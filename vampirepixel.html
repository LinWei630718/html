<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ÁçµÈ≠îÂÄñÂ≠òËÄÖ Demon Hunter Survivors</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Cinzel:wght@400;600;700&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0610; overflow: hidden; touch-action: none; user-select: none; }
canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
</style>
</head>
<body>
<canvas id="gc"></canvas>
<script>
'use strict';

// ====== POLYFILL: roundRect for older browsers ======
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (typeof r === 'number') r = [r, r, r, r];
    const [tl, tr, br, bl] = Array.isArray(r) ? r : [r, r, r, r];
    this.beginPath();
    this.moveTo(x + tl, y);
    this.lineTo(x + w - tr, y);
    this.quadraticCurveTo(x + w, y, x + w, y + tr);
    this.lineTo(x + w, y + h - br);
    this.quadraticCurveTo(x + w, y + h, x + w - br, y + h);
    this.lineTo(x + bl, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - bl);
    this.lineTo(x, y + tl);
    this.quadraticCurveTo(x, y, x + tl, y);
    this.closePath();
    return this;
  };
}

// ====== CANVAS SETUP ======
const CVS = document.getElementById('gc');
const CTX = CVS.getContext('2d');
let W, H;
const PI2 = Math.PI * 2;

function resize() {
  W = CVS.width = window.innerWidth;
  H = CVS.height = window.innerHeight;
  // Pixel art: disable smoothing
  CTX.imageSmoothingEnabled = false;
}
resize();
window.addEventListener('resize', resize);

// ====== PIXEL SIZE (8-bit look) ======
// All entity radii are 1.5x the old values (set directly in ENEMY_DEFS and player.r)
const PX = 2; // pixel block size for 8-bit rendering

// Draw a filled pixel-art rectangle (snaps to PX grid)
function pxRect(x, y, w, h, color) {
  CTX.fillStyle = color;
  CTX.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
}

// Draw a pixel-art circle as a blockish disc
function pxCircle(cx, cy, r, color) {
  CTX.fillStyle = color;
  const step = Math.max(1, Math.round(r * 0.4));
  for (let dy = -r; dy <= r; dy += step) {
    const hw = Math.sqrt(Math.max(0, r * r - dy * dy));
    CTX.fillRect(Math.round(cx - hw), Math.round(cy + dy), Math.round(hw * 2), step);
  }
}

// Draw outlined pixel rect (border only, 1 or 2 px thick)
function pxRectOutline(x, y, w, h, color, thick = 2) {
  CTX.fillStyle = color;
  CTX.fillRect(Math.round(x), Math.round(y), Math.round(w), thick);
  CTX.fillRect(Math.round(x), Math.round(y + h - thick), Math.round(w), thick);
  CTX.fillRect(Math.round(x), Math.round(y), thick, Math.round(h));
  CTX.fillRect(Math.round(x + w - thick), Math.round(y), thick, Math.round(h));
}

// ====== RESPONSIVE SCALE ======
function rw(base) { return base * Math.min(1, W / 480); }
function rh(base) { return base * Math.min(1, H / 860); }

// ====== UTILITY ======
function rand(a, b) { return Math.random() * (b - a) + a; }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
function dist(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); }
function angleTo(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function lerp(a, b, t) { return a + (b - a) * t; }
function rectOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}
function circleOverlap(ax, ay, ar, bx, by, br) {
  const dx = ax - bx, dy = ay - by;
  return dx * dx + dy * dy < (ar + br) * (ar + br);
}

// ====== QUADTREE ======
class QuadTree {
  constructor(x, y, w, h, depth = 0) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.depth = depth; this.items = []; this.children = null;
  }
  clear() { this.items.length = 0; this.children = null; }
  subdivide() {
    const hw = this.w / 2, hh = this.h / 2, d = this.depth + 1;
    this.children = [
      new QuadTree(this.x, this.y, hw, hh, d),
      new QuadTree(this.x + hw, this.y, hw, hh, d),
      new QuadTree(this.x, this.y + hh, hw, hh, d),
      new QuadTree(this.x + hw, this.y + hh, hw, hh, d)
    ];
  }
  insert(item) {
    if (!rectOverlap(this.x, this.y, this.w, this.h, item.x - item.r, item.y - item.r, item.r * 2, item.r * 2)) return;
    if (this.children) { for (const c of this.children) c.insert(item); return; }
    this.items.push(item);
    if (this.items.length > 8 && this.depth < 6) {
      this.subdivide();
      for (const it of this.items) for (const c of this.children) c.insert(it);
      this.items.length = 0;
    }
  }
  query(x, y, w, h, out) {
    if (!rectOverlap(this.x, this.y, this.w, this.h, x, y, w, h)) return out;
    if (this.children) { for (const c of this.children) c.query(x, y, w, h, out); }
    else { for (const it of this.items) if (out.indexOf(it) === -1) out.push(it); }
    return out;
  }
}

// ====== OBJECT POOL ======
class Pool {
  constructor(factory, size) {
    this.items = [];
    this.factory = factory;
    for (let i = 0; i < size; i++) { const o = factory(); o.active = false; this.items.push(o); }
  }
  get() {
    for (const o of this.items) if (!o.active) { o.active = true; return o; }
    const o = this.factory(); o.active = true; this.items.push(o); return o;
  }
  each(fn) { for (const o of this.items) if (o.active) fn(o); }
  count() { let c = 0; for (const o of this.items) if (o.active) c++; return c; }
}

// ====== CAMERA ======
const cam = { x: 0, y: 0 };
function toScreen(wx, wy) { return { x: Math.round(wx - cam.x + W / 2), y: Math.round(wy - cam.y + H / 2) }; }
function onScreen(wx, wy, margin = 80) {
  const sx = wx - cam.x + W / 2, sy = wy - cam.y + H / 2;
  return sx > -margin && sx < W + margin && sy > -margin && sy < H + margin;
}

// ====== DAMAGE TEXT ======
const dmgTexts = new Pool(() => ({ active: false, x: 0, y: 0, text: '', timer: 0, color: '#fff' }), 500);
function spawnDmgText(x, y, text, color = '#fff') {
  const t = dmgTexts.get();
  t.x = x + rand(-10, 10); t.y = y - 10; t.text = String(text); t.timer = 0.8; t.color = color;
}

// ====== PICKUPS ======
const GEM_COLORS = { 1: '#4466ff', 10: '#00cc44', 100: '#ff2244' };
const pickups = new Pool(() => ({ active: false, x: 0, y: 0, type: 'gem', value: 1, r: 9 }), 2000);
function spawnGem(x, y, value) {
  const p = pickups.get();
  p.x = x + rand(-8, 8); p.y = y + rand(-8, 8);
  p.type = 'gem'; p.value = value;
  p.r = value >= 100 ? 15 : value >= 10 ? 12 : 9;
}
function spawnChest(x, y) {
  const p = pickups.get(); p.x = x; p.y = y; p.type = 'chest'; p.value = 0; p.r = 24;
}
function spawnHeal(x, y) {
  const p = pickups.get(); p.x = x; p.y = y; p.type = 'heal'; p.value = 20; p.r = 12;
}

// ====== PLAYER ======
const player = {
  x: 0, y: 0, r: 18, // 1.5x original 12
  hp: 100, maxHp: 100,
  xp: 0, level: 1, xpToNext: 5,
  baseSpeed: 150,
  might: 1, area: 1, speed: 1, duration: 1, cooldown: 1, magnet: 40,
  weapons: [], passives: [],
  kills: 0, facing: 1, iFrames: 0, alive: true
};

function playerEffSpeed() { return player.baseSpeed * player.speed; }

const mouse = { x: 0, y: 0 };
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

// ====== INPUT ======
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; keys[e.code] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; keys[e.code] = false; });

// ====== UNIFIED UI BUTTON REGISTRY ======
const _uiButtons = [];
function registerBtn(x, y, w, h, state, fn) { _uiButtons.push({ x, y, w, h, state, fn }); }
function hitTestButtons(px, py) {
  for (const b of _uiButtons) {
    if (b.state === game.state && px >= b.x && px <= b.x + b.w && py >= b.y && py <= b.y + b.h) {
      b.fn(); return true;
    }
  }
  return false;
}
CVS.addEventListener('click', e => { hitTestButtons(e.clientX, e.clientY); });

// Virtual joystick
let touchId = null, touchStartX = 0, touchStartY = 0, touchDX = 0, touchDY = 0, touchActive = false;

CVS.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  const tx = t.clientX, ty = t.clientY;
  if (game.state === 'title' || game.state === 'weaponSelect' || game.state === 'gameover' ||
      game.state === 'victory' || game.state === 'levelup' || game.state === 'stageSelect') {
    if (hitTestButtons(tx, ty)) return;
    if (game.state === 'title') { game.start(); return; }
    if (game.state === 'gameover') { game.startNewGame(game.stage); return; }
    if (game.state === 'victory') { return; }  // victory: only button clicks should act
    return;
  }
  touchId = t.identifier;
  touchStartX = tx; touchStartY = ty;
  touchActive = true; touchDX = 0; touchDY = 0;
}, { passive: false });

CVS.addEventListener('touchmove', e => {
  e.preventDefault();
  if (game.state !== 'playing') return;
  for (const t of e.changedTouches) {
    if (t.identifier === touchId) {
      touchDX = t.clientX - touchStartX; touchDY = t.clientY - touchStartY;
      const mag = Math.sqrt(touchDX * touchDX + touchDY * touchDY);
      if (mag > 60) { touchDX = touchDX / mag * 60; touchDY = touchDY / mag * 60; }
    }
  }
}, { passive: false });

CVS.addEventListener('touchend', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === touchId) { touchActive = false; touchDX = 0; touchDY = 0; touchId = null; }
  }
}, { passive: false });

function getInputDir() {
  let dx = 0, dy = 0;
  if (keys['w'] || keys['arrowup'] || keys['ArrowUp']) dy -= 1;
  if (keys['s'] || keys['arrowdown'] || keys['ArrowDown']) dy += 1;
  if (keys['a'] || keys['arrowleft'] || keys['ArrowLeft']) dx -= 1;
  if (keys['d'] || keys['arrowright'] || keys['ArrowRight']) dx += 1;
  if (touchActive) {
    const mag = Math.sqrt(touchDX * touchDX + touchDY * touchDY);
    if (mag > 10) { dx = touchDX / mag; dy = touchDY / mag; }
  }
  const mag = Math.sqrt(dx * dx + dy * dy);
  if (mag > 0) { dx /= mag; dy /= mag; }
  return { x: dx, y: dy };
}

// ====== ENEMIES ======
// Base stats ‚Äî spawnEnemy applies hpMult for time and stage multiplier
const ENEMY_DEFS = {
  bat:      { hp: 5,      dmg: 2,  speed: 90,  r: 12,  color: '#a66', xp: 1,   knockback: 1   },
  skeleton: { hp: 10,     dmg: 5,  speed: 55,  r: 15,  color: '#cca', xp: 1,   knockback: 1   },
  ghost:    { hp: 20,     dmg: 5,  speed: 35,  r: 18,  color: '#88f', xp: 10,  knockback: 0.2 },
  zombie:   { hp: 30,     dmg: 8,  speed: 30,  r: 21,  color: '#4a4', xp: 1,   knockback: 1   },
  boss:     { hp: 3000,   dmg: 20, speed: 40,  r: 45,  color: '#f80', xp: 100, knockback: 0.3 },
  reaper:   { hp: 999999, dmg: 9999, speed: 60, r: 30, color: '#000', xp: 0,   knockback: 0   },
  // Stage 2 variants
  darkbat:  { hp: 15,     dmg: 4,  speed: 120, r: 12,  color: '#604', xp: 2,   knockback: 1   },
  lich:     { hp: 80,     dmg: 12, speed: 45,  r: 18,  color: '#88e', xp: 5,   knockback: 0.5 },
  gargoyle: { hp: 120,    dmg: 15, speed: 25,  r: 24,  color: '#666', xp: 5,   knockback: 0.8 },
  boss2:    { hp: 8000,   dmg: 30, speed: 50,  r: 48,  color: '#a00', xp: 200, knockback: 0.3 }
};

const enemies = new Pool(() => ({
  active: false, x: 0, y: 0, r: 10, hp: 10, maxHp: 10, dmg: 5, speed: 50,
  type: 'bat', color: '#a66', xp: 1, knockback: 1,
  kbx: 0, kby: 0, hitTimer: 0, flashTimer: 0
}), 1000);

function spawnEnemy(type, x, y) {
  const def = ENEMY_DEFS[type]; if (!def) return;
  const e = enemies.get();
  // HP scales with time (minutes) and stage
  const timeMult = 1 + game.time / 120;
  const stageMult = game.stage === 2 ? 2.5 : 1;
  e.x = x; e.y = y; e.type = type;
  e.hp = def.hp * timeMult * stageMult;
  e.maxHp = e.hp;
  e.dmg = def.dmg * (game.stage === 2 ? 1.5 : 1);
  e.speed = def.speed;
  e.r = def.r; e.color = def.color; e.xp = def.xp; e.knockback = def.knockback;
  e.kbx = 0; e.kby = 0; e.hitTimer = 0; e.flashTimer = 0;
  return e;
}

function spawnEnemyAtEdge(type) {
  const angle = rand(0, PI2);
  const d = Math.max(W, H) / 2 + 80;
  spawnEnemy(type, player.x + Math.cos(angle) * d, player.y + Math.sin(angle) * d);
}

// ====== BULLETS ======
const bullets = new Pool(() => ({
  active: false, x: 0, y: 0, vx: 0, vy: 0, r: 7, dmg: 10, pierce: 1, timer: 5,
  type: 'bullet', color: '#ff0', hitSet: null,
  ownerOffsetAngle: 0, orbitRadius: 0, orbitSpeed: 0
}), 500);

function fireBullet(x, y, angle, speed, dmg, r, pierce, timer, color, type) {
  const b = bullets.get();
  b.x = x; b.y = y;
  b.vx = Math.cos(angle) * speed; b.vy = Math.sin(angle) * speed;
  b.r = r; b.dmg = dmg; b.pierce = pierce; b.timer = timer;
  b.color = color; b.type = type || 'bullet';
  b.hitSet = new Set();
  b.ownerOffsetAngle = 0; b.orbitRadius = 0; b.orbitSpeed = 0;
  return b;
}

// ====== WEAPON DEFINITIONS ======
const WEAPON_DEFS = {
  whip: {
    name: 'ÁöÆÈû≠ Whip', icon: 'ü™¢', maxLv: 8,
    base: { dmg: 10, cd: 1.5, areaW: 100, areaH: 50, pierce: 999, dur: 0.3 },
    lvUp: (w) => { w.dmg += 3; w.areaW += 15; if (w.level % 2 === 0) w.cd = Math.max(0.5, w.cd - 0.1); },
    fire: (w, dt) => {
      w.cdTimer -= dt;
      if (w.cdTimer > 0) return;
      w.cdTimer = w.cd * player.cooldown;
      const aw = w.areaW * player.area, ah = w.areaH * player.area;
      const hx = player.x + player.facing * aw / 2;
      const b = fireBullet(hx, player.y, 0, 0, w.dmg * player.might, Math.max(aw, ah) / 2, 999, w.dur * player.duration, 'rgba(255,255,200,0.5)', 'melee');
      b.mw = aw; b.mh = ah; b.mx = hx - aw / 2; b.my = player.y - ah / 2;
    }
  },
  wand: {
    name: 'È≠îÊùñ Magic Wand', icon: 'ü™Ñ', maxLv: 8,
    base: { dmg: 15, cd: 1.0, speed: 300, projCount: 1, pierce: 1 },
    lvUp: (w) => { w.dmg += 3; if (w.level % 2 === 0) w.projCount += 1; if (w.level >= 6) w.pierce += 1; },
    fire: (w, dt) => {
      w.cdTimer -= dt;
      if (w.cdTimer > 0) return;
      w.cdTimer = w.cd * player.cooldown;
      for (let i = 0; i < w.projCount; i++) {
        const target = findNearest(player, i);
        if (!target) return;
        const a = angleTo(player, target);
        const px = player.x, py = player.y, spd = w.speed * player.speed, dmg = w.dmg * player.might, prc = w.pierce;
        setTimeout(() => {
          if (game.state !== 'playing') return;
          fireBullet(px, py, a, spd, dmg, 7, prc, 3, '#aaf', 'bullet');
        }, i * 80);
      }
    }
  },
  axe: {
    name: 'È£õÊñß Axe', icon: 'ü™ì', maxLv: 8,
    base: { dmg: 20, cd: 1.5, projCount: 1, pierce: 2, area: 15 },
    lvUp: (w) => { w.dmg += 5; if (w.level % 2 === 0) w.projCount += 1; w.pierce += 1; },
    fire: (w, dt) => {
      w.cdTimer -= dt;
      if (w.cdTimer > 0) return;
      w.cdTimer = w.cd * player.cooldown;
      for (let i = 0; i < w.projCount; i++) {
        const spread = (i - (w.projCount - 1) / 2) * 0.3;
        const a = -Math.PI / 2 + spread + rand(-0.2, 0.2);
        const b = fireBullet(player.x, player.y, a, 250 * player.speed, w.dmg * player.might, w.area * player.area, w.pierce, 3, '#c84', 'axe');
        b.gravity = 200; b.spin = rand(-8, 8);
      }
    }
  },
  bible: {
    name: 'ËÅñÁ∂ì King Bible', icon: 'üìñ', maxLv: 8,
    base: { dmg: 5, cd: 3.0, dur: 3, orbCount: 1, orbitR: 70, orbitSpeed: 3, area: 12 },
    lvUp: (w) => { w.dmg += 2; w.dur += 0.5; if (w.level % 2 === 0) w.orbCount += 1; w.orbitR += 5; w.orbitSpeed += 0.2; },
    fire: (w, dt) => {
      w.cdTimer -= dt;
      if (w.cdTimer > 0) return;
      if (w._orbiting) return;
      w.cdTimer = w.cd * player.cooldown;
      w._orbiting = true;
      w._orbTimer = w.dur * player.duration;
      w._orbs = [];
      for (let i = 0; i < w.orbCount; i++) {
        const b = fireBullet(player.x, player.y, 0, 0, w.dmg * player.might, w.area * player.area, 999, w.dur * player.duration + 0.5, '#ff8', 'bible');
        b.ownerOffsetAngle = (PI2 / w.orbCount) * i;
        b.orbitRadius = w.orbitR * player.area;
        b.orbitSpeed = w.orbitSpeed;
        b.hitSet = new Set();
        b._hitResetTimer = 0;
        w._orbs.push(b);
      }
    },
    update: (w, dt) => {
      if (!w._orbiting) return;
      w._orbTimer -= dt;
      if (w._orbTimer <= 0) { w._orbiting = false; for (const b of w._orbs) b.active = false; w._orbs = []; return; }
      w._orbAngle = (w._orbAngle || 0) + w.orbitSpeed * dt;
      w._orbs = w._orbs.filter(b => b.active);
      if (w._orbs.length === 0) { w._orbiting = false; return; }
      for (const b of w._orbs) {
        b.x = player.x + Math.cos(w._orbAngle + b.ownerOffsetAngle) * b.orbitRadius;
        b.y = player.y + Math.sin(w._orbAngle + b.ownerOffsetAngle) * b.orbitRadius;
        b._hitResetTimer = (b._hitResetTimer || 0) + dt;
        if (b._hitResetTimer > 0.3) { b._hitResetTimer = 0; b.hitSet.clear(); }
      }
    }
  },
  firewand: {
    name: 'ÁÅ´ÁêÉ Fire Wand', icon: 'üî•', maxLv: 8,
    base: { dmg: 30, cd: 1.2, speed: 200, pierce: 1 },
    lvUp: (w) => { w.dmg += 8; if (w.level >= 4) w.pierce += 1; },
    fire: (w, dt) => {
      w.cdTimer -= dt;
      if (w.cdTimer > 0) return;
      w.cdTimer = w.cd * player.cooldown;
      const candidates = [];
      enemies.each(e => { if (dist(player, e) < 600) candidates.push(e); });
      const target = candidates.length > 0 ? candidates[randInt(0, candidates.length - 1)] : null;
      const a = target ? angleTo(player, target) : rand(0, PI2);
      fireBullet(player.x, player.y, a, w.speed * player.speed, w.dmg * player.might, 10, w.pierce, 4, '#f60', 'fireball');
    }
  },
  // === Stage 2 extra weapons ===
  lightning: {
    name: 'ÈñÉÈõª Lightning', icon: '‚ö°', maxLv: 8,
    base: { dmg: 40, cd: 1.8, chainCount: 2, range: 250 },
    lvUp: (w) => { w.dmg += 10; if (w.level % 2 === 0) w.chainCount += 1; w.range += 20; },
    fire: (w, dt) => {
      w.cdTimer -= dt;
      if (w.cdTimer > 0) return;
      w.cdTimer = w.cd * player.cooldown;
      // strike nearest enemy, chain to adjacent
      const sorted = [];
      enemies.each(e => { const d = dist(player, e); if (d < w.range) sorted.push({ e, d }); });
      sorted.sort((a, b) => a.d - b.d);
      const hit = new Set();
      let last = null;
      for (let i = 0; i < Math.min(w.chainCount, sorted.length); i++) {
        const { e } = sorted[i];
        if (hit.has(e)) continue;
        hit.add(e);
        damageEnemy(e, w.dmg * player.might);
        // lightning bolt visual
        const b = fireBullet(last ? last.x : player.x, last ? last.y : player.y, angleTo(last || player, e), 0, 0, 5, 0, 0.15, '#ccffff', 'lightning');
        b.lx2 = e.x; b.ly2 = e.y;
        last = e;
      }
    }
  },
  cross: {
    name: 'ÂçÅÂ≠óÊû∂ Holy Cross', icon: '‚úùÔ∏è', maxLv: 8,
    base: { dmg: 25, cd: 2.0, pierce: 5, speed: 280 },
    lvUp: (w) => { w.dmg += 6; w.pierce += 2; if (w.level % 3 === 0) w.cd = Math.max(0.8, w.cd - 0.2); },
    fire: (w, dt) => {
      w.cdTimer -= dt;
      if (w.cdTimer > 0) return;
      w.cdTimer = w.cd * player.cooldown;
      // Fire in all 4 directions
      for (let i = 0; i < 4; i++) {
        const a = (Math.PI / 2) * i;
        fireBullet(player.x, player.y, a, w.speed * player.speed, w.dmg * player.might, 9, w.pierce, 3, '#ffffcc', 'cross');
      }
    }
  },
  shadow: {
    name: 'ÊöóÂΩ±ÂàÉ Shadow Blade', icon: 'üó°', maxLv: 8,
    base: { dmg: 50, cd: 2.5, projCount: 3, speed: 350, pierce: 1 },
    lvUp: (w) => { w.dmg += 12; if (w.level % 2 === 0) w.projCount += 1; if (w.level >= 5) w.pierce += 1; },
    fire: (w, dt) => {
      w.cdTimer -= dt;
      if (w.cdTimer > 0) return;
      w.cdTimer = w.cd * player.cooldown;
      const target = findNearest(player);
      const baseAngle = target ? angleTo(player, target) : 0;
      for (let i = 0; i < w.projCount; i++) {
        const spread = (i - (w.projCount - 1) / 2) * 0.18;
        const px = player.x, py = player.y, spd = w.speed * player.speed, dmg = w.dmg * player.might, prc = w.pierce;
        setTimeout(() => {
          if (game.state !== 'playing') return;
          fireBullet(px, py, baseAngle + spread, spd, dmg, 8, prc, 2.5, '#aa44ff', 'shadow');
        }, i * 60);
      }
    }
  }
};

function createWeapon(type) {
  const def = WEAPON_DEFS[type];
  return { type, level: 1, cdTimer: 0, ...def.base, _orbiting: false, _orbs: [], _orbAngle: 0, _orbTimer: 0 };
}

function upgradeWeapon(w) {
  if (w.level >= WEAPON_DEFS[w.type].maxLv) return;
  w.level++;
  WEAPON_DEFS[w.type].lvUp(w);
}

function findNearest(from, skip = 0) {
  const sorted = [];
  enemies.each(e => { sorted.push({ e, d: dist(from, e) }); });
  sorted.sort((a, b) => a.d - b.d);
  return sorted.length > skip ? sorted[skip].e : null;
}

// ====== PASSIVE DEFINITIONS ======
const PASSIVE_DEFS = {
  spinach:    { name: 'Ëè†Ëèú Spinach',         icon: 'ü•¨', maxLv: 5, desc: 'ÂÇ∑ÂÆ≥ +10%',   apply: (lv) => { player.might = 1 + lv * 0.1; } },
  heart:      { name: 'Á©∫Ëôõ‰πãÂøÉ Hollow Heart', icon: 'üíú', maxLv: 5, desc: 'ÊúÄÂ§ßHP +20%', apply: (lv) => { player.maxHp = 100 * (1 + lv * 0.2); if (player.hp > player.maxHp) player.hp = player.maxHp; } },
  candle:     { name: 'Áá≠Âè∞ Candelabrador',   icon: 'üïØÔ∏è', maxLv: 5, desc: 'ÁØÑÂúç +10%',   apply: (lv) => { player.area = 1 + lv * 0.1; } },
  bracer:     { name: 'Ë≠∑ËÖï Bracer',          icon: 'ü¶æ', maxLv: 5, desc: 'ÈÄüÂ∫¶ +10%',   apply: (lv) => { player.speed = 1 + lv * 0.1; } },
  tome:       { name: 'È≠îÊ≥ïÊõ∏ Empty Tome',    icon: 'üìï', maxLv: 5, desc: 'ÂÜ∑Âçª -8%',    apply: (lv) => { player.cooldown = Math.max(0.3, 1 - lv * 0.08); } },
  attractorb: { name: 'Âê∏ÂºïÂô® Attractorb',    icon: 'üß≤', maxLv: 5, desc: 'ÊãæÂèñÁØÑÂúç +30%', apply: (lv) => { player.magnet = 40 * (1 + lv * 0.3); } },
  // Stage 2 passives
  clover:     { name: 'Âπ∏ÈÅãËçâ Lucky Clover',  icon: 'üçÄ', maxLv: 5, desc: 'Êö¥Êìä +10%',   apply: (lv) => { player.critChance = lv * 0.1; } },
  wings:      { name: 'ÊÉ°È≠îÁøº Demon Wings',   icon: 'ü¶Ö', maxLv: 5, desc: 'ÈÄüÂ∫¶ +15%',   apply: (lv) => { player.speed = Math.min(3, (player.speed || 1) + lv * 0.15); } },
  soul:       { name: 'ÈùàÈ≠ÇËÉΩÈáè Soul Power',  icon: 'üîÆ', maxLv: 5, desc: 'ÂÇ∑ÂÆ≥ +15%',   apply: (lv) => { player.might = Math.min(5, (player.might || 1) + lv * 0.15); } },
  armor:      { name: 'ÊöóÈêµË≠∑Áî≤ Dark Armor',  icon: 'üõ°', maxLv: 5, desc: 'ÂèóÂÇ∑Ê∏õÂ∞ë 10%', apply: (lv) => { player.armor = lv * 0.1; } }
};

function getPassiveLevel(type) {
  const p = player.passives.find(p => p.type === type); return p ? p.level : 0;
}

function addOrUpgradePassive(type) {
  let p = player.passives.find(p => p.type === type);
  if (p) { if (p.level < PASSIVE_DEFS[type].maxLv) p.level++; }
  else { player.passives.push({ type, level: 1 }); }
  applyPassives();
}

function applyPassives() {
  player.might = 1; player.area = 1; player.speed = 1; player.duration = 1;
  player.cooldown = 1; player.magnet = 40; player.maxHp = 100;
  player.critChance = 0; player.armor = 0;
  for (const p of player.passives) PASSIVE_DEFS[p.type].apply(p.level);
}

// ====== LEVEL UP ======
function xpNeeded(level) {
  if (level === 1) return 5;
  if (level === 2) return 10;
  return Math.floor(10 * Math.pow(1.15, level - 2));
}

function addXP(amount) {
  player.xp += amount;
  while (player.xp >= player.xpToNext) {
    player.xp -= player.xpToNext;
    player.level++;
    player.xpToNext = xpNeeded(player.level);
    showLevelUpScreen();
  }
}

// Available weapon/passive pools per stage
function getAvailableWeapons() {
  if (game.stage === 1) return ['whip', 'wand', 'axe', 'bible', 'firewand'];
  return ['whip', 'wand', 'axe', 'bible', 'firewand', 'lightning', 'cross', 'shadow'];
}
function getAvailablePassives() {
  if (game.stage === 1) return ['spinach', 'heart', 'candle', 'bracer', 'tome', 'attractorb'];
  return ['spinach', 'heart', 'candle', 'bracer', 'tome', 'attractorb', 'clover', 'wings', 'soul', 'armor'];
}

// Max slots per stage
function maxWeaponSlots() { return game.stage === 1 ? 3 : 4; }
function maxPassiveSlots() { return game.stage === 1 ? 3 : 4; }

function generateChoices() {
  const pool = [];
  const weaponTypes = getAvailableWeapons();
  const passiveTypes = getAvailablePassives();

  for (const w of player.weapons) {
    if (w.level < WEAPON_DEFS[w.type].maxLv)
      pool.push({ cat: 'weapon', type: w.type, isNew: false, level: w.level + 1 });
  }
  if (player.weapons.length < maxWeaponSlots()) {
    for (const t of weaponTypes) {
      if (!player.weapons.find(w => w.type === t))
        pool.push({ cat: 'weapon', type: t, isNew: true, level: 1 });
    }
  }
  for (const p of player.passives) {
    if (p.level < PASSIVE_DEFS[p.type].maxLv)
      pool.push({ cat: 'passive', type: p.type, isNew: false, level: p.level + 1 });
  }
  if (player.passives.length < maxPassiveSlots()) {
    for (const t of passiveTypes) {
      if (!player.passives.find(p => p.type === t))
        pool.push({ cat: 'passive', type: t, isNew: true, level: 1 });
    }
  }

  for (let i = pool.length - 1; i > 0; i--) {
    const j = randInt(0, i); [pool[i], pool[j]] = [pool[j], pool[i]];
  }
  return pool.slice(0, 3);
}

let levelUpChoices = [];
function showLevelUpScreen() {
  levelUpChoices = generateChoices();
  if (levelUpChoices.length === 0) return; // no upgrades available, skip
  game.state = 'levelup';
}

function selectChoice(idx) {
  const c = levelUpChoices[idx]; if (!c) return;
  if (c.cat === 'weapon') {
    if (c.isNew) player.weapons.push(createWeapon(c.type));
    else { const w = player.weapons.find(w => w.type === c.type); if (w) upgradeWeapon(w); }
  } else { addOrUpgradePassive(c.type); }
  game.state = 'playing';
}

// ====== CHEST LOGIC ======
function openChest() {
  const numUpgrades = randInt(1, 3);
  for (let i = 0; i < numUpgrades; i++) {
    const choices = generateChoices();
    if (choices.length > 0) {
      const c = choices[0];
      if (c.cat === 'weapon') {
        if (c.isNew) player.weapons.push(createWeapon(c.type));
        else { const w = player.weapons.find(w => w.type === c.type); if (w) upgradeWeapon(w); }
      } else { addOrUpgradePassive(c.type); }
    }
  }
  spawnDmgText(player.x, player.y - 30, 'ÂØ∂ÁÆ±! +' + numUpgrades + ' ÂçáÁ¥ö', '#ff0');
}

// ====== WAVE SYSTEM ======
const waveSystem = {
  bossSpawned: false,
  reaperSpawned: false,
  boss2Count: 0,  // stage 2: how many boss2 spawned
  _spawnAccum: 0,
  _nextBoss2Time: 5 * 60, // 5 min

  init() {
    this.bossSpawned = false;
    this.reaperSpawned = false;
    this.boss2Count = 0;
    this._spawnAccum = 0;
    this._nextBoss2Time = 5 * 60;
  },

  update(dt) {
    const t = game.time;

    if (game.stage === 1) {
      // Stage 1 wave logic
      const spawnRate = this.getSpawnRate1(t);
      this._spawnAccum += dt * spawnRate;
      while (this._spawnAccum >= 1) { this._spawnAccum -= 1; this.spawnS1Enemy(t); }

      // Boss at 3 min
      if (t >= 180 && !this.bossSpawned) {
        this.bossSpawned = true;
        spawnEnemyAtEdge('boss');
        spawnDmgText(player.x, player.y - 50, '‚ö† BOSS Âá∫Áèæ!', '#f80');
      }

      // Victory at 10 min
      if (t >= 600) { game.state = 'victory'; return; }

    } else { // game.stage === 2
      // Stage 2 wave logic
      const spawnRate = this.getSpawnRate2(t);
      this._spawnAccum += dt * spawnRate;
      while (this._spawnAccum >= 1) { this._spawnAccum -= 1; this.spawnS2Enemy(t); }

      // Boss2 spawns every 5 min, max 3 times
      if (this.boss2Count < 3 && t >= this._nextBoss2Time) {
        this.boss2Count++;
        this._nextBoss2Time += 5 * 60;
        spawnEnemyAtEdge('boss2');
        spawnDmgText(player.x, player.y - 60, '‚ö† ÊÉ°È≠îÁéãÈôçËá®! (' + this.boss2Count + '/3)', '#ff4400');
        game.shake(8, 0.4);
      }

      // Reaper at 18 min in stage 2
      if (t >= 1080 && !this.reaperSpawned) {
        this.reaperSpawned = true;
        spawnEnemyAtEdge('reaper');
        spawnDmgText(player.x, player.y - 50, '‚ò† Ê≠ªÁ•ûÈôçËá®!', '#f00');
      }

      // Victory at 20 min
      if (t >= 1200) { game.state = 'victory'; return; }
    }
  },

  getSpawnRate1(t) {
    if (t < 60) return 1.5; if (t < 180) return 2.5;
    if (t < 300) return 4;  if (t < 480) return 5; return 7;
  },
  getSpawnRate2(t) {
    if (t < 120) return 3;   if (t < 360) return 5;
    if (t < 600) return 7;   if (t < 900) return 9; return 12;
  },

  spawnS1Enemy(t) {
    if (enemies.count() > 500) return;
    let type;
    if (t < 60) type = 'bat';
    else if (t < 180) type = Math.random() < 0.6 ? 'bat' : 'skeleton';
    else if (t < 300) type = Math.random() < 0.5 ? 'skeleton' : 'zombie';
    else if (t < 480) type = Math.random() < 0.5 ? 'ghost' : 'bat';
    else {
      const r = Math.random();
      if (r < 0.25) type = 'bat'; else if (r < 0.5) type = 'skeleton';
      else if (r < 0.75) type = 'zombie'; else type = 'ghost';
    }
    spawnEnemyAtEdge(type);
  },

  spawnS2Enemy(t) {
    if (enemies.count() > 600) return;
    const r = Math.random();
    let type;
    if (t < 120) { type = r < 0.5 ? 'darkbat' : 'skeleton'; }
    else if (t < 360) { type = r < 0.4 ? 'lich' : (r < 0.7 ? 'gargoyle' : 'darkbat'); }
    else if (t < 600) { type = r < 0.35 ? 'lich' : (r < 0.65 ? 'gargoyle' : (r < 0.85 ? 'ghost' : 'zombie')); }
    else { type = r < 0.3 ? 'lich' : (r < 0.6 ? 'gargoyle' : (r < 0.8 ? 'ghost' : 'zombie')); }
    spawnEnemyAtEdge(type);
  }
};

// ====== GAME STATE ======
const game = {
  state: 'title', // title | weaponSelect | playing | levelup | gameover | victory | stageSelect
  selectedWeapon: 'whip',
  stage: 1,
  time: 0,
  shakeTimer: 0, shakeIntensity: 0,

  reset(weaponType, stage) {
    game.stage = stage || 1;
    player.x = 0; player.y = 0; player.hp = 100; player.maxHp = 100;
    player.xp = 0; player.level = 1; player.xpToNext = 5;
    player.might = 1; player.area = 1; player.speed = 1; player.duration = 1;
    player.cooldown = 1; player.magnet = 40; player.critChance = 0; player.armor = 0;
    player.weapons = [createWeapon(weaponType || this.selectedWeapon || 'whip')];
    player.passives = [];
    player.kills = 0; player.facing = 1; player.iFrames = 0; player.alive = true;
    enemies.items.forEach(e => e.active = false);
    bullets.items.forEach(b => b.active = false);
    pickups.items.forEach(p => p.active = false);
    dmgTexts.items.forEach(t => t.active = false);
    this.time = 0;
    this.shakeTimer = 0;
    this.shakeIntensity = 0;
    cam.x = 0; cam.y = 0;
    waveSystem.init();
    this.state = 'playing';
  },

  start() { this.state = 'weaponSelect'; },

  startNewGame(stage) {
    this.stage = stage || 1;
    this.selectedWeapon = 'whip'; // reset to safe default
    this.state = 'weaponSelect';
  },

  shake(intensity, dur) { this.shakeIntensity = intensity; this.shakeTimer = dur; }
};

// ====== PIXEL ART GROUND ======
function drawGround() {
  // Dark pixel background
  CTX.fillStyle = '#0d0818';
  CTX.fillRect(0, 0, W, H);

  // Pixel grid tiles (stone floor effect)
  const tileSize = 48;
  const startX = Math.floor((cam.x - W / 2) / tileSize) * tileSize;
  const startY = Math.floor((cam.y - H / 2) / tileSize) * tileSize;

  for (let tx = startX; tx < cam.x + W / 2 + tileSize; tx += tileSize) {
    for (let ty = startY; ty < cam.y + H / 2 + tileSize; ty += tileSize) {
      const sx = Math.round(tx - cam.x + W / 2);
      const sy = Math.round(ty - cam.y + H / 2);
      // Checkerboard-ish pixel stone
      const odd = (Math.floor(tx / tileSize) + Math.floor(ty / tileSize)) % 2;
      CTX.fillStyle = odd ? '#120920' : '#0e0718';
      CTX.fillRect(sx, sy, tileSize, tileSize);
      // Tile border (1px)
      CTX.fillStyle = 'rgba(80,30,120,0.15)';
      CTX.fillRect(sx, sy, tileSize, 1);
      CTX.fillRect(sx, sy, 1, tileSize);
    }
  }

  // Stage 2: red tint overlay
  if (game.stage === 2) {
    CTX.fillStyle = 'rgba(80,0,0,0.10)';
    CTX.fillRect(0, 0, W, H);
  }
}

// ====== 8-BIT SPRITE HELPERS ======
// Each sprite is drawn as chunky pixel blocks

function drawPixelBat(r, flash) {
  const p = Math.round(r / 4); // pixel unit
  const flapT = (Date.now() / 140) % PI2;
  const wa = Math.sin(flapT) * 0.6;
  const col = flash ? '#fff' : '#7a3a6a';
  const col2 = flash ? '#fff' : '#5a2a50';
  const eyeCol = flash ? '#fff' : '#ff2222';

  // Wings ‚Äî L
  CTX.save(); CTX.rotate(-wa - 0.25);
  pxRect(-r*2.0, -r*0.4, r*2.0, r*0.5, col);
  CTX.restore();
  // Wings ‚Äî R
  CTX.save(); CTX.rotate(wa + 0.25);
  pxRect(0, -r*0.4, r*2.0, r*0.5, col);
  CTX.restore();
  // Body
  pxRect(-r*0.7, -r*0.85, r*1.4, r*1.5, col2);
  // Ears
  pxRect(-r*0.55, -r*1.4, r*0.4, r*0.6, col);
  pxRect(r*0.15, -r*1.4, r*0.4, r*0.6, col);
  // Eyes
  pxRect(-r*0.45, -r*0.3, r*0.35, r*0.35, eyeCol);
  pxRect(r*0.10, -r*0.3, r*0.35, r*0.35, eyeCol);
  // Fangs
  pxRect(-r*0.3, r*0.6, r*0.2, r*0.35, '#eee');
  pxRect(r*0.10, r*0.6, r*0.2, r*0.35, '#eee');
}

function drawPixelSkeleton(r, flash) {
  const col = flash ? '#fff' : '#d0c8a8';
  const dark = flash ? '#ccc' : '#908870';
  const eye = flash ? '#fff' : '#44ff22';
  // Body
  pxRect(-r*0.55, 0, r*1.1, r*0.9, col);
  // Skull
  pxRect(-r*0.5, -r*1.0, r*1.0, r*1.0, col);
  // Eye sockets
  pxRect(-r*0.38, -r*0.82, r*0.28, r*0.35, '#111');
  pxRect(r*0.10, -r*0.82, r*0.28, r*0.35, '#111');
  // Soul fire in eyes
  pxRect(-r*0.33, -r*0.78, r*0.18, r*0.26, eye);
  pxRect(r*0.15, -r*0.78, r*0.18, r*0.26, eye);
  // Jaw
  pxRect(-r*0.4, -r*0.12, r*0.8, r*0.18, col);
  // Ribs (3 lines)
  for (let i = 0; i < 3; i++) {
    pxRect(-r*0.48, r*0.12 + i*r*0.25, r*0.96, r*0.12, dark);
  }
  // Arms
  pxRect(-r*0.9, -r*0.1, r*0.38, r*0.7, col);
  pxRect(r*0.52, -r*0.1, r*0.38, r*0.7, col);
}

function drawPixelGhost(r, flash) {
  const bob = Math.sin(Date.now() / 380) * r * 0.12;
  const col = flash ? '#fff' : '#9999ee';
  const dark = flash ? '#ddd' : '#6666cc';
  CTX.save(); CTX.translate(0, bob);
  // Body (rounded top, wavy bottom via rects)
  pxRect(-r*0.85, -r*0.9, r*1.7, r*1.4, col);
  // Wavy bottom (3 bumps via dark cutouts)
  pxRect(-r*0.85, r*0.45, r*0.6, r*0.25, dark);
  pxRect(-r*0.05, r*0.45, r*0.6, r*0.25, dark);
  pxRect(r*0.45, r*0.45, r*0.4, r*0.25, dark);
  // Eyes
  pxRect(-r*0.48, -r*0.5, r*0.4, r*0.44, '#111');
  pxRect(r*0.08, -r*0.5, r*0.4, r*0.44, '#111');
  // Eye shine
  pxRect(-r*0.38, -r*0.48, r*0.15, r*0.15, 'rgba(180,200,255,0.7)');
  pxRect(r*0.18, -r*0.48, r*0.15, r*0.15, 'rgba(180,200,255,0.7)');
  CTX.restore();
}

function drawPixelZombie(r, flash) {
  const stagger = Math.sin(Date.now() / 260) * 0.08;
  CTX.rotate(stagger);
  const col = flash ? '#fff' : '#4a6a30';
  const skin = flash ? '#fff' : '#8aaa58';
  const eye = flash ? '#fff' : '#bbaa00';
  // Body
  pxRect(-r*0.6, -r*0.05, r*1.2, r*0.85, col);
  // Clothing tears
  pxRect(-r*0.35, r*0.15, r*0.2, r*0.55, '#2a4a18');
  pxRect(r*0.15, r*0.22, r*0.2, r*0.4, '#2a4a18');
  // Head
  pxRect(-r*0.52, -r*1.0, r*1.04, r*1.0, skin);
  // Decay patches
  pxRect(-r*0.15, -r*0.8, r*0.3, r*0.3, '#3a5a28');
  pxRect(r*0.2, -r*0.55, r*0.25, r*0.2, '#3a5a28');
  // Eyes
  pxRect(-r*0.38, -r*0.78, r*0.28, r*0.26, eye);
  pxRect(r*0.10, -r*0.78, r*0.28, r*0.26, eye);
  pxRect(-r*0.32, -r*0.74, r*0.12, r*0.14, '#2a1000');
  pxRect(r*0.16, -r*0.74, r*0.12, r*0.14, '#2a1000');
  // Mouth
  pxRect(-r*0.35, -r*0.38, r*0.7, r*0.22, '#1a0808');
  // Broken teeth
  pxRect(-r*0.24, -r*0.38, r*0.14, r*0.15, '#d8cca8');
  pxRect(r*0.10, -r*0.38, r*0.14, r*0.15, '#d8cca8');
  // Arms (outstretched)
  pxRect(r*0.6, -r*0.15, r*0.7, r*0.35, col);
  pxRect(-r*1.3, -r*0.25, r*0.7, r*0.35, col);
}

function drawPixelBoss(r, flash) {
  const pulse = 1 + Math.sin(Date.now() / 200) * 0.04;
  CTX.scale(pulse, pulse);
  const col = flash ? '#fff' : '#cc2200';
  const dark = flash ? '#ddd' : '#880000';
  const eye = flash ? '#fff' : '#ff8800';
  // Body
  pxRect(-r*0.9, -r*0.6, r*1.8, r*1.4, dark);
  pxRect(-r*0.75, -r*0.85, r*1.5, r*1.2, col);
  // Armor plates
  pxRect(-r*0.65, -r*0.3, r*1.3, r*0.55, '#440000');
  pxRect(-r*0.5, -r*0.6, r*1.0, r*0.35, '#550000');
  // Horns (pixel triangles)
  pxRect(-r*0.8, -r*1.55, r*0.35, r*0.7, '#110000');
  pxRect(-r*0.65, -r*1.8, r*0.2, r*0.3, '#110000');
  pxRect(r*0.45, -r*1.55, r*0.35, r*0.7, '#110000');
  pxRect(r*0.45, -r*1.8, r*0.2, r*0.3, '#110000');
  // Horn glow
  pxRect(-r*0.7, -r*1.6, r*0.25, r*0.55, 'rgba(255,80,0,0.4)');
  pxRect(r*0.45, -r*1.6, r*0.25, r*0.55, 'rgba(255,80,0,0.4)');
  // Face
  pxRect(-r*0.6, -r*0.78, r*1.2, r*0.85, '#8a1800');
  // Eyes
  pxRect(-r*0.5, -r*0.62, r*0.38, r*0.34, eye);
  pxRect(r*0.12, -r*0.62, r*0.38, r*0.34, eye);
  pxRect(-r*0.38, -r*0.58, r*0.1, r*0.26, '#110000');
  pxRect(r*0.28, -r*0.58, r*0.1, r*0.26, '#110000');
  // Mouth
  pxRect(-r*0.42, -r*0.16, r*0.84, r*0.28, '#080000');
  // Fangs
  pxRect(-r*0.32, -r*0.16, r*0.18, r*0.22, '#eee');
  pxRect(r*0.14, -r*0.16, r*0.18, r*0.22, '#eee');
}

function drawPixelBoss2(r, flash) {
  // Stage 2 Boss ‚Äî darker, more armored
  const pulse = 1 + Math.sin(Date.now() / 160) * 0.06;
  CTX.scale(pulse, pulse);
  const col = flash ? '#fff' : '#aa0000';
  const arm = flash ? '#ddd' : '#333344';
  const eye = flash ? '#fff' : '#ff00aa';
  // Huge body
  pxRect(-r*1.0, -r*0.7, r*2.0, r*1.6, '#220011');
  pxRect(-r*0.85, -r*0.95, r*1.7, r*1.4, col);
  // Heavy armor
  pxRect(-r*0.8, -r*0.5, r*1.6, r*0.7, arm);
  pxRect(-r*0.6, -r*0.8, r*1.2, r*0.35, arm);
  // Shoulder spikes
  pxRect(-r*1.1, -r*0.8, r*0.3, r*0.55, '#111122');
  pxRect(r*0.8, -r*0.8, r*0.3, r*0.55, '#111122');
  // Double horns
  for (let s = -1; s <= 1; s += 2) {
    pxRect(s*r*0.8, -r*1.7, r*0.28, r*0.8, '#110000');
    pxRect(s*r*0.55, -r*1.9, r*0.22, r*0.4, '#220011');
  }
  // Eyes (3)
  pxRect(-r*0.55, -r*0.62, r*0.3, r*0.3, eye);
  pxRect(r*0.25, -r*0.62, r*0.3, r*0.3, eye);
  pxRect(-r*0.12, -r*0.7, r*0.24, r*0.22, '#ffff00');
  // Mouth
  pxRect(-r*0.5, -r*0.18, r*1.0, r*0.32, '#080000');
  pxRect(-r*0.38, -r*0.18, r*0.2, r*0.26, '#eee');
  pxRect(r*0.18, -r*0.18, r*0.2, r*0.26, '#eee');
  pxRect(-r*0.06, -r*0.18, r*0.12, r*0.26, '#eee');
}

function drawPixelReaper(r, flash) {
  const sway = Math.sin(Date.now() / 450) * 0.07;
  CTX.rotate(sway);
  const cloak = flash ? '#fff' : '#150025';
  const pur = flash ? '#ddd' : '#8800cc';
  // Cloak body (trapezoid via rects)
  pxRect(-r*0.85, -r*0.75, r*1.7, r*1.8, cloak);
  pxRect(-r*0.75, -r*0.95, r*1.5, r*0.25, cloak);
  // Cloak shading / folds
  pxRect(-r*0.7, -r*0.7, r*0.18, r*1.6, 'rgba(0,0,0,0.35)');
  pxRect(r*0.52, -r*0.7, r*0.18, r*1.6, 'rgba(0,0,0,0.35)');
  // Hood
  pxRect(-r*0.6, -r*1.2, r*1.2, r*0.5, '#050010');
  pxRect(-r*0.45, -r*1.5, r*0.9, r*0.35, '#050010');
  // Skull face
  pxRect(-r*0.32, -r*1.2, r*0.64, r*0.55, '#ccc8b0');
  // Eye sockets
  pxRect(-r*0.28, -r*1.1, r*0.22, r*0.24, '#111');
  pxRect(r*0.06, -r*1.1, r*0.22, r*0.24, '#111');
  // Glowing eyes
  pxRect(-r*0.24, -r*1.06, r*0.14, r*0.16, pur);
  pxRect(r*0.10, -r*1.06, r*0.14, r*0.16, pur);
  // Bony hand
  pxRect(r*0.5, -r*0.15, r*0.28, r*0.22, '#ccc8b0');
  // Scythe pole
  pxRect(r*0.58, -r*0.85, r*0.12, r*1.6, '#6a5040');
  // Scythe blade
  pxRect(r*0.5, -r*1.25, r*0.55, r*0.18, '#c0c8d0');
  pxRect(r*0.42, -r*1.08, r*0.22, r*0.18, '#c0c8d0');
  pxRect(r*0.62, -r*1.42, r*0.35, r*0.18, '#c0c8d0');
}

function drawPixelDarkBat(r, flash) {
  // Darker, faster bat for stage 2
  const flapT = (Date.now() / 100) % PI2;
  const wa = Math.sin(flapT) * 0.7;
  const col = flash ? '#fff' : '#440060';
  const col2 = flash ? '#fff' : '#220040';
  const eyeCol = flash ? '#fff' : '#ff00ff';
  CTX.save(); CTX.rotate(-wa - 0.3);
  pxRect(-r*2.2, -r*0.5, r*2.2, r*0.6, col);
  CTX.restore();
  CTX.save(); CTX.rotate(wa + 0.3);
  pxRect(0, -r*0.5, r*2.2, r*0.6, col);
  CTX.restore();
  pxRect(-r*0.65, -r*0.9, r*1.3, r*1.5, col2);
  pxRect(-r*0.5, -r*1.5, r*0.38, r*0.65, col);
  pxRect(r*0.12, -r*1.5, r*0.38, r*0.65, col);
  pxRect(-r*0.42, -r*0.35, r*0.32, r*0.32, eyeCol);
  pxRect(r*0.10, -r*0.35, r*0.32, r*0.32, eyeCol);
}

function drawPixelLich(r, flash) {
  const float = Math.sin(Date.now() / 300) * r * 0.1;
  CTX.save(); CTX.translate(0, float);
  const col = flash ? '#fff' : '#8888cc';
  const dark = flash ? '#ddd' : '#444488';
  const eye = flash ? '#fff' : '#00ffcc';
  // Robe
  pxRect(-r*0.7, -r*0.3, r*1.4, r*1.1, dark);
  // Body / chest
  pxRect(-r*0.55, -r*0.8, r*1.1, r*0.55, col);
  // Head skull
  pxRect(-r*0.45, -r*1.35, r*0.9, r*0.6, col);
  // Eye sockets
  pxRect(-r*0.38, -r*1.22, r*0.26, r*0.28, '#111');
  pxRect(r*0.12, -r*1.22, r*0.26, r*0.28, '#111');
  // Glowing eyes
  pxRect(-r*0.33, -r*1.18, r*0.16, r*0.18, eye);
  pxRect(r*0.17, -r*1.18, r*0.16, r*0.18, eye);
  // Crown
  pxRect(-r*0.45, -r*1.65, r*0.9, r*0.32, '#cc9900');
  pxRect(-r*0.42, -r*1.8, r*0.18, r*0.2, '#ffcc00');
  pxRect(-r*0.06, -r*1.82, r*0.12, r*0.22, '#ffcc00');
  pxRect(r*0.24, -r*1.8, r*0.18, r*0.2, '#ffcc00');
  // Wand / staff
  pxRect(r*0.55, -r*1.2, r*0.12, r*1.4, '#554433');
  pxRect(r*0.45, -r*1.4, r*0.32, r*0.22, '#aa44ff');
  CTX.restore();
}

function drawPixelGargoyle(r, flash) {
  const col = flash ? '#fff' : '#666680';
  const dark = flash ? '#ccc' : '#444458';
  const eye = flash ? '#fff' : '#ff4400';
  // Stone body
  pxRect(-r*0.7, -r*0.3, r*1.4, r*1.1, dark);
  pxRect(-r*0.6, -r*0.75, r*1.2, r*0.5, col);
  // Wing stubs
  pxRect(-r*1.1, -r*0.6, r*0.5, r*0.8, dark);
  pxRect(r*0.6, -r*0.6, r*0.5, r*0.8, dark);
  // Head
  pxRect(-r*0.5, -r*1.2, r*1.0, r*0.5, col);
  // Horns
  pxRect(-r*0.4, -r*1.5, r*0.18, r*0.35, dark);
  pxRect(r*0.22, -r*1.5, r*0.18, r*0.35, dark);
  // Eyes
  pxRect(-r*0.38, -r*1.1, r*0.28, r*0.25, eye);
  pxRect(r*0.10, -r*1.1, r*0.28, r*0.25, eye);
  // Teeth
  pxRect(-r*0.32, -r*0.78, r*0.16, r*0.2, '#eee');
  pxRect(-r*0.06, -r*0.78, r*0.16, r*0.2, '#eee');
  pxRect(r*0.20, -r*0.78, r*0.16, r*0.2, '#eee');
}

// ====== PIXEL PLAYER ======
function drawPixelPlayer(r, facing) {
  const f = facing;
  // Ground shadow
  CTX.fillStyle = 'rgba(0,0,0,0.35)';
  CTX.beginPath(); CTX.ellipse(0, r*0.85, r*0.8, r*0.22, 0, 0, PI2); CTX.fill();

  if (f === -1) CTX.scale(-1, 1);

  // Boots
  pxRect(-r*0.58, r*0.52, r*0.46, r*0.42, '#2a1a08');
  pxRect(r*0.12, r*0.52, r*0.46, r*0.42, '#2a1a08');
  pxRect(-r*0.58, r*0.52, r*0.46, r*0.1, '#3a2a18');
  pxRect(r*0.12, r*0.52, r*0.46, r*0.1, '#3a2a18');
  // Trousers
  pxRect(-r*0.52, r*0.08, r*0.42, r*0.5, '#1a2232');
  pxRect(r*0.10, r*0.08, r*0.42, r*0.5, '#1a2232');
  // Coat
  pxRect(-r*0.58, -r*0.5, r*1.16, r*0.62, '#221428');
  pxRect(-r*0.58, -r*0.5, r*0.14, r*0.62, '#301c38'); // left highlight
  // Collar
  pxRect(-r*0.14, -r*0.5, r*0.28, r*0.28, '#120c18');
  // Belt
  pxRect(-r*0.58, r*0.07, r*1.16, r*0.1, '#110a06');
  pxRect(-r*0.1, r*0.07, r*0.2, r*0.1, '#b89010'); // buckle
  // Back arm
  pxRect(-r*0.82, -r*0.4, r*0.26, r*0.58, '#1e1224');
  pxRect(-r*0.7, r*0.16, r*0.22, r*0.22, '#c07050'); // hand
  // Front arm + bob
  const armBob = Math.sin(Date.now() / 200) * r * 0.05;
  pxRect(r*0.54, -r*0.38 + armBob, r*0.28, r*0.54, '#221428');
  pxRect(r*0.62, r*0.16 + armBob, r*0.22, r*0.22, '#c07050'); // hand
  // Neck
  pxRect(-r*0.14, -r*0.6, r*0.28, r*0.14, '#c07050');
  // Face
  pxRect(-r*0.42, -r*0.92, r*0.84, r*0.9, '#c89060');
  pxRect(-r*0.38, -r*0.68, r*0.76, r*0.14, 'rgba(80,50,25,0.3)'); // stubble
  // Brim of hat
  pxRect(-r*0.78, -r*1.0, r*1.56, r*0.14, '#141010');
  // Hat crown
  pxRect(-r*0.44, -r*1.5, r*0.88, r*0.52, '#1c1414');
  pxRect(-r*0.42, -r*1.48, r*0.84, r*0.5, '#201818');
  // Hat band
  pxRect(-r*0.44, -r*1.08, r*0.88, r*0.1, '#7a1800');
  // Eye
  pxRect(r*0.06, -r*0.78, r*0.24, r*0.2, '#f0e0c8'); // white
  pxRect(r*0.12, -r*0.77, r*0.14, r*0.16, '#285a80'); // iris
  pxRect(r*0.14, -r*0.76, r*0.08, r*0.1, '#080600'); // pupil
  pxRect(r*0.2, -r*0.79, r*0.05, r*0.05, '#fff');    // glint
  // Eyebrow
  pxRect(r*0.04, -r*0.88, r*0.28, r*0.08, '#4a2c10');
  // Mouth
  pxRect(r*0.06, -r*0.62, r*0.26, r*0.06, '#8a5030');
}

// ====== MAIN UPDATE ======
function update(dt) {
  if (game.state !== 'playing') return;
  game.time += dt;
  if (game.shakeTimer > 0) game.shakeTimer -= dt;

  const dir = getInputDir();
  if (dir.x !== 0) player.facing = dir.x > 0 ? 1 : -1;
  const effSpeed = playerEffSpeed();
  player.x += dir.x * effSpeed * dt;
  player.y += dir.y * effSpeed * dt;

  cam.x = lerp(cam.x, player.x, 5 * dt);
  cam.y = lerp(cam.y, player.y, 5 * dt);
  if (player.iFrames > 0) player.iFrames -= dt;

  for (const w of player.weapons) {
    const def = WEAPON_DEFS[w.type];
    def.fire(w, dt);
    if (def.update) def.update(w, dt);
  }

  waveSystem.update(dt);

  // Quadtree
  const qt = new QuadTree(cam.x - W, cam.y - H, W * 2, H * 2);
  enemies.each(e => qt.insert(e));

  // Update bullets
  bullets.each(b => {
    if (b.type === 'bible') return;
    b.timer -= dt;
    if (b.timer <= 0) { b.active = false; return; }
    b.x += b.vx * dt; b.y += b.vy * dt;
    if (b.gravity) b.vy += b.gravity * dt;
    if (b.type === 'axe' && b.spin) b._angle = (b._angle || 0) + b.spin * dt;

    if (b.type === 'melee') {
      const candidates = qt.query(b.mx, b.my, b.mw, b.mh, []);
      for (const e of candidates) {
        if (b.hitSet.has(e)) continue;
        if (rectOverlap(b.mx, b.my, b.mw, b.mh, e.x - e.r, e.y - e.r, e.r * 2, e.r * 2)) {
          b.hitSet.add(e); damageEnemy(e, b.dmg);
        }
      }
    } else {
      const candidates = qt.query(b.x - b.r, b.y - b.r, b.r * 2, b.r * 2, []);
      for (const e of candidates) {
        if (b.hitSet.has(e)) continue;
        if (circleOverlap(b.x, b.y, b.r, e.x, e.y, e.r)) {
          b.hitSet.add(e); damageEnemy(e, b.dmg);
          if (b.type !== 'lightning') { b.pierce--; if (b.pierce <= 0) { b.active = false; return; } }
        }
      }
    }
    if (!onScreen(b.x, b.y, 250)) b.active = false;
  });

  // Bible bullets collision
  bullets.each(b => {
    if (b.type !== 'bible' || !b.active) return;
    const candidates = qt.query(b.x - b.r, b.y - b.r, b.r * 2, b.r * 2, []);
    for (const e of candidates) {
      if (b.hitSet.has(e)) continue;
      if (circleOverlap(b.x, b.y, b.r, e.x, e.y, e.r)) {
        b.hitSet.add(e); damageEnemy(e, b.dmg);
        const a = angleTo(player, e);
        e.kbx += Math.cos(a) * 80 * e.knockback;
        e.kby += Math.sin(a) * 80 * e.knockback;
      }
    }
  });

  // Update enemies
  enemies.each(e => {
    const a = angleTo(e, player);
    e.x += Math.cos(a) * e.speed * dt;
    e.y += Math.sin(a) * e.speed * dt;
    if (Math.abs(e.kbx) > 0.1 || Math.abs(e.kby) > 0.1) {
      e.x += e.kbx * dt * 5; e.y += e.kby * dt * 5;
      e.kbx *= 0.9; e.kby *= 0.9;
    }
    e.hitTimer -= dt; e.flashTimer -= dt;

    if (player.iFrames <= 0 && circleOverlap(player.x, player.y, player.r, e.x, e.y, e.r)) {
      const dmgTaken = e.dmg * (1 - (player.armor || 0));
      player.hp -= dmgTaken;
      player.iFrames = 0.5;
      spawnDmgText(player.x, player.y, Math.round(dmgTaken), '#f44');
      game.shake(5, 0.15);
      const pa = angleTo(e, player);
      player.x += Math.cos(pa) * 30; player.y += Math.sin(pa) * 30;
      if (player.hp <= 0) { player.hp = 0; player.alive = false; game.state = 'gameover'; }
    }

    if (dist(player, e) > 1400) e.active = false;
  });

  // Pickups
  pickups.each(p => {
    const d = dist(player, p);
    if (d < player.magnet * 3) {
      const a = angleTo(p, player);
      const pullSpeed = 300 * (1 - d / (player.magnet * 3));
      p.x += Math.cos(a) * pullSpeed * dt; p.y += Math.sin(a) * pullSpeed * dt;
    }
    if (d < player.magnet) {
      p.active = false;
      if (p.type === 'gem') addXP(p.value);
      else if (p.type === 'chest') openChest();
      else if (p.type === 'heal') {
        player.hp = Math.min(player.hp + p.value, player.maxHp);
        spawnDmgText(player.x, player.y, '+' + p.value, '#0f0');
      }
    }
  });

  dmgTexts.each(t => { t.timer -= dt; t.y -= 40 * dt; if (t.timer <= 0) t.active = false; });
}

function damageEnemy(e, dmg) {
  // Crit
  const crit = Math.random() < (player.critChance || 0);
  const finalDmg = crit ? dmg * 2 : dmg;
  e.hp -= finalDmg;
  e.flashTimer = 0.1;
  spawnDmgText(e.x, e.y, (crit ? '‚òÖ' : '') + Math.round(finalDmg), crit ? '#ffee00' : '#ff0');
  const a = angleTo(player, e);
  e.kbx += Math.cos(a) * 40 * e.knockback;
  e.kby += Math.sin(a) * 40 * e.knockback;

  if (e.hp <= 0) {
    e.active = false; player.kills++;
    if (e.xp >= 100) spawnGem(e.x, e.y, 100);
    else if (e.xp >= 10) spawnGem(e.x, e.y, 10);
    else spawnGem(e.x, e.y, 1);
    if (e.type === 'boss' || e.type === 'boss2') spawnChest(e.x, e.y);
    if (Math.random() < 0.02) spawnHeal(e.x, e.y);
  }
}

// ====== RENDER ======
function render() {
  _uiButtons.length = 0;
  CTX.imageSmoothingEnabled = false;
  CTX.save();

  let sx = 0, sy = 0;
  if (game.shakeTimer > 0) {
    sx = Math.round(rand(-game.shakeIntensity, game.shakeIntensity));
    sy = Math.round(rand(-game.shakeIntensity, game.shakeIntensity));
    CTX.translate(sx, sy);
  }

  drawGround();

  // Pickups
  pickups.each(p => {
    if (!onScreen(p.x, p.y)) return;
    const s = toScreen(p.x, p.y);
    if (p.type === 'gem') {
      const gc = GEM_COLORS[p.value] || '#4466ff';
      // Pixel diamond
      pxRect(s.x - p.r * 0.6, s.y - p.r, p.r * 1.2, p.r * 0.9, gc);
      pxRect(s.x - p.r * 0.9, s.y - p.r * 0.15, p.r * 1.8, p.r * 0.5, gc);
      pxRect(s.x - p.r * 0.6, s.y + p.r * 0.32, p.r * 1.2, p.r * 0.6, gc + 'aa');
      // Shine
      pxRect(s.x - p.r * 0.3, s.y - p.r * 0.85, p.r * 0.5, p.r * 0.4, 'rgba(255,255,255,0.5)');
    } else if (p.type === 'chest') {
      pxRect(s.x - 18, s.y - 12, 36, 24, '#c8880a');
      pxRect(s.x - 18, s.y - 12, 36, 7, '#8a5800');
      pxRect(s.x - 4, s.y - 4, 8, 8, '#ffe000');
      pxRectOutline(s.x - 18, s.y - 12, 36, 24, '#ffa000', 2);
    } else if (p.type === 'heal') {
      pxRect(s.x - 3, s.y - 9, 6, 18, '#00ee44');
      pxRect(s.x - 9, s.y - 3, 18, 6, '#00ee44');
    }
  });

  // Enemies
  enemies.each(e => {
    if (!onScreen(e.x, e.y)) return;
    const s = toScreen(e.x, e.y);
    const flash = e.flashTimer > 0;
    CTX.save();
    CTX.translate(s.x, s.y);

    if (e.type === 'bat')          drawPixelBat(e.r, flash);
    else if (e.type === 'skeleton') drawPixelSkeleton(e.r, flash);
    else if (e.type === 'ghost')    drawPixelGhost(e.r, flash);
    else if (e.type === 'zombie')   drawPixelZombie(e.r, flash);
    else if (e.type === 'boss')     drawPixelBoss(e.r, flash);
    else if (e.type === 'reaper')   drawPixelReaper(e.r, flash);
    else if (e.type === 'darkbat')  drawPixelDarkBat(e.r, flash);
    else if (e.type === 'lich')     drawPixelLich(e.r, flash);
    else if (e.type === 'gargoyle') drawPixelGargoyle(e.r, flash);
    else if (e.type === 'boss2')    drawPixelBoss2(e.r, flash);
    else {
      // Fallback
      pxRect(-e.r, -e.r, e.r * 2, e.r * 2, flash ? '#fff' : e.color);
    }

    CTX.restore();

    // HP bar for bosses
    if (e.type === 'boss' || e.type === 'boss2' || e.type === 'reaper') {
      const ss = toScreen(e.x, e.y);
      const bw = e.r * 3.2;
      pxRect(ss.x - bw/2 - 2, ss.y - e.r * 2 - 12, bw + 4, 12, 'rgba(0,0,0,0.8)');
      pxRect(ss.x - bw/2, ss.y - e.r * 2 - 10, bw, 8, '#300');
      const hpCol = e.type === 'reaper' ? '#cc00ff' : (e.type === 'boss2' ? '#ff0066' : '#ff4400');
      pxRect(ss.x - bw/2, ss.y - e.r * 2 - 10, bw * Math.max(0, e.hp / e.maxHp), 8, hpCol);
      CTX.fillStyle = 'rgba(255,255,255,0.8)';
      CTX.font = 'bold 10px "Cinzel", serif';
      CTX.textAlign = 'center';
      const label = e.type === 'boss2' ? '‚ò† ÈªëÊöóÊÉ°È≠îÁéã' : (e.type === 'boss' ? '‚ö† ÊÉ°È≠îÁéã' : '‚ò† Ê≠ªÁ•û');
      CTX.fillText(label, ss.x, ss.y - e.r * 2 - 13);
    }
  });

  // Bullets
  bullets.each(b => {
    if (!onScreen(b.x, b.y)) return;
    const s = toScreen(b.x, b.y);
    CTX.save();

    if (b.type === 'melee') {
      const ms = toScreen(b.mx + b.mw / 2, b.my + b.mh / 2);
      // Pixel slash effect
      CTX.globalAlpha = 0.55;
      pxRect(ms.x - b.mw/2, ms.y - b.mh/2, b.mw, b.mh, '#ffff88');
      CTX.globalAlpha = 1;

    } else if (b.type === 'axe') {
      CTX.translate(s.x, s.y);
      CTX.rotate(b._angle || 0);
      CTX.font = Math.max(20, b.r * 2.5) + 'px serif';
      CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
      CTX.fillText('ü™ì', 0, 0);

    } else if (b.type === 'bible') {
      CTX.translate(s.x, s.y);
      CTX.font = Math.max(18, b.r * 2.2) + 'px serif';
      CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
      CTX.fillText('üìñ', 0, 0);

    } else if (b.type === 'fireball') {
      CTX.translate(s.x, s.y);
      CTX.shadowColor = '#ff6600'; CTX.shadowBlur = 16;
      CTX.font = Math.max(18, b.r * 2.5) + 'px serif';
      CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
      CTX.fillText('üî•', 0, 0);

    } else if (b.type === 'lightning') {
      // Draw lightning bolt line
      if (b.lx2 !== undefined) {
        const s2 = toScreen(b.lx2, b.ly2);
        CTX.strokeStyle = '#ccffff'; CTX.lineWidth = 4; CTX.globalAlpha = 0.9;
        CTX.shadowColor = '#44ffff'; CTX.shadowBlur = 12;
        CTX.beginPath(); CTX.moveTo(s.x, s.y); CTX.lineTo(s2.x, s2.y); CTX.stroke();
        CTX.shadowBlur = 0; CTX.globalAlpha = 1;
      }

    } else if (b.type === 'cross') {
      pxRect(s.x - 2, s.y - b.r * 1.2, 4, b.r * 2.4, '#ffffcc');
      pxRect(s.x - b.r * 0.8, s.y - 2, b.r * 1.6, 4, '#ffffcc');

    } else if (b.type === 'shadow') {
      CTX.globalAlpha = 0.85;
      pxRect(s.x - b.r, s.y - b.r, b.r * 2, b.r * 2, '#aa44ff');
      pxRect(s.x - b.r + 2, s.y - b.r + 2, b.r * 2 - 4, b.r * 2 - 4, '#cc88ff');

    } else {
      // Default wand bullet ‚Äî pixel circle
      pxRect(s.x - b.r, s.y - b.r, b.r * 2, b.r * 2, b.color);
      pxRect(s.x - b.r + 2, s.y - b.r + 2, b.r * 2 - 4, b.r * 2 - 4, '#ddeeff');
    }
    CTX.restore();
  });

  // Player
  if (player.alive) {
    const ps = toScreen(player.x, player.y);
    const blink = player.iFrames > 0 && Math.floor(player.iFrames * 14) % 2 === 0;
    if (!blink) {
      CTX.save();
      CTX.translate(ps.x, ps.y);
      drawPixelPlayer(player.r, player.facing);
      // Low HP pulsing border
      if (player.hp / player.maxHp < 0.3) {
        const pulseA = 0.3 + Math.sin(Date.now() / 120) * 0.3;
        CTX.strokeStyle = 'rgba(255,0,0,' + pulseA + ')';
        CTX.lineWidth = 3;
        CTX.strokeRect(-player.r - 4, -player.r * 1.4, (player.r + 4) * 2, player.r * 2.6);
      }
      CTX.restore();
    }
  }

  // Damage texts
  dmgTexts.each(t => {
    if (!onScreen(t.x, t.y)) return;
    const s = toScreen(t.x, t.y);
    CTX.save();
    CTX.font = 'bold 13px "Cinzel", serif';
    CTX.fillStyle = t.color;
    CTX.shadowColor = t.color; CTX.shadowBlur = 5;
    CTX.globalAlpha = clamp(t.timer / 0.3, 0, 1);
    CTX.textAlign = 'center';
    CTX.fillText(t.text, s.x, s.y);
    CTX.globalAlpha = 1;
    CTX.restore();
  });

  CTX.restore();

  // ====== UI OVERLAYS ======
  if (game.state === 'playing' || game.state === 'levelup') drawHUD();
  if (game.state === 'title')       drawTitle();
  if (game.state === 'weaponSelect') drawWeaponSelect();
  if (game.state === 'levelup')     drawLevelUp();
  if (game.state === 'gameover')    drawGameOver();
  if (game.state === 'victory')     drawVictory();
  if (game.state === 'stageSelect') drawStageSelect();

  // Virtual joystick
  if (touchActive && game.state === 'playing') {
    CTX.globalAlpha = 0.28;
    CTX.strokeStyle = '#fff'; CTX.lineWidth = 2;
    CTX.beginPath(); CTX.arc(touchStartX, touchStartY, 50, 0, PI2); CTX.stroke();
    CTX.beginPath(); CTX.arc(touchStartX + touchDX, touchStartY + touchDY, 20, 0, PI2);
    CTX.fillStyle = '#fff'; CTX.fill();
    CTX.globalAlpha = 1;
  }
}

// ====== HUD ======
function drawHUD() {
  const isMobile = W < 600;

  // XP Bar
  const barW = W * (isMobile ? 0.5 : 0.55), barH = isMobile ? 10 : 14;
  const barX = (W - barW) / 2, barY = 8;
  const xpRatio = player.xp / player.xpToNext;

  pxRect(barX - 2, barY - 2, barW + 4, barH + 4, 'rgba(0,0,0,0.7)');
  pxRect(barX, barY, barW, barH, '#1a0a2e');
  if (xpRatio > 0) {
    pxRect(barX, barY, barW * xpRatio, barH, '#9b5de5');
    pxRect(barX, barY, barW * xpRatio, barH / 2, 'rgba(200,150,255,0.25)');
  }
  pxRectOutline(barX, barY, barW, barH, 'rgba(180,100,255,0.6)', 1);
  CTX.save(); CTX.shadowColor = '#b060ff'; CTX.shadowBlur = 6;
  CTX.fillStyle = '#e8d4ff';
  CTX.font = `bold ${isMobile ? 9 : 11}px "Cinzel", serif`;
  CTX.textAlign = 'center';
  CTX.fillText('LV ' + player.level + (game.stage === 2 ? ' ‚òÖÁ¨¨‰∫åÈóú' : ''), W / 2, barY + barH - 1);
  CTX.restore();

  // HP Bar
  const hpW = isMobile ? Math.min(110, W * 0.28) : 140, hpH = isMobile ? 10 : 14;
  const hpX = 8, hpY = barY + barH + 6;
  const hpRatio = player.hp / player.maxHp;
  pxRect(hpX - 2, hpY - 2, hpW + 4, hpH + 4, 'rgba(0,0,0,0.7)');
  pxRect(hpX, hpY, hpW, hpH, '#1a0005');
  if (hpRatio > 0) {
    const hpCol = hpRatio > 0.5 ? '#e8102a' : hpRatio > 0.25 ? '#ff6600' : '#ff0000';
    pxRect(hpX, hpY, hpW * hpRatio, hpH, hpCol);
  }
  pxRectOutline(hpX, hpY, hpW, hpH, 'rgba(200,50,70,0.7)', 1);
  CTX.save(); CTX.fillStyle = '#ffccd5';
  CTX.font = `bold ${isMobile ? 8 : 10}px "Cinzel", serif`;
  CTX.textAlign = 'left';
  CTX.fillText('‚ù§ ' + Math.ceil(player.hp) + '/' + Math.ceil(player.maxHp), hpX + 2, hpY + hpH - 1);
  CTX.restore();

  // Timer & Kills
  const maxTime = game.stage === 2 ? 1200 : 600;
  const mins = Math.floor(game.time / 60);
  const secs = Math.floor(game.time % 60);
  const timeStr = String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
  CTX.save();
  CTX.shadowColor = '#e8b84b'; CTX.shadowBlur = 8;
  CTX.font = `bold ${isMobile ? 14 : 18}px "Cinzel", serif`;
  CTX.textAlign = 'right'; CTX.fillStyle = '#ffe066';
  CTX.fillText('‚è± ' + timeStr, W - 8, barY + barH + 2);
  CTX.shadowBlur = 4;
  CTX.font = `${isMobile ? 10 : 12}px "Cinzel", serif`;
  CTX.fillStyle = '#e8c87a';
  CTX.fillText('‚ò† ' + player.kills, W - 8, barY + barH + (isMobile ? 16 : 20));
  CTX.restore();

  // Weapon & Passive slots
  const slotSize = isMobile ? 36 : 44, slotPad = isMobile ? 4 : 6;
  const bottomY = H - slotSize - 8;
  let wx = 8;
  for (const w of player.weapons) {
    const def = WEAPON_DEFS[w.type];
    pxRect(wx, bottomY, slotSize, slotSize, 'rgba(0,0,0,0.75)');
    pxRectOutline(wx, bottomY, slotSize, slotSize, 'rgba(100,60,200,0.8)', 2);
    CTX.font = `${isMobile ? 18 : 22}px serif`;
    CTX.textAlign = 'center';
    CTX.fillText(def.icon, wx + slotSize / 2, bottomY + slotSize * 0.68);
    pxRect(wx + slotSize - 12, bottomY - 1, 12, 10, '#9b5de5');
    CTX.fillStyle = '#fff';
    CTX.font = `bold ${isMobile ? 8 : 9}px "Cinzel", serif`;
    CTX.fillText(w.level, wx + slotSize - 6, bottomY + 8);
    wx += slotSize + slotPad;
  }
  let ppx = W - slotSize - 8;
  for (const p of player.passives) {
    const def = PASSIVE_DEFS[p.type];
    pxRect(ppx, bottomY, slotSize, slotSize, 'rgba(0,0,0,0.75)');
    pxRectOutline(ppx, bottomY, slotSize, slotSize, 'rgba(40,160,80,0.8)', 2);
    CTX.font = `${isMobile ? 18 : 22}px serif`;
    CTX.textAlign = 'center';
    CTX.fillText(def.icon, ppx + slotSize / 2, bottomY + slotSize * 0.68);
    pxRect(ppx + slotSize - 12, bottomY - 1, 12, 10, '#2ecc71');
    CTX.fillStyle = '#fff';
    CTX.font = `bold ${isMobile ? 8 : 9}px "Cinzel", serif`;
    CTX.fillText(p.level, ppx + slotSize - 6, bottomY + 8);
    ppx -= slotSize + slotPad;
  }
}

// ====== TITLE SCREEN ======
function drawTitle() {
  CTX.fillStyle = 'rgba(0,0,0,0.94)'; CTX.fillRect(0, 0, W, H);
  const moonGrad = CTX.createRadialGradient(W/2, H/2 - 80, 0, W/2, H/2 - 80, 350);
  moonGrad.addColorStop(0, 'rgba(180,10,30,0.22)');
  moonGrad.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = moonGrad; CTX.fillRect(0, 0, W, H);
  CTX.textAlign = 'center';

  const titleSize = Math.min(52, rw(52));
  CTX.save(); CTX.shadowColor = '#c0102a'; CTX.shadowBlur = 38;
  CTX.fillStyle = '#ff2040';
  CTX.font = `bold ${titleSize}px "Cinzel Decorative", serif`;
  CTX.fillText('ÁçµÈ≠îÂÄñÂ≠òËÄÖ', W/2, H/2 - rh(65)); CTX.restore();
  CTX.save(); CTX.shadowColor = '#e8b84b'; CTX.shadowBlur = 10;
  CTX.fillStyle = '#e8b84b';
  CTX.font = `600 ${Math.min(18, rw(18))}px "Cinzel", serif`;
  CTX.fillText('DEMON HUNTER SURVIVORS', W/2, H/2 - rh(22)); CTX.restore();

  // Pixel art badge: 8-BIT
  const bx8 = W/2 - 42, by8 = H/2 - rh(14);
  pxRect(bx8, by8, 84, 20, '#220044');
  pxRectOutline(bx8, by8, 84, 20, '#aa44ff', 2);
  CTX.fillStyle = '#cc88ff'; CTX.font = 'bold 11px "Cinzel", serif';
  CTX.fillText('[ 8-BIT PIXEL ]', W/2, by8 + 14);

  CTX.fillStyle = 'rgba(200,180,220,0.6)';
  CTX.font = `${Math.min(12, rw(12))}px "Cinzel", serif`;
  CTX.fillText('WASD / ÊñπÂêëÈçµ ÁßªÂãï  ¬∑  Ëá™ÂãïÊîªÊìä', W/2, H/2 + rh(36));

  const bw = Math.min(200, rw(200)), bh = Math.min(50, rh(50));
  const bx = W/2 - bw/2, by = H/2 + rh(62);
  pxRect(bx, by, bw, bh, '#6a000f');
  pxRect(bx + 4, by + 4, bw - 8, bh - 8, '#c0102a');
  pxRectOutline(bx, by, bw, bh, '#e8b84b', 2);
  CTX.save(); CTX.shadowColor = '#ffe066'; CTX.shadowBlur = 8;
  CTX.fillStyle = '#ffe066';
  CTX.font = `bold ${Math.min(19, rw(19))}px "Cinzel", serif`;
  CTX.fillText('‚öî  ÈñãÂßãÈÅäÊà≤  ‚öî', W/2, by + bh * 0.65); CTX.restore();
  if (Math.floor(Date.now() / 900) % 2 === 0) {
    CTX.fillStyle = 'rgba(200,180,220,0.4)'; CTX.font = '10px "Cinzel", serif';
    CTX.fillText('Êåâ‰ªªÊÑèÈçµ / ÈªûÊìäÁï´Èù¢ÈñãÂßã', W/2, by + bh + rh(24));
  }
  registerBtn(bx, by, bw, bh, 'title', () => game.start());
  if (!drawTitle._keyBound) {
    drawTitle._keyBound = true;
    function titleKeyHandler() {
      if (game.state === 'title') { game.start(); window.removeEventListener('keydown', titleKeyHandler); }
    }
    window.addEventListener('keydown', titleKeyHandler);
  }
}

// ====== WEAPON SELECT SCREEN ======
const WEAPON_SELECT_OPTIONS_S1 = [
  { type: 'whip',     label: 'ÁöÆÈû≠', subtitle: 'Whip',       desc: 'ËøëË∑ùÂ§ßÁØÑÂúçÊèÆÁ†ç',  color: '#c8a020', border: '#ffd040' },
  { type: 'wand',     label: 'È≠îÊùñ', subtitle: 'Magic Wand', desc: 'ÈéñÂÆöÊúÄËøëÊïµ‰∫∫',    color: '#4488ff', border: '#88aaff' },
  { type: 'axe',      label: 'È£õÊñß', subtitle: 'Axe',        desc: 'ÊããÁâ©Á∑öÈ´òÂÇ∑ÂÆ≥Á©øÈÄè', color: '#cc5500', border: '#ff8822' },
  { type: 'bible',    label: 'ËÅñÁ∂ì', subtitle: 'King Bible', desc: 'ÁπûË∫´ÊóãËΩâË≠∑Áõæ',    color: '#8844ff', border: '#bb88ff' },
  { type: 'firewand', label: 'ÁÅ´ÁêÉ', subtitle: 'Fire Wand',  desc: 'Èö®Ê©üÈéñÂÆöÁÅ´ÁêÉ',    color: '#ff3300', border: '#ff6644' },
];
const WEAPON_SELECT_OPTIONS_S2 = [
  { type: 'whip',     label: 'ÁöÆÈû≠', subtitle: 'Whip',         desc: 'ËøëË∑ùÂ§ßÁØÑÂúçÊèÆÁ†ç', color: '#c8a020', border: '#ffd040' },
  { type: 'wand',     label: 'È≠îÊùñ', subtitle: 'Magic Wand',   desc: 'ÈéñÂÆöÊúÄËøëÊïµ‰∫∫',   color: '#4488ff', border: '#88aaff' },
  { type: 'firewand', label: 'ÁÅ´ÁêÉ', subtitle: 'Fire Wand',    desc: 'Èö®Ê©üÈéñÂÆöÁÅ´ÁêÉ',   color: '#ff3300', border: '#ff6644' },
  { type: 'lightning',label: 'ÈñÉÈõª', subtitle: 'Lightning',    desc: 'ÈÄ£ÈéñÈõªÊìäÊïµ‰∫∫',   color: '#44ddff', border: '#aaeeff' },
  { type: 'cross',    label: 'ÂçÅÂ≠óÊû∂',subtitle: 'Holy Cross',  desc: '4ÊñπÂêëË≤´Á©øÂ∞ÑÊìä',  color: '#eeeeaa', border: '#ffffdd' },
  { type: 'shadow',   label: 'ÊöóÂΩ±ÂàÉ',subtitle: 'Shadow Blade', desc: 'ÊâáÂΩ¢ÊöóÂΩ±Êñ¨',    color: '#9944ff', border: '#cc88ff' },
];

function drawWeaponSelect() {
  const opts = game.stage === 2 ? WEAPON_SELECT_OPTIONS_S2 : WEAPON_SELECT_OPTIONS_S1;

  CTX.fillStyle = 'rgba(0,0,0,0.95)'; CTX.fillRect(0, 0, W, H);
  const glow = CTX.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.6);
  glow.addColorStop(0, 'rgba(80,20,120,0.22)'); glow.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = glow; CTX.fillRect(0, 0, W, H);

  const PAD = 10, BTN_H = Math.max(36, Math.min(50, H * 0.07)), BTN_GAP = 10;
  const TITLE_PAD_TOP = 10;
  const titleFontSz = Math.max(16, Math.min(28, W * 0.055, H * 0.048));
  const subFontSz = Math.max(10, Math.min(13, W * 0.024));
  const HEADER_H = TITLE_PAD_TOP + titleFontSz + 6 + subFontSz + 12;
  const availH = H - HEADER_H - BTN_H - BTN_GAP - PAD;
  const numCards = opts.length;
  const isMobile = W < 600;
  const cols = W < 420 ? 2 : (isMobile ? Math.min(numCards, 3) : numCards);
  const rows = Math.ceil(numCards / cols);
  const GAP = Math.max(5, Math.min(10, W * 0.016));
  const cardW = Math.floor((W - PAD * 2 - GAP * (cols - 1)) / cols);
  const cardH = Math.max(70, Math.floor((availH - GAP * (rows - 1)) / rows));
  const startX = PAD, startY = HEADER_H;

  // Title
  CTX.textAlign = 'center';
  const titleY = TITLE_PAD_TOP + titleFontSz;
  CTX.save(); CTX.shadowColor = '#cc88ff'; CTX.shadowBlur = 20;
  CTX.fillStyle = '#cc88ff';
  CTX.font = 'bold ' + titleFontSz + 'px "Cinzel Decorative", serif';
  CTX.fillText(game.stage === 2 ? 'ÈÅ∏ÊìáÁ¨¨‰∫åÈóúËµ∑ÂßãÊ≠¶Âô®' : 'ÈÅ∏ÊìáÂàùÂßãÊ≠¶Âô®', W/2, titleY); CTX.restore();
  CTX.fillStyle = 'rgba(200,180,230,0.5)';
  CTX.font = subFontSz + 'px "Cinzel", serif';
  CTX.fillText('Choose Your Starting Weapon  ‚Äî  Stage ' + game.stage, W/2, titleY + titleFontSz + 2);

  // Cards
  for (let i = 0; i < numCards; i++) {
    const opt = opts[i];
    const col = i % cols, row = Math.floor(i / cols);
    const cx = startX + col * (cardW + GAP);
    const cy = startY + row * (cardH + GAP);
    const isSelected = game.selectedWeapon === opt.type;
    const isHover = !isMobile && mouse.x >= cx && mouse.x <= cx + cardW && mouse.y >= cy && mouse.y <= cy + cardH;
    const hi = isSelected || isHover;
    const capI = i;
    registerBtn(cx, cy, cardW, cardH, 'weaponSelect', () => { game.selectedWeapon = opts[capI].type; });

    // Glow for selected
    if (isSelected) {
      CTX.save(); CTX.shadowColor = opt.border; CTX.shadowBlur = 20;
      CTX.fillStyle = 'rgba(0,0,0,0)'; CTX.fillRect(cx - 3, cy - 3, cardW + 6, cardH + 6); CTX.restore();
    }

    // Card bg (pixel style)
    const bgCol = isSelected ? '#3a1860' : (hi ? '#2a1248' : '#120a22');
    pxRect(cx, cy, cardW, cardH, bgCol);
    pxRect(cx, cy, cardW, isSelected ? 4 : 2, opt.border);
    pxRectOutline(cx, cy, cardW, cardH, isSelected ? opt.border : (hi ? opt.color : 'rgba(80,60,100,0.55)'), isSelected ? 2 : 1);

    // Icon
    const iconSize = Math.max(14, Math.min(cardW * 0.35, cardH * 0.3, 36));
    const iconY = cy + cardH * 0.38;
    CTX.save(); if (isSelected) { CTX.shadowColor = opt.border; CTX.shadowBlur = 12; }
    CTX.font = iconSize + 'px serif'; CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
    CTX.fillText({ whip:'ü™¢', wand:'ü™Ñ', axe:'ü™ì', bible:'üìñ', firewand:'üî•', lightning:'‚ö°', cross:'‚úùÔ∏è', shadow:'üó°' }[opt.type] || '‚öî', cx + cardW/2, iconY);
    CTX.restore(); CTX.textBaseline = 'alphabetic';

    const nameFontSz = Math.max(9, Math.min(13, cardW * 0.1, cardH * 0.09));
    CTX.fillStyle = isSelected ? opt.border : '#e8e0f8';
    CTX.font = 'bold ' + nameFontSz + 'px "Cinzel", serif'; CTX.textAlign = 'center';
    CTX.fillText(opt.label, cx + cardW/2, cy + cardH * 0.59);

    if (cardH > 90) {
      CTX.fillStyle = opt.color;
      CTX.font = Math.max(7, Math.min(10, cardW * 0.075)) + 'px "Cinzel", serif';
      CTX.fillText(opt.subtitle, cx + cardW/2, cy + cardH * 0.73);
    }
    if (cardH > 118) {
      CTX.fillStyle = 'rgba(200,190,220,0.65)';
      CTX.font = Math.max(7, Math.min(9, cardW * 0.062)) + 'px "Cinzel", serif';
      CTX.fillText(opt.desc, cx + cardW/2, cy + cardH * 0.87);
    }
    if (isSelected) {
      CTX.save(); CTX.fillStyle = opt.border; CTX.shadowColor = opt.border; CTX.shadowBlur = 6;
      CTX.font = 'bold ' + Math.max(7, Math.min(9, cardW * 0.062)) + 'px "Cinzel", serif';
      CTX.fillText('‚úì Â∑≤ÈÅ∏Êìá', cx + cardW/2, cy + cardH - 7); CTX.restore();
    }
  }

  // Confirm button
  const cardsBottom = startY + rows * cardH + (rows - 1) * GAP;
  const btnW = Math.min(220, W - PAD * 2), btnX = W/2 - btnW/2;
  const btnY = Math.min(cardsBottom + BTN_GAP, H - BTN_H - PAD);

  pxRect(btnX, btnY, btnW, BTN_H, '#280a50');
  pxRect(btnX + 3, btnY + 3, btnW - 6, BTN_H - 6, '#4a2080');
  pxRectOutline(btnX, btnY, btnW, BTN_H, '#cc88ff', 2);
  CTX.save(); CTX.shadowColor = '#eeccff'; CTX.shadowBlur = 8;
  CTX.fillStyle = '#eeccff';
  CTX.font = 'bold ' + Math.max(13, Math.min(17, W * 0.034)) + 'px "Cinzel", serif';
  CTX.textAlign = 'center';
  CTX.fillText('‚öî  Âá∫ÁôºÂÜíÈö™  ‚öî', W/2, btnY + BTN_H * 0.67); CTX.restore();
  registerBtn(btnX, btnY, btnW, BTN_H, 'weaponSelect', () => { game.reset(game.selectedWeapon, game.stage); });
}

// ====== LEVEL UP SCREEN ======
const _levelUpCards = [];
function drawLevelUp() {
  CTX.fillStyle = 'rgba(5,0,15,0.84)'; CTX.fillRect(0, 0, W, H);
  const vig = CTX.createRadialGradient(W/2, H/2, 100, W/2, H/2, Math.max(W,H)*0.7);
  vig.addColorStop(0, 'rgba(0,0,0,0)'); vig.addColorStop(1, 'rgba(0,0,0,0.6)');
  CTX.fillStyle = vig; CTX.fillRect(0, 0, W, H);
  CTX.textAlign = 'center';

  const isMobile = W < 600;
  CTX.save(); CTX.shadowColor = '#ffe066'; CTX.shadowBlur = 28;
  CTX.fillStyle = '#ffe066';
  CTX.font = `bold ${Math.min(40, rw(40))}px "Cinzel Decorative", serif`;
  CTX.fillText('‚¨Ü LEVEL UP! ‚¨Ü', W/2, isMobile ? 48 : H/2 - 140); CTX.restore();

  CTX.fillStyle = 'rgba(200,180,230,0.6)';
  CTX.font = `${Math.min(13, rw(13))}px "Cinzel", serif`;
  CTX.fillText('ÈªûÊìäÂç°ÁâáÈÅ∏ÊìáÂçáÁ¥ö', W/2, isMobile ? 70 : H/2 - 100);

  const maxCardW = isMobile ? Math.min(155, (W - 30) / 3 - 8) : 185;
  const cardW = maxCardW, cardH = isMobile ? Math.min(185, H - 105) : 215;
  const gap = isMobile ? 8 : 20;
  const totalW = levelUpChoices.length * cardW + (levelUpChoices.length - 1) * gap;
  const startX = Math.max(4, (W - totalW) / 2);
  const startY = isMobile ? 82 : H / 2 - 85;

  _levelUpCards.length = 0;
  for (let i = 0; i < levelUpChoices.length; i++) {
    const c = levelUpChoices[i];
    const cx = startX + i * (cardW + gap), cy = startY;
    _levelUpCards.push({ x: cx, y: cy, w: cardW, h: cardH, idx: i });
    registerBtn(cx, cy, cardW, cardH, 'levelup', () => selectChoice(i));

    const isWeapon = c.cat === 'weapon';
    const def = isWeapon ? WEAPON_DEFS[c.type] : PASSIVE_DEFS[c.type];
    const isHover = !isMobile && mouse.x >= cx && mouse.x <= cx + cardW && mouse.y >= cy && mouse.y <= cy + cardH;

    // Card bg (pixel)
    pxRect(cx, cy, cardW, cardH, isWeapon ? (isHover ? '#2a1a5a' : '#1e1440') : (isHover ? '#0f3020' : '#0a2218'));
    pxRect(cx, cy, cardW, 3, isWeapon ? '#9b5de5' : '#2ecc71');
    pxRectOutline(cx, cy, cardW, cardH, isHover ? (isWeapon ? '#9b5de5' : '#2ecc71') : (isWeapon ? 'rgba(100,60,180,0.55)' : 'rgba(40,140,70,0.55)'), isHover ? 2 : 1);

    const iconSize = Math.min(38, cardW * 0.21);
    CTX.save(); if (isHover) { CTX.shadowColor = isWeapon ? '#cc88ff' : '#44ee88'; CTX.shadowBlur = 18; }
    CTX.font = `${iconSize}px serif`; CTX.textAlign = 'center';
    CTX.fillText(def.icon, cx + cardW/2, cy + cardH * 0.27); CTX.restore();

    const nameFontSize = Math.min(12, cardW * 0.073);
    CTX.fillStyle = '#e8e0f8';
    CTX.font = `bold ${nameFontSize}px "Cinzel", serif`;
    let displayName = def.name;
    if (isMobile) displayName = def.name.split(' ')[0];
    CTX.fillText(displayName, cx + cardW/2, cy + cardH * 0.43);

    CTX.save(); CTX.shadowColor = '#ffe066'; CTX.shadowBlur = c.isNew ? 10 : 3;
    CTX.fillStyle = c.isNew ? '#ffe066' : '#c0a830';
    CTX.font = `bold ${Math.min(11, cardW * 0.068)}px "Cinzel", serif`;
    CTX.fillText(c.isNew ? '‚ú¶ NEW ‚ú¶' : `Lv${c.level-1}‚Üí${c.level}`, cx + cardW/2, cy + cardH * 0.56); CTX.restore();

    CTX.fillStyle = isWeapon ? '#9b5de5' : '#2ecc71';
    CTX.font = `${Math.min(11, cardW * 0.063)}px "Cinzel", serif`;
    CTX.fillText(isWeapon ? 'Ê≠¶Âô®' : 'Ë¢´Âãï', cx + cardW/2, cy + cardH * 0.68);

    if (!isWeapon && cardH > 160) {
      CTX.fillStyle = 'rgba(200,230,200,0.75)';
      CTX.font = `${Math.min(11, cardW * 0.062)}px "Cinzel", serif`;
      CTX.fillText(def.desc, cx + cardW/2, cy + cardH * 0.79);
    }

    const tapHint = isMobile ? 'ÈªûÊìä' : (isHover ? 'ÈªûÊìäÈÅ∏Êìá' : '');
    if (tapHint) {
      CTX.fillStyle = 'rgba(255,255,255,0.3)';
      CTX.font = `${Math.min(10, cardW * 0.058)}px "Cinzel", serif`;
      CTX.fillText(tapHint, cx + cardW/2, cy + cardH - 10);
    }
  }
}

// ====== GAME OVER ======
function drawGameOver() {
  CTX.fillStyle = 'rgba(0,0,0,0.92)'; CTX.fillRect(0, 0, W, H);
  const glow = CTX.createRadialGradient(W/2, H/2, 0, W/2, H/2, 400);
  glow.addColorStop(0, 'rgba(150,0,20,0.25)'); glow.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = glow; CTX.fillRect(0, 0, W, H);
  CTX.textAlign = 'center';

  CTX.save(); CTX.shadowColor = '#ff0000'; CTX.shadowBlur = 48;
  CTX.fillStyle = '#cc1020';
  CTX.font = `bold ${Math.min(58, rw(58))}px "Cinzel Decorative", serif`;
  CTX.fillText('GAME OVER', W/2, H/2 - rh(82)); CTX.restore();

  const panW = Math.min(320, W - 40);
  pxRect(W/2 - panW/2, H/2 - rh(52), panW, rh(112), 'rgba(0,0,0,0.55)');
  pxRectOutline(W/2 - panW/2, H/2 - rh(52), panW, rh(112), 'rgba(180,20,30,0.6)', 1);

  const mins = Math.floor(game.time / 60), secs = Math.floor(game.time % 60);
  CTX.fillStyle = '#e8d0d8'; CTX.font = `${Math.min(15, rw(15))}px "Cinzel", serif`;
  CTX.fillText('‚è±  Â≠òÊ¥ªÊôÇÈñì  ' + String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0'), W/2, H/2 - rh(20));
  CTX.fillText('‚ò†  Á∏ΩÊìäÊÆ∫    ' + player.kills, W/2, H/2 + rh(12));
  CTX.fillText('‚¨Ü  ÈÅîÂà∞Á≠âÁ¥ö  ' + player.level, W/2, H/2 + rh(44));

  const bw = Math.min(190, W - 40), bh = Math.min(46, rh(46));
  const bx = W/2 - bw/2, by = H/2 + rh(80);
  pxRect(bx, by, bw, bh, '#3a0008'); pxRect(bx+3, by+3, bw-6, bh-6, '#6a0010');
  pxRectOutline(bx, by, bw, bh, 'rgba(200,50,60,0.85)', 2);
  CTX.save(); CTX.shadowColor = '#ff8890'; CTX.shadowBlur = 5;
  CTX.fillStyle = '#ffcccc'; CTX.font = `bold ${Math.min(17, rw(17))}px "Cinzel", serif`;
  CTX.fillText('‚Ü∫  ÈáçÊñ∞ÈñãÂßã', W/2, by + bh * 0.66); CTX.restore();
  registerBtn(bx, by, bw, bh, 'gameover', () => game.startNewGame(1));

  if (!drawGameOver._keyBound) {
    drawGameOver._keyBound = true;
    window.addEventListener('keydown', e => { if (game.state === 'gameover') game.startNewGame(game.stage); });
  }
}

// ====== VICTORY ======
function drawVictory() {
  CTX.fillStyle = 'rgba(0,0,0,0.92)'; CTX.fillRect(0, 0, W, H);
  const glow = CTX.createRadialGradient(W/2, H/2, 0, W/2, H/2, 400);
  glow.addColorStop(0, 'rgba(200,160,0,0.22)'); glow.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = glow; CTX.fillRect(0, 0, W, H);
  CTX.textAlign = 'center';

  CTX.save(); CTX.shadowColor = '#ffe066'; CTX.shadowBlur = 46;
  CTX.fillStyle = '#e8b84b';
  CTX.font = `bold ${Math.min(52, rw(52))}px "Cinzel Decorative", serif`;
  CTX.fillText(game.stage === 1 ? '‚ú¶ Á¨¨‰∏ÄÈóúÈÄöÈóú! ‚ú¶' : '‚ú¶ ÈÅäÊà≤ÈÄöÈóú! ‚ú¶', W/2, H/2 - rh(90)); CTX.restore();

  CTX.fillStyle = 'rgba(255,240,150,0.7)';
  CTX.font = `${Math.min(15, rw(15))}px "Cinzel", serif`;
  CTX.fillText(game.stage === 1 ? '‰Ω†Âú®Á¨¨‰∏ÄÈóúÂ≠òÊ¥ª‰∫Ü 10 ÂàÜÈêòÔºÅÁπºÁ∫åÊåëÊà∞Á¨¨‰∫åÈóúÔºü' : '‰Ω†ÈÄöÈóú‰∫ÜÂÖ®ÈÉ®ÂÖ©ÈóúÔºÅÊÅ≠ÂñúÔºÅ', W/2, H/2 - rh(44));

  const panW = Math.min(320, W - 40);
  pxRect(W/2 - panW/2, H/2 - rh(20), panW, rh(90), 'rgba(0,0,0,0.55)');
  pxRectOutline(W/2 - panW/2, H/2 - rh(20), panW, rh(90), 'rgba(232,184,75,0.5)', 1);
  CTX.fillStyle = '#e8d8b0'; CTX.font = `${Math.min(14, rw(14))}px "Cinzel", serif`;
  CTX.fillText('‚ò†  Á∏ΩÊìäÊÆ∫  ' + player.kills, W/2, H/2 + rh(12));
  CTX.fillText('‚¨Ü  ÈÅîÂà∞Á≠âÁ¥ö  ' + player.level, W/2, H/2 + rh(42));

  if (game.stage === 1) {
    // Two buttons: Stage 2 and Restart
    const bw = Math.min(180, W/2 - 20), bh = Math.min(46, rh(46));
    const gap = 10;
    const totalBtnW = bw * 2 + gap;
    const bx1 = W/2 - totalBtnW/2, by1 = H/2 + rh(94);
    const bx2 = bx1 + bw + gap;

    // Stage 2 button (gold)
    pxRect(bx1, by1, bw, bh, '#3a2800'); pxRect(bx1+3, by1+3, bw-6, bh-6, '#6a5000');
    pxRectOutline(bx1, by1, bw, bh, '#e8b84b', 2);
    CTX.save(); CTX.shadowColor = '#ffe066'; CTX.shadowBlur = 8;
    CTX.fillStyle = '#ffe066'; CTX.font = `bold ${Math.min(13, rw(13))}px "Cinzel", serif`;
    CTX.fillText('‚öî ÊåëÊà∞Á¨¨‰∫åÈóú', bx1 + bw/2, by1 + bh * 0.67); CTX.restore();
    registerBtn(bx1, by1, bw, bh, 'victory', () => {
      game.stage = 2;
      game.selectedWeapon = 'whip'; // whip is valid in both stage lists
      game.state = 'weaponSelect';
    });

    // Restart button (red)
    pxRect(bx2, by1, bw, bh, '#280008'); pxRect(bx2+3, by1+3, bw-6, bh-6, '#550010');
    pxRectOutline(bx2, by1, bw, bh, 'rgba(200,50,60,0.8)', 2);
    CTX.save(); CTX.fillStyle = '#ffcccc'; CTX.font = `bold ${Math.min(13, rw(13))}px "Cinzel", serif`;
    CTX.fillText('‚Ü∫ ÂÜç‰æÜ‰∏ÄÂ±Ä', bx2 + bw/2, by1 + bh * 0.67); CTX.restore();
    registerBtn(bx2, by1, bw, bh, 'victory', () => game.startNewGame(1));

  } else {
    // Final victory ‚Äî just restart
    const bw = Math.min(200, W - 40), bh = Math.min(48, rh(48));
    const bx = W/2 - bw/2, by = H/2 + rh(94);
    pxRect(bx, by, bw, bh, '#3a2800'); pxRect(bx+3, by+3, bw-6, bh-6, '#6a5000');
    pxRectOutline(bx, by, bw, bh, '#e8b84b', 2);
    CTX.save(); CTX.shadowColor = '#ffe066'; CTX.shadowBlur = 6;
    CTX.fillStyle = '#ffe066'; CTX.font = `bold ${Math.min(17, rw(17))}px "Cinzel", serif`;
    CTX.fillText('‚öî  ÂÜç‰æÜ‰∏ÄÂ±Ä', W/2, by + bh * 0.67); CTX.restore();
    registerBtn(bx, by, bw, bh, 'victory', () => game.startNewGame(1));
  }
}

// ====== STAGE SELECT SCREEN (unused placeholder) ======
function drawStageSelect() {
  // This state should not normally be reached
  if (game.state === 'stageSelect') game.state = 'weaponSelect';
}

// ====== GAME LOOP ======
let lastTime = 0;
function loop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(ts => { lastTime = ts; requestAnimationFrame(loop); });
</script>
</body>
</html>
