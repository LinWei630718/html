<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ÁçµÈ≠îÂÄñÂ≠òËÄÖ Demon Hunter Survivors</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Cinzel:wght@400;600;700&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0610; overflow: hidden; touch-action: none; user-select: none; }
canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
</style>
</head>
<body>
<canvas id="gc"></canvas>
<script>
'use strict';

// ====== POLYFILL: roundRect for older browsers ======
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (typeof r === 'number') r = [r, r, r, r];
    const [tl, tr, br, bl] = Array.isArray(r) ? r : [r, r, r, r];
    this.beginPath();
    this.moveTo(x + tl, y);
    this.lineTo(x + w - tr, y);
    this.quadraticCurveTo(x + w, y, x + w, y + tr);
    this.lineTo(x + w, y + h - br);
    this.quadraticCurveTo(x + w, y + h, x + w - br, y + h);
    this.lineTo(x + bl, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - bl);
    this.lineTo(x, y + tl);
    this.quadraticCurveTo(x, y, x + tl, y);
    this.closePath();
    return this;
  };
}

// ====== CANVAS SETUP ======
const CVS = document.getElementById('gc');
const CTX = CVS.getContext('2d');
let W, H;
const PI2 = Math.PI * 2;

function resize() {
  W = CVS.width = window.innerWidth;
  H = CVS.height = window.innerHeight;
  CTX.imageSmoothingEnabled = false;
}
resize();
window.addEventListener('resize', resize);

// ====== PIXEL SIZE (8-bit look) ======
const PX = 2; 

function pxRect(x, y, w, h, color) {
  CTX.fillStyle = color;
  CTX.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
}

function pxCircle(cx, cy, r, color) {
  CTX.fillStyle = color;
  const step = Math.max(1, Math.round(r * 0.4));
  for (let dy = -r; dy <= r; dy += step) {
    const hw = Math.sqrt(Math.max(0, r * r - dy * dy));
    CTX.fillRect(Math.round(cx - hw), Math.round(cy + dy), Math.round(hw * 2), step);
  }
}

function pxRectOutline(x, y, w, h, color, thick = 2) {
  CTX.fillStyle = color;
  CTX.fillRect(Math.round(x), Math.round(y), Math.round(w), thick);
  CTX.fillRect(Math.round(x), Math.round(y + h - thick), Math.round(w), thick);
  CTX.fillRect(Math.round(x), Math.round(y), thick, Math.round(h));
  CTX.fillRect(Math.round(x + w - thick), Math.round(y), thick, Math.round(h));
}

// ====== RESPONSIVE SCALE ======
function rw(base) { return base * Math.min(1, W / 480); }
function rh(base) { return base * Math.min(1, H / 860); }

// ====== UTILITY ======
function rand(a, b) { return Math.random() * (b - a) + a; }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
function dist(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); }
function angleTo(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function lerp(a, b, t) { return a + (b - a) * t; }
function rectOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}
function circleOverlap(ax, ay, ar, bx, by, br) {
  const dx = ax - bx, dy = ay - by;
  return dx * dx + dy * dy < (ar + br) * (ar + br);
}

// ====== QUADTREE ======
class QuadTree {
  constructor(x, y, w, h, depth = 0) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.depth = depth; this.items = []; this.children = null;
  }
  clear() { this.items.length = 0; this.children = null; }
  subdivide() {
    const hw = this.w / 2, hh = this.h / 2, d = this.depth + 1;
    this.children = [
      new QuadTree(this.x, this.y, hw, hh, d),
      new QuadTree(this.x + hw, this.y, hw, hh, d),
      new QuadTree(this.x, this.y + hh, hw, hh, d),
      new QuadTree(this.x + hw, this.y + hh, hw, hh, d)
    ];
  }
  insert(item) {
    if (!rectOverlap(this.x, this.y, this.w, this.h, item.x - item.r, item.y - item.r, item.r * 2, item.r * 2)) return;
    if (this.children) { for (const c of this.children) c.insert(item); return; }
    this.items.push(item);
    if (this.items.length > 8 && this.depth < 6) {
      this.subdivide();
      for (const it of this.items) for (const c of this.children) c.insert(it);
      this.items.length = 0;
    }
  }
  query(x, y, w, h, out) {
    if (!rectOverlap(this.x, this.y, this.w, this.h, x, y, w, h)) return out;
    if (this.children) { for (const c of this.children) c.query(x, y, w, h, out); }
    else { for (const it of this.items) if (out.indexOf(it) === -1) out.push(it); }
    return out;
  }
}

// ====== OBJECT POOL ======
class Pool {
  constructor(factory, size) {
    this.items = [];
    this.factory = factory;
    for (let i = 0; i < size; i++) { const o = factory(); o.active = false; this.items.push(o); }
  }
  get() {
    for (const o of this.items) if (!o.active) { o.active = true; return o; }
    const o = this.factory(); o.active = true; this.items.push(o); return o;
  }
  each(fn) { for (const o of this.items) if (o.active) fn(o); }
  count() { let c = 0; for (const o of this.items) if (o.active) c++; return c; }
}

// ====== CAMERA ======
const cam = { x: 0, y: 0 };
function toScreen(wx, wy) { return { x: Math.round(wx - cam.x + W / 2), y: Math.round(wy - cam.y + H / 2) }; }
function onScreen(wx, wy, margin = 80) {
  const sx = wx - cam.x + W / 2, sy = wy - cam.y + H / 2;
  return sx > -margin && sx < W + margin && sy > -margin && sy < H + margin;
}

// ====== BOSS3 EXPLOSION SYSTEM ======
const bossExplosion = {
  active: false,
  phase: 0,        // 0=inactive, 1=pre-flash, 2=shockwave, 3=particle shower, 4=void collapse, 5=done
  timer: 0,
  bx: 0, by: 0,    // boss world position (captured at death)
  particles: [],
  shockwaves: [],
  flashAlpha: 0,
  screenShatter: [],
  pulseRings: [],
  done: false,

  start(x, y) {
    this.active = true; this.done = false; this.phase = 1; this.timer = 0;
    this.bx = x; this.by = y;
    this.flashAlpha = 0;
    this.particles = [];
    this.shockwaves = [];
    this.screenShatter = [];
    this.pulseRings = [];
    // Pre-generate particle burst (300 particles)
    for (let i = 0; i < 300; i++) {
      const a = rand(0, Math.PI * 2);
      const spd = rand(80, 600 + i * 2.5);
      const size = rand(3, 18);
      const life = rand(1.2, 4.5);
      const hue = Math.random() < 0.5 ? rand(0, 40) : rand(280, 360); // red-orange or purple
      const col = `hsl(${hue},100%,${rand(50,90)}%)`;
      this.particles.push({ x, y, vx: Math.cos(a)*spd, vy: Math.sin(a)*spd, size, life, maxLife: life, col, gravity: rand(30,120), spin: rand(-8,8), alpha: 1 });
    }
    // Shockwave rings
    for (let i = 0; i < 5; i++) {
      this.shockwaves.push({ r: 0, maxR: 400 + i * 180, delay: i * 0.18, alpha: 1, col: i % 2 === 0 ? '#ff4400' : '#aa00ff' });
    }
    // Screen shatter lines (random cracks from center)
    for (let i = 0; i < 24; i++) {
      const a = rand(0, Math.PI * 2);
      const len = rand(80, Math.max(W, H) * 0.7);
      this.screenShatter.push({ a, len, alpha: 0, maxAlpha: rand(0.4, 0.9), col: Math.random() < 0.5 ? '#ff2200' : '#cc00ff', life: rand(0.8, 2.2) });
    }
    // Pulse rings for continuous ripple
    for (let i = 0; i < 8; i++) {
      this.pulseRings.push({ r: 0, delay: i * 0.25, speed: rand(300, 600), alpha: 0.9, col: i%3===0?'#fff':i%3===1?'#ff4400':'#aa00ff' });
    }
  },

  update(dt) {
    if (!this.active) return;
    this.timer += dt;
    const t = this.timer;

    // Phase transitions
    if (this.phase === 1 && t >= 0.15) { this.phase = 2; game.shake(40, 2.0); }
    if (this.phase === 2 && t >= 0.6)  { this.phase = 3; }
    if (this.phase === 3 && t >= 2.8)  { this.phase = 4; }
    if (this.phase === 4 && t >= 5.2)  { this.phase = 5; this.done = true; }

    // Flash alpha
    if (this.phase === 1) this.flashAlpha = Math.min(1, t / 0.15);
    else if (this.phase === 2) this.flashAlpha = Math.max(0, 1 - (t - 0.15) / 0.45);
    else this.flashAlpha = 0;

    // Update shockwaves
    for (const sw of this.shockwaves) {
      if (t < sw.delay) continue;
      const age = t - sw.delay;
      sw.r = age * 900;
      sw.alpha = Math.max(0, 1 - sw.r / sw.maxR);
    }

    // Update particles
    for (const p of this.particles) {
      if (p.life <= 0) continue;
      p.life -= dt;
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vy += p.gravity * dt;
      p.vx *= 0.98; p.vy *= 0.98;
      p.alpha = Math.max(0, p.life / p.maxLife);
    }

    // Update screen shatter
    for (const s of this.screenShatter) {
      if (t < 0.1) continue;
      const age = t - 0.1;
      if (age < 0.3) s.alpha = Math.min(s.maxAlpha, age / 0.3 * s.maxAlpha);
      else if (age > 0.6) s.alpha = Math.max(0, s.maxAlpha - (age - 0.6) / s.life * s.maxAlpha);
    }

    // Update pulse rings
    for (const pr of this.pulseRings) {
      if (t < pr.delay) continue;
      pr.r += pr.speed * dt;
      pr.alpha = Math.max(0, 0.9 - pr.r / 1200);
    }

    // Phase 4: void collapse ‚Äî show state but keep particles fading
    // After done, game transitions to victory3
    if (this.done && game.state === 'playing') {
      game.state = 'victory3';
      bossExplosion.active = false;
    }
  },

  render() {
    if (!this.active) return;
    const t = this.timer;
    // Convert boss world pos to screen pos
    const bsx = this.bx - cam.x + W / 2;
    const bsy = this.by - cam.y + H / 2;

    // Screen crack lines (behind everything)
    CTX.save();
    for (const s of this.screenShatter) {
      if (s.alpha <= 0) continue;
      CTX.globalAlpha = s.alpha;
      CTX.strokeStyle = s.col;
      CTX.lineWidth = 2;
      CTX.shadowColor = s.col; CTX.shadowBlur = 8;
      CTX.beginPath();
      CTX.moveTo(bsx, bsy);
      CTX.lineTo(bsx + Math.cos(s.a) * s.len, bsy + Math.sin(s.a) * s.len);
      CTX.stroke();
    }
    CTX.restore();

    // Shockwave rings
    CTX.save();
    for (const sw of this.shockwaves) {
      if (sw.alpha <= 0 || sw.r <= 0) continue;
      CTX.globalAlpha = sw.alpha * 0.7;
      CTX.strokeStyle = sw.col;
      CTX.lineWidth = Math.max(2, 12 * sw.alpha);
      CTX.shadowColor = sw.col; CTX.shadowBlur = 20;
      CTX.beginPath(); CTX.arc(bsx, bsy, sw.r, 0, Math.PI * 2); CTX.stroke();
    }
    CTX.restore();

    // Pulse rings
    CTX.save();
    for (const pr of this.pulseRings) {
      if (pr.alpha <= 0 || pr.r <= 0) continue;
      CTX.globalAlpha = pr.alpha * 0.5;
      CTX.strokeStyle = pr.col;
      CTX.lineWidth = 3;
      CTX.shadowColor = pr.col; CTX.shadowBlur = 12;
      CTX.beginPath(); CTX.arc(bsx, bsy, pr.r, 0, Math.PI * 2); CTX.stroke();
    }
    CTX.restore();

    // Particles
    CTX.save();
    for (const p of this.particles) {
      if (p.alpha <= 0 || p.life <= 0) continue;
      const ps = { x: p.x - cam.x + W/2, y: p.y - cam.y + H/2 };
      CTX.globalAlpha = p.alpha;
      CTX.fillStyle = p.col;
      CTX.shadowColor = p.col; CTX.shadowBlur = p.size * 1.5;
      const sz = p.size * p.alpha;
      CTX.fillRect(Math.round(ps.x - sz/2), Math.round(ps.y - sz/2), Math.round(sz), Math.round(sz));
    }
    CTX.restore();

    // Phase 4: void collapse ‚Äî dark imploding circle with purple
    if (this.phase >= 4) {
      const age4 = t - 2.8;
      const collapseR = Math.max(0, 300 - age4 * 120);
      const colAlpha = Math.max(0, 1 - age4 / 2.4);
      CTX.save();
      const vg = CTX.createRadialGradient(bsx, bsy, 0, bsx, bsy, collapseR + 40);
      vg.addColorStop(0, `rgba(0,0,0,${colAlpha})`);
      vg.addColorStop(0.5, `rgba(80,0,120,${colAlpha * 0.6})`);
      vg.addColorStop(1, 'rgba(0,0,0,0)');
      CTX.fillStyle = vg; CTX.fillRect(0, 0, W, H);
      // Inner glow ring
      if (collapseR > 10) {
        CTX.globalAlpha = colAlpha * 0.8;
        CTX.strokeStyle = '#aa00ff';
        CTX.lineWidth = 6;
        CTX.shadowColor = '#aa00ff'; CTX.shadowBlur = 30;
        CTX.beginPath(); CTX.arc(bsx, bsy, collapseR, 0, Math.PI * 2); CTX.stroke();
      }
      CTX.restore();
    }

    // Screen-wide flash (phases 1-2)
    if (this.flashAlpha > 0) {
      CTX.save();
      CTX.globalAlpha = this.flashAlpha;
      // White flash that transitions to orange-red
      const flashPct = this.phase === 1 ? this.timer / 0.15 : 1 - (this.timer - 0.15) / 0.45;
      const flashCol = flashPct > 0.5
        ? `rgba(255,255,255,1)`
        : `rgba(255,${Math.round(flashPct * 2 * 100)},0,1)`;
      CTX.fillStyle = flashCol;
      CTX.fillRect(0, 0, W, H);
      CTX.restore();
    }

    // Phase 2 secondary explosion glow at boss position
    if (this.phase === 2) {
      const age2 = t - 0.15;
      const glowR = age2 * 800;
      const glowA = Math.max(0, 0.8 - age2 / 0.45);
      CTX.save();
      const eg = CTX.createRadialGradient(bsx, bsy, 0, bsx, bsy, glowR);
      eg.addColorStop(0, `rgba(255,200,50,${glowA})`);
      eg.addColorStop(0.3, `rgba(255,80,0,${glowA * 0.7})`);
      eg.addColorStop(0.7, `rgba(150,0,200,${glowA * 0.4})`);
      eg.addColorStop(1, 'rgba(0,0,0,0)');
      CTX.fillStyle = eg; CTX.fillRect(0, 0, W, H);
      CTX.restore();
    }
  }
};

// ====== DAMAGE TEXT ======
const dmgTexts = new Pool(() => ({ active: false, x: 0, y: 0, text: '', timer: 0, color: '#fff' }), 500);
function spawnDmgText(x, y, text, color = '#fff') {
  const t = dmgTexts.get();
  t.x = x + rand(-10, 10); t.y = y - 10; t.text = String(text); t.timer = 0.8; t.color = color;
}

// ====== PICKUPS ======
const GEM_COLORS = { 1: '#4466ff', 10: '#00cc44', 100: '#ff2244', 200: '#ff00aa' };
const pickups = new Pool(() => ({ active: false, x: 0, y: 0, type: 'gem', value: 1, r: 9 }), 2000);
function spawnGem(x, y, value) {
  const p = pickups.get();
  p.x = x + rand(-8, 8); p.y = y + rand(-8, 8);
  p.type = 'gem'; p.value = value;
  p.r = value >= 100 ? 15 : value >= 10 ? 12 : 9;
}
function spawnChest(x, y) {
  const p = pickups.get(); p.x = x; p.y = y; p.type = 'chest'; p.value = 0; p.r = 24;
}
function spawnHeal(x, y) {
  const p = pickups.get(); p.x = x; p.y = y; p.type = 'heal'; p.value = 20; p.r = 12;
}
function spawnWeaponChest(x, y) {
  const p = pickups.get(); p.x = x; p.y = y; p.type = 'weaponChest'; p.value = 0; p.r = 22;
}
function spawnPassiveChest(x, y) {
  const p = pickups.get(); p.x = x; p.y = y; p.type = 'passiveChest'; p.value = 0; p.r = 22;
}
function spawnItemChest(x, y) {
  const p = pickups.get(); p.x = x; p.y = y; p.type = 'itemChest'; p.value = 0; p.r = 22;
}

// ====== PLAYER ======
const player = {
  x: 0, y: 0, r: 18,
  hp: 100, maxHp: 100,
  xp: 0, level: 1, xpToNext: 5,
  baseSpeed: 150,
  might: 1, area: 1, speed: 1, duration: 1, cooldown: 1, magnet: 40,
  weapons: [], passives: [],
  kills: 0, facing: 1, iFrames: 0, alive: true,
  critChance: 0, armor: 0,
  mightMult: 1, defenseBreak: false, invincible: false
};

function playerEffSpeed() { return player.baseSpeed * player.speed; }

// ====== ACTIVE EFFECTS ======
const activeEffects = [];
function addEffect(type, duration) {
  const idx = activeEffects.findIndex(e => e.type === type);
  if (idx !== -1) activeEffects.splice(idx, 1);
  activeEffects.push({ type, timer: duration, duration });
  applyActiveEffects();
  const labels = { mightBoost: '‚öî ÂÇ∑ÂÆ≥ √ó2  ' + duration + 's!', defenseBreak: 'üí• Èò≤Á¶¶Á†¥Á¢é  ' + duration + 's!', invincible: 'üõ° ÁÑ°ÊïµÁãÄÊÖã  ' + duration + 's!' };
  spawnDmgText(player.x, player.y - 40, labels[type] || type, '#ffee00');
}
function applyActiveEffects() {
  player.mightMult = 1; player.defenseBreak = false; player.invincible = false;
  for (const e of activeEffects) {
    if (e.type === 'mightBoost') player.mightMult = 2;
    if (e.type === 'defenseBreak') player.defenseBreak = true;
    if (e.type === 'invincible') player.invincible = true;
  }
}
function updateActiveEffects(dt) {
  for (let i = activeEffects.length - 1; i >= 0; i--) {
    activeEffects[i].timer -= dt;
    if (activeEffects[i].timer <= 0) {
      const expired = activeEffects.splice(i, 1)[0];
      applyActiveEffects();
      const expLabels = { mightBoost: '‚öî ÂÇ∑ÂÆ≥Âä†ÊàêÁµêÊùü', defenseBreak: 'Èò≤Á¶¶ÊÅ¢Âæ©', invincible: 'üõ° ÁÑ°ÊïµÁµêÊùü' };
      spawnDmgText(player.x, player.y - 30, expLabels[expired.type] || 'ÊïàÊûúÁµêÊùü', '#aaa');
    }
  }
}

const mouse = { x: 0, y: 0 };
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; keys[e.code] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; keys[e.code] = false; });

const _uiButtons = [];
function registerBtn(x, y, w, h, state, fn) { _uiButtons.push({ x, y, w, h, state, fn }); }
function hitTestButtons(px, py) {
  for (const b of _uiButtons) {
    if (b.state === game.state && px >= b.x && px <= b.x + b.w && py >= b.y && py <= b.y + b.h) {
      b.fn(); return true;
    }
  }
  return false;
}
CVS.addEventListener('click', e => { hitTestButtons(e.clientX, e.clientY); });

let touchId = null, touchStartX = 0, touchStartY = 0, touchDX = 0, touchDY = 0, touchActive = false;
CVS.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  const tx = t.clientX, ty = t.clientY;
  if (game.state !== 'playing') {
    if (hitTestButtons(tx, ty)) return;
    if (game.state === 'title') { game.start(); return; }
    if (game.state === 'gameover') { game.startNewGame(game.stage); return; }
    return;
  }
  touchId = t.identifier; touchStartX = tx; touchStartY = ty;
  touchActive = true; touchDX = 0; touchDY = 0;
}, { passive: false });
CVS.addEventListener('touchmove', e => {
  e.preventDefault();
  if (game.state !== 'playing') return;
  for (const t of e.changedTouches) {
    if (t.identifier === touchId) {
      touchDX = t.clientX - touchStartX; touchDY = t.clientY - touchStartY;
      const mag = Math.sqrt(touchDX * touchDX + touchDY * touchDY);
      if (mag > 60) { touchDX = touchDX / mag * 60; touchDY = touchDY / mag * 60; }
    }
  }
}, { passive: false });
CVS.addEventListener('touchend', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === touchId) { touchActive = false; touchDX = 0; touchDY = 0; touchId = null; }
  }
}, { passive: false });

function getInputDir() {
  let dx = 0, dy = 0;
  if (keys['w'] || keys['arrowup'] || keys['ArrowUp']) dy -= 1;
  if (keys['s'] || keys['arrowdown'] || keys['ArrowDown']) dy += 1;
  if (keys['a'] || keys['arrowleft'] || keys['ArrowLeft']) dx -= 1;
  if (keys['d'] || keys['arrowright'] || keys['ArrowRight']) dx += 1;
  if (touchActive) {
    const mag = Math.sqrt(touchDX * touchDX + touchDY * touchDY);
    if (mag > 10) { dx = touchDX / mag; dy = touchDY / mag; }
  }
  const mag = Math.sqrt(dx * dx + dy * dy);
  if (mag > 0) { dx /= mag; dy /= mag; }
  return { x: dx, y: dy };
}

// ====== ENEMIES ======
const ENEMY_DEFS = {
  bat:      { hp: 5,      dmg: 2,  speed: 90,  r: 12,  color: '#a66', xp: 1,   knockback: 1   },
  skeleton: { hp: 10,     dmg: 5,  speed: 55,  r: 15,  color: '#cca', xp: 1,   knockback: 1   },
  ghost:    { hp: 20,     dmg: 5,  speed: 35,  r: 18,  color: '#88f', xp: 10,  knockback: 0.2 },
  zombie:   { hp: 30,     dmg: 8,  speed: 30,  r: 21,  color: '#4a4', xp: 1,   knockback: 1   },
  boss:     { hp: 9000,   dmg: 20, speed: 40,  r: 45,  color: '#f80', xp: 100, knockback: 0.3 },
  reaper:   { hp: 999999, dmg: 9999, speed: 60, r: 30, color: '#000', xp: 0,   knockback: 0   },
  darkbat:  { hp: 15,     dmg: 4,  speed: 120, r: 12,  color: '#604', xp: 2,   knockback: 1   },
  lich:     { hp: 80,     dmg: 12, speed: 45,  r: 18,  color: '#88e', xp: 5,   knockback: 0.5 },
  gargoyle: { hp: 120,    dmg: 15, speed: 25,  r: 24,  color: '#666', xp: 5,   knockback: 0.8 },
  boss2:    { hp: 24000,  dmg: 30, speed: 50,  r: 48,  color: '#a00', xp: 200, knockback: 0.3 },
  // Stage 3 Boss (3√ó HP)
  boss3:    { hp: 150000,  dmg: 45, speed: 38,  r: 65,  color: '#408', xp: 5000, knockback: 0.1 },
  boss3_form2:{hp: 48000, dmg: 55, speed: 65,  r: 55,  color: '#f00', xp: 10000,knockback: 0   }
};

const enemies = new Pool(() => ({
  active: false, x: 0, y: 0, r: 10, hp: 10, maxHp: 10, dmg: 5, speed: 50,
  type: 'bat', color: '#a66', xp: 1, knockback: 1,
  kbx: 0, kby: 0, hitTimer: 0, flashTimer: 0
}), 1000);

function spawnEnemy(type, x, y) {
  const def = ENEMY_DEFS[type]; if (!def) return;
  const e = enemies.get();
  // Bypass scaling for stage 3 bosses to keep exact tuning
  const timeMult = type.startsWith('boss3') ? 1 : (1 + game.time / 120);
  const stageMult = type.startsWith('boss3') ? 1 : (game.stage === 2 ? 2.5 : 1);
  e.x = x; e.y = y; e.type = type;
  e.hp = def.hp * timeMult * stageMult;
  e.maxHp = e.hp;
  e.dmg = def.dmg * (game.stage >= 2 && !type.startsWith('boss3') ? 1.5 : 1);
  e.speed = def.speed;
  e.r = def.r; e.color = def.color; e.xp = def.xp; e.knockback = def.knockback;
  e.kbx = 0; e.kby = 0; e.hitTimer = 0; e.flashTimer = 0;
  return e;
}

function spawnEnemyAtEdge(type) {
  const angle = rand(0, PI2);
  const d = Math.max(W, H) / 2 + 80;
  spawnEnemy(type, player.x + Math.cos(angle) * d, player.y + Math.sin(angle) * d);
}

// ====== BULLETS ======
const bullets = new Pool(() => ({
  active: false, x: 0, y: 0, vx: 0, vy: 0, r: 7, dmg: 10, pierce: 1, timer: 5,
  type: 'bullet', color: '#ff0', hitSet: null, ownerOffsetAngle: 0, orbitRadius: 0, orbitSpeed: 0
}), 500);

function fireBullet(x, y, angle, speed, dmg, r, pierce, timer, color, type) {
  const b = bullets.get();
  b.x = x; b.y = y; b.vx = Math.cos(angle) * speed; b.vy = Math.sin(angle) * speed;
  b.r = r; b.dmg = dmg; b.pierce = pierce; b.timer = timer; b.color = color; b.type = type || 'bullet';
  b.hitSet = new Set(); b.ownerOffsetAngle = 0; b.orbitRadius = 0; b.orbitSpeed = 0;
  return b;
}

// ====== WEAPON DEFINITIONS ======
const WEAPON_DEFS = {
  whip: {
    name: 'ÁöÆÈû≠ Whip', icon: 'ü™¢', maxLv: 8, base: { dmg: 10, cd: 1.5, areaW: 100, areaH: 50, pierce: 999, dur: 0.3 },
    lvUp: (w) => { w.dmg += 3; w.areaW += 15; if (w.level % 2 === 0) w.cd = Math.max(0.5, w.cd - 0.1); },
    fire: (w, dt) => {
      w.cdTimer -= dt; if (w.cdTimer > 0) return; w.cdTimer = w.cd * player.cooldown;
      const aw = w.areaW * player.area, ah = w.areaH * player.area;
      const hx = player.x + player.facing * aw / 2;
      const b = fireBullet(hx, player.y, 0, 0, w.dmg * player.might, Math.max(aw, ah) / 2, 999, w.dur * player.duration, 'rgba(255,255,200,0.5)', 'melee');
      b.mw = aw; b.mh = ah; b.mx = hx - aw / 2; b.my = player.y - ah / 2;
    }
  },
  wand: {
    name: 'È≠îÊùñ Magic Wand', icon: 'ü™Ñ', maxLv: 8, base: { dmg: 15, cd: 1.0, speed: 300, projCount: 1, pierce: 1 },
    lvUp: (w) => { w.dmg += 3; if (w.level % 2 === 0) w.projCount += 1; if (w.level >= 6) w.pierce += 1; },
    fire: (w, dt) => {
      w.cdTimer -= dt; if (w.cdTimer > 0) return; w.cdTimer = w.cd * player.cooldown;
      for (let i = 0; i < w.projCount; i++) {
        const target = findNearest(player, i); if (!target) continue;
        const a = angleTo(player, target);
        const px = player.x, py = player.y, spd = w.speed * player.speed, dmg = w.dmg * player.might, prc = w.pierce;
        setTimeout(() => { if (game.state === 'playing') fireBullet(px, py, a, spd, dmg, 7, prc, 3, '#aaf', 'bullet'); }, i * 80);
      }
    }
  },
  axe: {
    name: 'È£õÊñß Axe', icon: 'ü™ì', maxLv: 8, base: { dmg: 20, cd: 1.5, projCount: 1, pierce: 2, area: 15 },
    lvUp: (w) => { w.dmg += 5; if (w.level % 2 === 0) w.projCount += 1; w.pierce += 1; },
    fire: (w, dt) => {
      w.cdTimer -= dt; if (w.cdTimer > 0) return; w.cdTimer = w.cd * player.cooldown;
      for (let i = 0; i < w.projCount; i++) {
        const spread = (i - (w.projCount - 1) / 2) * 0.3;
        const b = fireBullet(player.x, player.y, -Math.PI / 2 + spread + rand(-0.2, 0.2), 250 * player.speed, w.dmg * player.might, w.area * player.area, w.pierce, 3, '#c84', 'axe');
        b.gravity = 200; b.spin = rand(-8, 8);
      }
    }
  },
  bible: {
    name: 'ËÅñÁ∂ì King Bible', icon: 'üìñ', maxLv: 8, base: { dmg: 5, cd: 3.0, dur: 3, orbCount: 1, orbitR: 70, orbitSpeed: 3, area: 12 },
    lvUp: (w) => { w.dmg += 2; w.dur += 0.5; if (w.level % 2 === 0) w.orbCount += 1; w.orbitR += 5; w.orbitSpeed += 0.2; },
    fire: (w, dt) => {
      w.cdTimer -= dt; if (w.cdTimer > 0 || w._orbiting) return; w.cdTimer = w.cd * player.cooldown;
      w._orbiting = true; w._orbTimer = w.dur * player.duration; w._orbs = [];
      for (let i = 0; i < w.orbCount; i++) {
        const b = fireBullet(player.x, player.y, 0, 0, w.dmg * player.might, w.area * player.area, 999, w.dur * player.duration + 0.5, '#ff8', 'bible');
        b.ownerOffsetAngle = (PI2 / w.orbCount) * i; b.orbitRadius = w.orbitR * player.area; b.orbitSpeed = w.orbitSpeed;
        b.hitSet = new Set(); b._hitResetTimer = 0; w._orbs.push(b);
      }
    },
    update: (w, dt) => {
      if (!w._orbiting) return;
      w._orbTimer -= dt;
      if (w._orbTimer <= 0) { w._orbiting = false; for (const b of w._orbs) b.active = false; w._orbs = []; return; }
      w._orbAngle = (w._orbAngle || 0) + w.orbitSpeed * dt;
      w._orbs = w._orbs.filter(b => b.active);
      if (w._orbs.length === 0) { w._orbiting = false; return; }
      for (const b of w._orbs) {
        b.x = player.x + Math.cos(w._orbAngle + b.ownerOffsetAngle) * b.orbitRadius;
        b.y = player.y + Math.sin(w._orbAngle + b.ownerOffsetAngle) * b.orbitRadius;
        b._hitResetTimer = (b._hitResetTimer || 0) + dt;
        if (b._hitResetTimer > 0.3) { b._hitResetTimer = 0; b.hitSet.clear(); }
      }
    }
  },
  firewand: {
    name: 'ÁÅ´ÁêÉ Fire Wand', icon: 'üî•', maxLv: 8, base: { dmg: 30, cd: 1.2, speed: 200, pierce: 1 },
    lvUp: (w) => { w.dmg += 8; if (w.level >= 4) w.pierce += 1; },
    fire: (w, dt) => {
      w.cdTimer -= dt; if (w.cdTimer > 0) return; w.cdTimer = w.cd * player.cooldown;
      const candidates = []; enemies.each(e => { if (dist(player, e) < 600) candidates.push(e); });
      const target = candidates.length > 0 ? candidates[randInt(0, candidates.length - 1)] : null;
      fireBullet(player.x, player.y, target ? angleTo(player, target) : rand(0, PI2), w.speed * player.speed, w.dmg * player.might, 10, w.pierce, 4, '#f60', 'fireball');
    }
  },
  lightning: {
    name: 'ÈñÉÈõª Lightning', icon: '‚ö°', maxLv: 8, base: { dmg: 40, cd: 1.8, chainCount: 2, range: 250 },
    lvUp: (w) => { w.dmg += 10; if (w.level % 2 === 0) w.chainCount += 1; w.range += 20; },
    fire: (w, dt) => {
      w.cdTimer -= dt; if (w.cdTimer > 0) return; w.cdTimer = w.cd * player.cooldown;
      const sorted = []; enemies.each(e => { const d = dist(player, e); if (d < w.range) sorted.push({ e, d }); });
      sorted.sort((a, b) => a.d - b.d);
      const hit = new Set(); let last = null;
      for (let i = 0; i < Math.min(w.chainCount, sorted.length); i++) {
        const { e } = sorted[i]; if (hit.has(e)) continue; hit.add(e); damageEnemy(e, w.dmg * player.might);
        const b = fireBullet(last ? last.x : player.x, last ? last.y : player.y, angleTo(last || player, e), 0, 0, 5, 0, 0.15, '#ccffff', 'lightning');
        b.lx2 = e.x; b.ly2 = e.y; last = e;
      }
    }
  },
  cross: {
    name: 'ÂçÅÂ≠óÊû∂ Holy Cross', icon: '‚úùÔ∏è', maxLv: 8, base: { dmg: 25, cd: 2.0, pierce: 5, speed: 280 },
    lvUp: (w) => { w.dmg += 6; w.pierce += 2; if (w.level % 3 === 0) w.cd = Math.max(0.8, w.cd - 0.2); },
    fire: (w, dt) => {
      w.cdTimer -= dt; if (w.cdTimer > 0) return; w.cdTimer = w.cd * player.cooldown;
      for (let i = 0; i < 4; i++) fireBullet(player.x, player.y, (Math.PI / 2) * i, w.speed * player.speed, w.dmg * player.might, 9, w.pierce, 3, '#ffffcc', 'cross');
    }
  },
  shadow: {
    name: 'ÊöóÂΩ±ÂàÉ Shadow Blade', icon: 'üó°', maxLv: 8, base: { dmg: 50, cd: 2.5, projCount: 3, speed: 350, pierce: 1 },
    lvUp: (w) => { w.dmg += 12; if (w.level % 2 === 0) w.projCount += 1; if (w.level >= 5) w.pierce += 1; },
    fire: (w, dt) => {
      w.cdTimer -= dt; if (w.cdTimer > 0) return; w.cdTimer = w.cd * player.cooldown;
      const target = findNearest(player); const baseAngle = target ? angleTo(player, target) : 0;
      for (let i = 0; i < w.projCount; i++) {
        const px = player.x, py = player.y, spd = w.speed * player.speed, dmg = w.dmg * player.might, prc = w.pierce;
        setTimeout(() => { if (game.state === 'playing') fireBullet(px, py, baseAngle + (i - (w.projCount - 1) / 2) * 0.18, spd, dmg, 8, prc, 2.5, '#aa44ff', 'shadow'); }, i * 60);
      }
    }
  }
};

function createWeapon(type) { return { type, level: 1, cdTimer: 0, ...WEAPON_DEFS[type].base, _orbiting: false, _orbs: [], _orbAngle: 0, _orbTimer: 0 }; }
function upgradeWeapon(w) { if (w.level >= WEAPON_DEFS[w.type].maxLv) return; w.level++; WEAPON_DEFS[w.type].lvUp(w); }
function findNearest(from, skip = 0) {
  const sorted = []; enemies.each(e => { sorted.push({ e, d: dist(from, e) }); });
  sorted.sort((a, b) => a.d - b.d); return sorted.length > skip ? sorted[skip].e : null;
}

// ====== PASSIVE DEFINITIONS ======
const PASSIVE_DEFS = {
  spinach:    { name: 'Ëè†Ëèú Spinach',         icon: 'ü•¨', maxLv: 5, desc: 'ÂÇ∑ÂÆ≥ +10%',   apply: (lv) => { player.might += lv * 0.1; } },
  heart:      { name: 'Á©∫Ëôõ‰πãÂøÉ Hollow Heart', icon: 'üíú', maxLv: 5, desc: 'ÊúÄÂ§ßHP +20%', apply: (lv) => { player.maxHp = 100 * (1 + lv * 0.2); if (player.hp > player.maxHp) player.hp = player.maxHp; } },
  candle:     { name: 'Áá≠Âè∞ Candelabrador',   icon: 'üïØÔ∏è', maxLv: 5, desc: 'ÁØÑÂúç +10%',   apply: (lv) => { player.area += lv * 0.1; } },
  bracer:     { name: 'Ë≠∑ËÖï Bracer',          icon: 'ü¶æ', maxLv: 5, desc: 'ÈÄüÂ∫¶ +10%',   apply: (lv) => { player.speed += lv * 0.1; } },
  tome:       { name: 'È≠îÊ≥ïÊõ∏ Empty Tome',    icon: 'üìï', maxLv: 5, desc: 'ÂÜ∑Âçª -8%',    apply: (lv) => { player.cooldown = Math.max(0.3, player.cooldown - lv * 0.08); } },
  attractorb: { name: 'Âê∏ÂºïÂô® Attractorb',    icon: 'üß≤', maxLv: 5, desc: 'ÊãæÂèñÁØÑÂúç +30%', apply: (lv) => { player.magnet += 40 * lv * 0.3; } },
  clover:     { name: 'Âπ∏ÈÅãËçâ Lucky Clover',  icon: 'üçÄ', maxLv: 5, desc: 'Êö¥Êìä +10%',   apply: (lv) => { player.critChance = lv * 0.1; } },
  wings:      { name: 'ÊÉ°È≠îÁøº Demon Wings',   icon: 'ü¶Ö', maxLv: 5, desc: 'ÈÄüÂ∫¶ +15%',   apply: (lv) => { player.speed = Math.min(3, (player.speed || 1) + lv * 0.15); } },
  soul:       { name: 'ÈùàÈ≠ÇËÉΩÈáè Soul Power',  icon: 'üîÆ', maxLv: 5, desc: 'ÂÇ∑ÂÆ≥ +15%',   apply: (lv) => { player.might = Math.min(5, (player.might || 1) + lv * 0.15); } },
  armor:      { name: 'ÊöóÈêµË≠∑Áî≤ Dark Armor',  icon: 'üõ°', maxLv: 5, desc: 'ÂèóÂÇ∑Ê∏õÂ∞ë 10%', apply: (lv) => { player.armor = lv * 0.1; } }
};

function getPassiveLevel(type) { const p = player.passives.find(p => p.type === type); return p ? p.level : 0; }
function addOrUpgradePassive(type) {
  let p = player.passives.find(p => p.type === type);
  if (p) { if (p.level < PASSIVE_DEFS[type].maxLv) p.level++; } else { player.passives.push({ type, level: 1 }); }
  applyPassives();
}
function applyPassives() {
  player.might = 1; player.area = 1; player.speed = 1; player.duration = 1;
  player.cooldown = 1; player.magnet = 40; player.maxHp = 100; player.critChance = 0; player.armor = 0;
  for (const p of player.passives) PASSIVE_DEFS[p.type].apply(p.level);
}

// ====== LEVEL UP ======
function xpNeeded(level) {
  if (level === 1) return 5; if (level === 2) return 10;
  return Math.floor(10 * Math.pow(1.15, level - 2));
}

let _pendingLevelUps = 0;
function addXP(amount) {
  player.xp += amount;
  while (player.xp >= player.xpToNext) {
    player.xp -= player.xpToNext; player.level++; player.xpToNext = xpNeeded(player.level); _pendingLevelUps++;
  }
  if (_pendingLevelUps > 0 && game.state === 'playing') { _pendingLevelUps--; showLevelUpScreen(); }
}
function consumeNextLevelUp() { if (_pendingLevelUps > 0) { _pendingLevelUps--; showLevelUpScreen(); } }

function getAvailableWeapons() {
  if (game.stage === 1) return ['whip', 'wand', 'axe', 'bible', 'firewand'];
  return ['whip', 'wand', 'axe', 'bible', 'firewand', 'lightning', 'cross', 'shadow'];
}
function getAvailablePassives() {
  if (game.stage === 1) return ['spinach', 'heart', 'candle', 'bracer', 'tome', 'attractorb'];
  return ['spinach', 'heart', 'candle', 'bracer', 'tome', 'attractorb', 'clover', 'wings', 'soul', 'armor'];
}

function maxWeaponSlots() { return game.stage >= 2 ? 4 : 3; }
function maxPassiveSlots() { return game.stage >= 2 ? 4 : 3; }

function generateChoices() {
  const pool = [];
  const weaponTypes = getAvailableWeapons(); const passiveTypes = getAvailablePassives();
  for (const w of player.weapons) if (w.level < WEAPON_DEFS[w.type].maxLv) pool.push({ cat: 'weapon', type: w.type, isNew: false, level: w.level + 1 });
  if (player.weapons.length < maxWeaponSlots()) {
    for (const t of weaponTypes) if (!player.weapons.find(w => w.type === t)) pool.push({ cat: 'weapon', type: t, isNew: true, level: 1 });
  }
  for (const p of player.passives) if (p.level < PASSIVE_DEFS[p.type].maxLv) pool.push({ cat: 'passive', type: p.type, isNew: false, level: p.level + 1 });
  if (player.passives.length < maxPassiveSlots()) {
    for (const t of passiveTypes) if (!player.passives.find(p => p.type === t)) pool.push({ cat: 'passive', type: t, isNew: true, level: 1 });
  }
  for (let i = pool.length - 1; i > 0; i--) { const j = randInt(0, i); [pool[i], pool[j]] = [pool[j], pool[i]]; }
  return pool.slice(0, 3);
}

let levelUpChoices = [];
function showLevelUpScreen() {
  levelUpChoices = generateChoices();
  if (levelUpChoices.length === 0) return;
  game.state = 'levelup';
}

function selectChoice(idx) {
  const ch = levelUpChoices[idx]; if (!ch) return;
  if (ch.cat === 'weapon') {
    if (ch.isNew) player.weapons.push(createWeapon(ch.type));
    else { const w = player.weapons.find(w => w.type === ch.type); if (w) upgradeWeapon(w); }
  } else { addOrUpgradePassive(ch.type); }
  game.state = 'playing'; consumeNextLevelUp();
}

function openChest() {
  const numUpgrades = randInt(1, 3);
  for (let i = 0; i < numUpgrades; i++) {
    const choices = generateChoices();
    if (choices.length > 0) {
      const ch = choices[0];
      if (ch.cat === 'weapon') {
        if (ch.isNew) player.weapons.push(createWeapon(ch.type));
        else { const w = player.weapons.find(w => w.type === ch.type); if (w) upgradeWeapon(w); }
      } else { addOrUpgradePassive(ch.type); }
    }
  }
  spawnDmgText(player.x, player.y - 30, 'ÂØ∂ÁÆ±! +' + numUpgrades + ' ÂçáÁ¥ö', '#ff0');
}

function openWeaponChest() {
  const weaponTypes = getAvailableWeapons();
  const upgradable = player.weapons.filter(w => w.level < WEAPON_DEFS[w.type].maxLv);
  if (upgradable.length > 0) {
    const w = upgradable[randInt(0, upgradable.length - 1)]; upgradeWeapon(w);
    spawnDmgText(player.x, player.y - 40, '‚öî ' + WEAPON_DEFS[w.type].name + ' Lv' + w.level + '!', '#ffd700'); return;
  }
  if (player.weapons.length < maxWeaponSlots()) {
    const avail = weaponTypes.filter(t => !player.weapons.find(w => w.type === t));
    if (avail.length > 0) {
      const t = avail[randInt(0, avail.length - 1)]; player.weapons.push(createWeapon(t));
      spawnDmgText(player.x, player.y - 40, '‚öî Êñ∞Ê≠¶Âô®: ' + WEAPON_DEFS[t].name + '!', '#ffd700'); return;
    }
  }
  addXP(50); spawnDmgText(player.x, player.y - 40, '‚öî Ê≠¶Âô®Â∑≤Êªø! +50 XP', '#ffd700');
}

function openPassiveChest() {
  const passiveTypes = getAvailablePassives();
  const upgradable = player.passives.filter(p => p.level < PASSIVE_DEFS[p.type].maxLv);
  if (upgradable.length > 0) {
    const p = upgradable[randInt(0, upgradable.length - 1)]; addOrUpgradePassive(p.type);
    spawnDmgText(player.x, player.y - 40, '‚ú¶ ' + PASSIVE_DEFS[p.type].name + ' Lv' + p.level + '!', '#88ff88'); return;
  }
  if (player.passives.length < maxPassiveSlots()) {
    const avail = passiveTypes.filter(t => !player.passives.find(p => p.type === t));
    if (avail.length > 0) {
      const t = avail[randInt(0, avail.length - 1)]; addOrUpgradePassive(t);
      spawnDmgText(player.x, player.y - 40, '‚ú¶ Êñ∞ÊäÄËÉΩ: ' + PASSIVE_DEFS[t].name + '!', '#88ff88'); return;
    }
  }
  addXP(50); spawnDmgText(player.x, player.y - 40, '‚ú¶ ÊäÄËÉΩÂ∑≤Êªø! +50 XP', '#88ff88');
}

const ITEM_EFFECTS = [
  { id: 'mightBoost', label: '‚öî ÁãÇÊö¥‰πãÂäõ', desc: '30ÁßíÂÇ∑ÂÆ≥ √ó2', color: '#ff6600', instant: false, fn: () => addEffect('mightBoost', 30) },
  { id: 'aoeBlast', label: 'üí• ÂÖ®Ëû¢ÂπïË°ùÊìäÊ≥¢', desc: 'ÂÖ®Ëû¢ÂπïÊÄ™Áâ©Âèó 50 ÂÇ∑ÂÆ≥', color: '#ff2244', instant: true, fn: () => {
      let hit = 0; enemies.each(e => { if (e.type !== 'reaper') { damageEnemy(e, 50); hit++; } });
      spawnDmgText(player.x, player.y - 50, 'üí• Ë°ùÊìäÊ≥¢! ' + hit + ' ÈöªÂèóÂÇ∑', '#ff2244');
    }
  },
  { id: 'defenseBreak', label: 'üó° Èò≤Á¶¶Á†¥Á¢é', desc: '30ÁßíÊïµ‰∫∫Èò≤Á¶¶Èôç 50%', color: '#ff88ff', instant: false, fn: () => addEffect('defenseBreak', 30) },
  { id: 'invincible', label: 'üõ° ÁÑ°ÊïµË≠∑Áõæ', desc: '10ÁßíÂÖçÁñ´ÊâÄÊúâÂÇ∑ÂÆ≥', color: '#44ddff', instant: false, fn: () => addEffect('invincible', 10) }
];

function openItemChest() {
  const eff = ITEM_EFFECTS[randInt(0, ITEM_EFFECTS.length - 1)];
  eff.fn();
  if (!eff.instant) spawnDmgText(player.x, player.y - 30, eff.label + ': ' + eff.desc, eff.color);
}

// ====== WAVE SYSTEM ======
const waveSystem = {
  bossSpawned: false, reaperSpawned: false, boss2Count: 0,
  boss3Spawned: false,
  _spawnAccum: 0, _nextBoss2Time: 5 * 60,
  _chestAccum: 0, _nextChestIn: 30,

  init() {
    this.bossSpawned = false; this.reaperSpawned = false; this.boss2Count = 0; this.boss3Spawned = false;
    this._spawnAccum = 0; this._nextBoss2Time = 5 * 60;
    this._chestAccum = 0; this._nextChestIn = rand(30, 50);
  },

  update(dt) {
    const t = game.time;

    if (game.stage === 1) {
      const spawnRate = this.getSpawnRate1(t);
      this._spawnAccum += dt * spawnRate;
      while (this._spawnAccum >= 1) { this._spawnAccum -= 1; this.spawnS1Enemy(t); }

      if (t >= 180 && !this.bossSpawned) {
        this.bossSpawned = true; spawnEnemyAtEdge('boss'); spawnDmgText(player.x, player.y - 50, '‚ö† BOSS Âá∫Áèæ!', '#f80');
      }
      if (t >= 600) { game.state = 'victory'; return; }

    } else if (game.stage === 2) {
      const spawnRate = this.getSpawnRate2(t);
      this._spawnAccum += dt * spawnRate;
      while (this._spawnAccum >= 1) { this._spawnAccum -= 1; this.spawnS2Enemy(t); }

      if (this.boss2Count < 3 && t >= this._nextBoss2Time) {
        this.boss2Count++; this._nextBoss2Time += 5 * 60;
        spawnEnemyAtEdge('boss2'); spawnDmgText(player.x, player.y - 60, '‚ö† ÊÉ°È≠îÁéãÈôçËá®! (' + this.boss2Count + '/3)', '#ff4400');
        game.shake(8, 0.4);
      }
      if (t >= 1080 && !this.reaperSpawned) {
        this.reaperSpawned = true; spawnEnemyAtEdge('reaper'); spawnDmgText(player.x, player.y - 50, '‚ò† Ê≠ªÁ•ûÈôçËá®!', '#f00');
      }

      this._chestAccum += dt;
      if (this._chestAccum >= this._nextChestIn) {
        this._chestAccum = 0; this._nextChestIn = rand(35, 55); this.spawnRandomS2Chest();
      }
      if (t >= 1200) { game.state = 'victory'; return; }

    } else if (game.stage === 3) {
      // Stage 3 - Boss only + Special Chests
      if (!this.boss3Spawned) {
        this.boss3Spawned = true;
        spawnEnemyAtEdge('boss3');
        spawnDmgText(player.x, player.y - 80, '‚ö† ÁµÇÊ•µÈªëÊöóÈôçËá®ÔºÅ', '#aa00ff');
        game.shake(15, 0.6);
      }
      
      this._chestAccum += dt;
      if (this._chestAccum >= this._nextChestIn) {
        this._chestAccum = 0;
        this._nextChestIn = rand(15, 25);
        const chestCount = randInt(1, 5);
        for(let i=0; i<chestCount; i++) {
          this.spawnRandomS2Chest(); // reuse S2 random chest generation logic
        }
      }
    }
  },

  getSpawnRate1(t) { if (t < 60) return 1.5; if (t < 180) return 2.5; if (t < 300) return 4; if (t < 480) return 5; return 7; },
  getSpawnRate2(t) { if (t < 120) return 3; if (t < 360) return 5; if (t < 600) return 7; if (t < 900) return 9; return 12; },

  spawnS1Enemy(t) {
    if (enemies.count() > 500) return;
    let type;
    if (t < 60) type = 'bat'; else if (t < 180) type = Math.random() < 0.6 ? 'bat' : 'skeleton';
    else if (t < 300) type = Math.random() < 0.5 ? 'skeleton' : 'zombie'; else if (t < 480) type = Math.random() < 0.5 ? 'ghost' : 'bat';
    else { const r = Math.random(); if (r < 0.25) type = 'bat'; else if (r < 0.5) type = 'skeleton'; else if (r < 0.75) type = 'zombie'; else type = 'ghost'; }
    spawnEnemyAtEdge(type);
  },

  spawnS2Enemy(t) {
    if (enemies.count() > 600) return;
    const r = Math.random(); let type;
    if (t < 120) { type = r < 0.5 ? 'darkbat' : 'skeleton'; } else if (t < 360) { type = r < 0.4 ? 'lich' : (r < 0.7 ? 'gargoyle' : 'darkbat'); }
    else if (t < 600) { type = r < 0.35 ? 'lich' : (r < 0.65 ? 'gargoyle' : (r < 0.85 ? 'ghost' : 'zombie')); }
    else { type = r < 0.3 ? 'lich' : (r < 0.6 ? 'gargoyle' : (r < 0.8 ? 'ghost' : 'zombie')); }
    spawnEnemyAtEdge(type);
  },

  spawnRandomS2Chest() {
    const angle = rand(0, Math.PI * 2); const d = rand(120, 220);
    const x = player.x + Math.cos(angle) * d, y = player.y + Math.sin(angle) * d;
    const roll = Math.random();
    if (roll < 0.35) { spawnWeaponChest(x, y); spawnDmgText(x, y - 30, '‚öî Ê≠¶Âô®ÂØ∂ÁÆ±!', '#ffd700'); }
    else if (roll < 0.70) { spawnPassiveChest(x, y); spawnDmgText(x, y - 30, '‚ú¶ ÊäÄËÉΩÂØ∂ÁÆ±!', '#88ff88'); }
    else { spawnItemChest(x, y); spawnDmgText(x, y - 30, 'üéÅ ÈÅìÂÖ∑ÂØ∂ÁÆ±!', '#44ddff'); }
  }
};

// ====== GAME STATE ======
const stage3Selections = { weapons: [], passives: [] };

const game = {
  state: 'title', // title|weaponSelect|stage3Select|playing|levelup|gameover|gameover2|victory|victory3
  selectedWeapon: 'whip',
  stage: 1, time: 0, shakeTimer: 0, shakeIntensity: 0, reviveCount: 0, MAX_REVIVES: 3,

  reset(weaponType, stage) {
    game.stage = stage || 1;
    player.x = 0; player.y = 0; player.hp = 100; player.maxHp = 100;
    player.xp = 0; player.level = 1; player.xpToNext = 5;
    player.might = 1; player.area = 1; player.speed = 1; player.duration = 1;
    player.cooldown = 1; player.magnet = 40; player.critChance = 0; player.armor = 0;
    
    if (game.stage === 3) {
      player.weapons = stage3Selections.weapons.map(t => createWeapon(t));
      player.passives = stage3Selections.passives.map(t => ({type: t, level: 1}));
      applyPassives();
    } else {
      player.weapons = [createWeapon(weaponType || this.selectedWeapon || 'whip')];
      player.passives = [];
    }

    player.kills = 0; player.facing = 1; player.iFrames = 0; player.alive = true;
    if (stage !== 2 && stage !== 3) this.reviveCount = 0; 
    _pendingLevelUps = 0; activeEffects.length = 0;
    bossExplosion.active = false; bossExplosion.done = false; bossExplosion.phase = 0;
    player.mightMult = 1; player.defenseBreak = false; player.invincible = false;
    enemies.items.forEach(e => e.active = false); bullets.items.forEach(b => b.active = false);
    pickups.items.forEach(p => p.active = false); dmgTexts.items.forEach(t => t.active = false);
    this.time = 0; this.shakeTimer = 0; this.shakeIntensity = 0;
    cam.x = 0; cam.y = 0; waveSystem.init(); this.state = 'playing';
  },
  start() { this.state = 'weaponSelect'; },
  startNewGame(stage) {
    this.stage = stage || 1; this.selectedWeapon = 'whip';
    if (this.stage === 3) {
      stage3Selections.weapons = []; stage3Selections.passives = [];
      this.state = 'stage3Select';
    } else {
      this.state = 'weaponSelect';
    }
  },
  shake(intensity, dur) { this.shakeIntensity = intensity; this.shakeTimer = dur; }
};

// ====== PIXEL ART RENDERING ======
function drawGround() {
  CTX.fillStyle = game.stage === 3 ? '#050010' : '#0d0818';
  CTX.fillRect(0, 0, W, H);
  const tileSize = 48;
  const startX = Math.floor((cam.x - W / 2) / tileSize) * tileSize;
  const startY = Math.floor((cam.y - H / 2) / tileSize) * tileSize;

  for (let tx = startX; tx < cam.x + W / 2 + tileSize; tx += tileSize) {
    for (let ty = startY; ty < cam.y + H / 2 + tileSize; ty += tileSize) {
      const sx = Math.round(tx - cam.x + W / 2), sy = Math.round(ty - cam.y + H / 2);
      const odd = (Math.floor(tx / tileSize) + Math.floor(ty / tileSize)) % 2;
      
      if (game.stage === 3) {
        CTX.fillStyle = odd ? '#0a001a' : '#060012';
        CTX.fillRect(sx, sy, tileSize, tileSize);
        CTX.fillStyle = 'rgba(100,20,150,0.15)';
      } else {
        CTX.fillStyle = odd ? '#120920' : '#0e0718';
        CTX.fillRect(sx, sy, tileSize, tileSize);
        CTX.fillStyle = 'rgba(80,30,120,0.15)';
      }
      CTX.fillRect(sx, sy, tileSize, 1); CTX.fillRect(sx, sy, 1, tileSize);
    }
  }

  if (game.stage === 2) { CTX.fillStyle = 'rgba(80,0,0,0.10)'; CTX.fillRect(0, 0, W, H); }
  if (game.stage === 3) { CTX.fillStyle = 'rgba(40,0,80,0.15)'; CTX.fillRect(0, 0, W, H); }
}

function drawPixelBat(r, flash) {
  const wa = Math.sin((Date.now() / 140) % PI2) * 0.6;
  const col = flash ? '#fff' : '#7a3a6a', col2 = flash ? '#fff' : '#5a2a50', eyeCol = flash ? '#fff' : '#ff2222';
  CTX.save(); CTX.rotate(-wa - 0.25); pxRect(-r*2.0, -r*0.4, r*2.0, r*0.5, col); CTX.restore();
  CTX.save(); CTX.rotate(wa + 0.25); pxRect(0, -r*0.4, r*2.0, r*0.5, col); CTX.restore();
  pxRect(-r*0.7, -r*0.85, r*1.4, r*1.5, col2);
  pxRect(-r*0.55, -r*1.4, r*0.4, r*0.6, col); pxRect(r*0.15, -r*1.4, r*0.4, r*0.6, col);
  pxRect(-r*0.45, -r*0.3, r*0.35, r*0.35, eyeCol); pxRect(r*0.10, -r*0.3, r*0.35, r*0.35, eyeCol);
  pxRect(-r*0.3, r*0.6, r*0.2, r*0.35, '#eee'); pxRect(r*0.10, r*0.6, r*0.2, r*0.35, '#eee');
}
function drawPixelSkeleton(r, flash) {
  const col = flash ? '#fff' : '#d0c8a8', dark = flash ? '#ccc' : '#908870', eye = flash ? '#fff' : '#44ff22';
  pxRect(-r*0.55, 0, r*1.1, r*0.9, col); pxRect(-r*0.5, -r*1.0, r*1.0, r*1.0, col);
  pxRect(-r*0.38, -r*0.82, r*0.28, r*0.35, '#111'); pxRect(r*0.10, -r*0.82, r*0.28, r*0.35, '#111');
  pxRect(-r*0.33, -r*0.78, r*0.18, r*0.26, eye); pxRect(r*0.15, -r*0.78, r*0.18, r*0.26, eye);
  pxRect(-r*0.4, -r*0.12, r*0.8, r*0.18, col);
  for (let i = 0; i < 3; i++) pxRect(-r*0.48, r*0.12 + i*r*0.25, r*0.96, r*0.12, dark);
  pxRect(-r*0.9, -r*0.1, r*0.38, r*0.7, col); pxRect(r*0.52, -r*0.1, r*0.38, r*0.7, col);
}
function drawPixelGhost(r, flash) {
  const bob = Math.sin(Date.now() / 380) * r * 0.12;
  const col = flash ? '#fff' : '#9999ee', dark = flash ? '#ddd' : '#6666cc';
  CTX.save(); CTX.translate(0, bob);
  pxRect(-r*0.85, -r*0.9, r*1.7, r*1.4, col);
  pxRect(-r*0.85, r*0.45, r*0.6, r*0.25, dark); pxRect(-r*0.05, r*0.45, r*0.6, r*0.25, dark); pxRect(r*0.45, r*0.45, r*0.4, r*0.25, dark);
  pxRect(-r*0.48, -r*0.5, r*0.4, r*0.44, '#111'); pxRect(r*0.08, -r*0.5, r*0.4, r*0.44, '#111');
  pxRect(-r*0.38, -r*0.48, r*0.15, r*0.15, 'rgba(180,200,255,0.7)'); pxRect(r*0.18, -r*0.48, r*0.15, r*0.15, 'rgba(180,200,255,0.7)');
  CTX.restore();
}
function drawPixelZombie(r, flash) {
  CTX.rotate(Math.sin(Date.now() / 260) * 0.08);
  const col = flash ? '#fff' : '#4a6a30', skin = flash ? '#fff' : '#8aaa58', eye = flash ? '#fff' : '#bbaa00';
  pxRect(-r*0.6, -r*0.05, r*1.2, r*0.85, col);
  pxRect(-r*0.35, r*0.15, r*0.2, r*0.55, '#2a4a18'); pxRect(r*0.15, r*0.22, r*0.2, r*0.4, '#2a4a18');
  pxRect(-r*0.52, -r*1.0, r*1.04, r*1.0, skin);
  pxRect(-r*0.15, -r*0.8, r*0.3, r*0.3, '#3a5a28'); pxRect(r*0.2, -r*0.55, r*0.25, r*0.2, '#3a5a28');
  pxRect(-r*0.38, -r*0.78, r*0.28, r*0.26, eye); pxRect(r*0.10, -r*0.78, r*0.28, r*0.26, eye);
  pxRect(-r*0.32, -r*0.74, r*0.12, r*0.14, '#2a1000'); pxRect(r*0.16, -r*0.74, r*0.12, r*0.14, '#2a1000');
  pxRect(-r*0.35, -r*0.38, r*0.7, r*0.22, '#1a0808');
  pxRect(-r*0.24, -r*0.38, r*0.14, r*0.15, '#d8cca8'); pxRect(r*0.10, -r*0.38, r*0.14, r*0.15, '#d8cca8');
  pxRect(r*0.6, -r*0.15, r*0.7, r*0.35, col); pxRect(-r*1.3, -r*0.25, r*0.7, r*0.35, col);
}
function drawPixelBoss(r, flash) {
  const pulse = 1 + Math.sin(Date.now() / 200) * 0.04; CTX.scale(pulse, pulse);
  const col = flash ? '#fff' : '#cc2200', dark = flash ? '#ddd' : '#880000', eye = flash ? '#fff' : '#ff8800';
  pxRect(-r*0.9, -r*0.6, r*1.8, r*1.4, dark); pxRect(-r*0.75, -r*0.85, r*1.5, r*1.2, col);
  pxRect(-r*0.65, -r*0.3, r*1.3, r*0.55, '#440000'); pxRect(-r*0.5, -r*0.6, r*1.0, r*0.35, '#550000');
  pxRect(-r*0.8, -r*1.55, r*0.35, r*0.7, '#110000'); pxRect(-r*0.65, -r*1.8, r*0.2, r*0.3, '#110000');
  pxRect(r*0.45, -r*1.55, r*0.35, r*0.7, '#110000'); pxRect(r*0.45, -r*1.8, r*0.2, r*0.3, '#110000');
  pxRect(-r*0.7, -r*1.6, r*0.25, r*0.55, 'rgba(255,80,0,0.4)'); pxRect(r*0.45, -r*1.6, r*0.25, r*0.55, 'rgba(255,80,0,0.4)');
  pxRect(-r*0.6, -r*0.78, r*1.2, r*0.85, '#8a1800');
  pxRect(-r*0.5, -r*0.62, r*0.38, r*0.34, eye); pxRect(r*0.12, -r*0.62, r*0.38, r*0.34, eye);
  pxRect(-r*0.38, -r*0.58, r*0.1, r*0.26, '#110000'); pxRect(r*0.28, -r*0.58, r*0.1, r*0.26, '#110000');
  pxRect(-r*0.42, -r*0.16, r*0.84, r*0.28, '#080000');
  pxRect(-r*0.32, -r*0.16, r*0.18, r*0.22, '#eee'); pxRect(r*0.14, -r*0.16, r*0.18, r*0.22, '#eee');
}
function drawPixelBoss2(r, flash) {
  const pulse = 1 + Math.sin(Date.now() / 160) * 0.06; CTX.scale(pulse, pulse);
  const col = flash ? '#fff' : '#aa0000', arm = flash ? '#ddd' : '#333344', eye = flash ? '#fff' : '#ff00aa';
  pxRect(-r*1.0, -r*0.7, r*2.0, r*1.6, '#220011'); pxRect(-r*0.85, -r*0.95, r*1.7, r*1.4, col);
  pxRect(-r*0.8, -r*0.5, r*1.6, r*0.7, arm); pxRect(-r*0.6, -r*0.8, r*1.2, r*0.35, arm);
  pxRect(-r*1.1, -r*0.8, r*0.3, r*0.55, '#111122'); pxRect(r*0.8, -r*0.8, r*0.3, r*0.55, '#111122');
  for (let s = -1; s <= 1; s += 2) { pxRect(s*r*0.8, -r*1.7, r*0.28, r*0.8, '#110000'); pxRect(s*r*0.55, -r*1.9, r*0.22, r*0.4, '#220011'); }
  pxRect(-r*0.55, -r*0.62, r*0.3, r*0.3, eye); pxRect(r*0.25, -r*0.62, r*0.3, r*0.3, eye); pxRect(-r*0.12, -r*0.7, r*0.24, r*0.22, '#ffff00');
  pxRect(-r*0.5, -r*0.18, r*1.0, r*0.32, '#080000');
  pxRect(-r*0.38, -r*0.18, r*0.2, r*0.26, '#eee'); pxRect(r*0.18, -r*0.18, r*0.2, r*0.26, '#eee'); pxRect(-r*0.06, -r*0.18, r*0.12, r*0.26, '#eee');
}
function drawPixelReaper(r, flash) {
  CTX.rotate(Math.sin(Date.now() / 450) * 0.07);
  const cloak = flash ? '#fff' : '#150025', pur = flash ? '#ddd' : '#8800cc';
  pxRect(-r*0.85, -r*0.75, r*1.7, r*1.8, cloak); pxRect(-r*0.75, -r*0.95, r*1.5, r*0.25, cloak);
  pxRect(-r*0.7, -r*0.7, r*0.18, r*1.6, 'rgba(0,0,0,0.35)'); pxRect(r*0.52, -r*0.7, r*0.18, r*1.6, 'rgba(0,0,0,0.35)');
  pxRect(-r*0.6, -r*1.2, r*1.2, r*0.5, '#050010'); pxRect(-r*0.45, -r*1.5, r*0.9, r*0.35, '#050010');
  pxRect(-r*0.32, -r*1.2, r*0.64, r*0.55, '#ccc8b0');
  pxRect(-r*0.28, -r*1.1, r*0.22, r*0.24, '#111'); pxRect(r*0.06, -r*1.1, r*0.22, r*0.24, '#111');
  pxRect(-r*0.24, -r*1.06, r*0.14, r*0.16, pur); pxRect(r*0.10, -r*1.06, r*0.14, r*0.16, pur);
  pxRect(r*0.5, -r*0.15, r*0.28, r*0.22, '#ccc8b0');
  pxRect(r*0.58, -r*0.85, r*0.12, r*1.6, '#6a5040');
  pxRect(r*0.5, -r*1.25, r*0.55, r*0.18, '#c0c8d0'); pxRect(r*0.42, -r*1.08, r*0.22, r*0.18, '#c0c8d0'); pxRect(r*0.62, -r*1.42, r*0.35, r*0.18, '#c0c8d0');
}
function drawPixelDarkBat(r, flash) {
  const wa = Math.sin((Date.now() / 100) % PI2) * 0.7;
  const col = flash ? '#fff' : '#440060', col2 = flash ? '#fff' : '#220040', eyeCol = flash ? '#fff' : '#ff00ff';
  CTX.save(); CTX.rotate(-wa - 0.3); pxRect(-r*2.2, -r*0.5, r*2.2, r*0.6, col); CTX.restore();
  CTX.save(); CTX.rotate(wa + 0.3); pxRect(0, -r*0.5, r*2.2, r*0.6, col); CTX.restore();
  pxRect(-r*0.65, -r*0.9, r*1.3, r*1.5, col2);
  pxRect(-r*0.5, -r*1.5, r*0.38, r*0.65, col); pxRect(r*0.12, -r*1.5, r*0.38, r*0.65, col);
  pxRect(-r*0.42, -r*0.35, r*0.32, r*0.32, eyeCol); pxRect(r*0.10, -r*0.35, r*0.32, r*0.32, eyeCol);
}
function drawPixelLich(r, flash) {
  CTX.save(); CTX.translate(0, Math.sin(Date.now() / 300) * r * 0.1);
  const col = flash ? '#fff' : '#8888cc', dark = flash ? '#ddd' : '#444488', eye = flash ? '#fff' : '#00ffcc';
  pxRect(-r*0.7, -r*0.3, r*1.4, r*1.1, dark); pxRect(-r*0.55, -r*0.8, r*1.1, r*0.55, col);
  pxRect(-r*0.45, -r*1.35, r*0.9, r*0.6, col);
  pxRect(-r*0.38, -r*1.22, r*0.26, r*0.28, '#111'); pxRect(r*0.12, -r*1.22, r*0.26, r*0.28, '#111');
  pxRect(-r*0.33, -r*1.18, r*0.16, r*0.18, eye); pxRect(r*0.17, -r*1.18, r*0.16, r*0.18, eye);
  pxRect(-r*0.45, -r*1.65, r*0.9, r*0.32, '#cc9900'); pxRect(-r*0.42, -r*1.8, r*0.18, r*0.2, '#ffcc00');
  pxRect(-r*0.06, -r*1.82, r*0.12, r*0.22, '#ffcc00'); pxRect(r*0.24, -r*1.8, r*0.18, r*0.2, '#ffcc00');
  pxRect(r*0.55, -r*1.2, r*0.12, r*1.4, '#554433'); pxRect(r*0.45, -r*1.4, r*0.32, r*0.22, '#aa44ff');
  CTX.restore();
}
function drawPixelGargoyle(r, flash) {
  const col = flash ? '#fff' : '#666680', dark = flash ? '#ccc' : '#444458', eye = flash ? '#fff' : '#ff4400';
  pxRect(-r*0.7, -r*0.3, r*1.4, r*1.1, dark); pxRect(-r*0.6, -r*0.75, r*1.2, r*0.5, col);
  pxRect(-r*1.1, -r*0.6, r*0.5, r*0.8, dark); pxRect(r*0.6, -r*0.6, r*0.5, r*0.8, dark);
  pxRect(-r*0.5, -r*1.2, r*1.0, r*0.5, col);
  pxRect(-r*0.4, -r*1.5, r*0.18, r*0.35, dark); pxRect(r*0.22, -r*1.5, r*0.18, r*0.35, dark);
  pxRect(-r*0.38, -r*1.1, r*0.28, r*0.25, eye); pxRect(r*0.10, -r*1.1, r*0.28, r*0.25, eye);
  pxRect(-r*0.32, -r*0.78, r*0.16, r*0.2, '#eee'); pxRect(-r*0.06, -r*0.78, r*0.16, r*0.2, '#eee'); pxRect(r*0.20, -r*0.78, r*0.16, r*0.2, '#eee');
}
function drawPixelBoss3(r, flash) {
  // ‚îÄ‚îÄ ÁµÇÊ•µÈªëÊöó ‚îÄ‚îÄ Massive eldritch entity, Phase 1
  const T = Date.now();
  const pulse = 1 + Math.sin(T / 220) * 0.06;
  CTX.scale(pulse, pulse);

  const c0  = flash ? '#fff' : '#0d0022';   // void body
  const c1  = flash ? '#eee' : '#1a0044';   // deep purple
  const c2  = flash ? '#ddd' : '#330066';   // mid purple
  const eye = flash ? '#fff' : '#cc00ff';   // eye glow
  const vn  = flash ? '#ddd' : '#ff00cc';   // vein/accent

  // Rotating outer chaos ring (3 large orbiting blobs)
  const orbT = T / 400;
  for (let i = 0; i < 4; i++) {
    const a = orbT + i * Math.PI / 2;
    const ox = Math.cos(a) * r * 1.55, oy = Math.sin(a) * r * 1.55;
    pxRect(ox - r*0.38, oy - r*0.38, r*0.76, r*0.76, c0);
    pxRect(ox - r*0.26, oy - r*0.26, r*0.52, r*0.52, c1);
    pxRect(ox - r*0.12, oy - r*0.12, r*0.24, r*0.24, eye);
  }

  // Wide shadow wings (flat pixel wings)
  pxRect(-r*2.2, -r*0.55, r*1.4, r*0.4,  c0);   // left wing outer
  pxRect(-r*1.9, -r*0.75, r*1.1, r*0.65, c1);   // left wing mid
  pxRect(-r*1.6, -r*0.9,  r*0.7, r*0.85, c2);   // left wing inner
  pxRect(r*0.8,  -r*0.55, r*1.4, r*0.4,  c0);   // right wing outer
  pxRect(r*0.8,  -r*0.75, r*1.1, r*0.65, c1);
  pxRect(r*0.9,  -r*0.9,  r*0.7, r*0.85, c2);

  // Shoulder spikes (5 per side)
  for (let s = -1; s <= 1; s += 2) {
    for (let k = 0; k < 5; k++) {
      const sx = s * (r*0.85 + k * r*0.22);
      pxRect(sx - r*0.1, -r*(1.4 + k*0.18), r*0.2, r*(0.5 + k*0.12), c1);
      pxRect(sx - r*0.05, -r*(1.55 + k*0.18), r*0.1, r*0.2, vn);
    }
  }

  // Main giant body
  pxRect(-r*1.05, -r*0.55, r*2.1, r*1.6,  c0);   // outer shadow
  pxRect(-r*0.9,  -r*0.8,  r*1.8, r*1.7,  c1);   // core body
  pxRect(-r*0.75, -r*0.95, r*1.5, r*1.5,  c2);   // highlight body

  // Armored chest plates
  pxRect(-r*0.7, -r*0.35, r*1.4, r*0.5, '#1a0033');
  pxRect(-r*0.5, -r*0.6,  r*1.0, r*0.28, '#220044');
  // Chest veins
  pxRect(-r*0.05, -r*0.55, r*0.1, r*0.45, vn);
  pxRect(-r*0.35, -r*0.42, r*0.7, r*0.06, vn);

  // Face / head
  pxRect(-r*0.65, -r*1.3, r*1.3, r*0.75, c1);
  pxRect(-r*0.55, -r*1.45, r*1.1, r*0.55, c2);

  // Crown of spikes (top of head)
  for (let k = -2; k <= 2; k++) {
    const h = r * (0.55 - Math.abs(k) * 0.1);
    pxRect(k * r*0.22 - r*0.07, -r*1.45 - h, r*0.14, h, k===0 ? vn : c1);
  }

  // 3 eyes (main face)
  const eyeT = Math.sin(T / 180);
  pxRect(-r*0.44, -r*1.22, r*0.32, r*0.28, '#0a0018');  // left socket
  pxRect(r*0.12,  -r*1.22, r*0.32, r*0.28, '#0a0018');  // right socket
  pxRect(-r*0.15, -r*1.28, r*0.3,  r*0.22, '#0a0018');  // center socket
  // Eye glow (pulsing)
  const eA = 0.5 + eyeT * 0.5;
  pxRect(-r*0.4,  -r*1.18, r*0.24, r*0.2, eye);
  pxRect(r*0.16,  -r*1.18, r*0.24, r*0.2, eye);
  pxRect(-r*0.1,  -r*1.24, r*0.2,  r*0.18, '#ffff00');  // center eye yellow
  // Iris pupils
  pxRect(-r*0.3,  -r*1.16, r*0.08, r*0.12, '#0a0018');
  pxRect(r*0.22,  -r*1.16, r*0.08, r*0.12, '#0a0018');
  pxRect(-r*0.02, -r*1.22, r*0.06, r*0.1,  '#0a0018');

  // Massive gaping mouth
  pxRect(-r*0.55, -r*0.82, r*1.1, r*0.38, '#000');
  // Fang rows
  for (let k = 0; k < 4; k++) {
    pxRect(-r*0.48 + k*r*0.28, -r*0.82, r*0.14, r*0.22, '#e8e8f0'); // upper fangs
    pxRect(-r*0.42 + k*r*0.28, -r*0.52, r*0.14, r*0.18, '#c8c8e0'); // lower fangs
  }

  // Arms (huge, clawed)
  pxRect(-r*1.35, -r*0.2, r*0.5, r*0.9, c1);    // left upper arm
  pxRect(-r*1.45, r*0.55, r*0.45, r*0.5, c2);   // left forearm
  // Left claw fingers
  for (let k = 0; k < 3; k++) pxRect(-r*1.55 + k*r*0.14, r*0.95, r*0.1, r*0.3, c1);
  pxRect(r*0.85,  -r*0.2, r*0.5, r*0.9, c1);    // right upper arm
  pxRect(r*1.0,   r*0.55, r*0.45, r*0.5, c2);   // right forearm
  for (let k = 0; k < 3; k++) pxRect(r*1.0 + k*r*0.14, r*0.95, r*0.1, r*0.3, c1);

  // Tentacles (lower body, 4 writhing)
  const tT = T / 280;
  for (let k = 0; k < 4; k++) {
    const tx = (-r*0.6 + k * r*0.4);
    const tw = Math.sin(tT + k * 1.2) * r * 0.18;
    pxRect(tx + tw,        r*0.8,  r*0.2, r*0.5, c1);
    pxRect(tx + tw*1.5,    r*1.2,  r*0.18, r*0.4, c2);
    pxRect(tx + tw*2.0,    r*1.5,  r*0.14, r*0.3, vn);
  }

  // Aura / dark energy halo (outer ring)
  const auraA = 0.12 + Math.sin(T / 150) * 0.06;
  CTX.save();
  CTX.shadowColor = '#aa00ff'; CTX.shadowBlur = 30;
  pxRect(-r*1.05, -r*1.5, r*2.1, r*0.04, 'rgba(180,0,255,' + auraA + ')');
  CTX.restore();
}

function drawPixelBoss3Form2(r, flash) {
  // ‚îÄ‚îÄ ÁãÇ‰∫ÇÈªëÊöó ‚îÄ‚îÄ Phase 2: faster, more chaotic, cracked & enraged
  const T = Date.now();
  CTX.rotate(Math.sin(T / 70) * 0.13);   // violent shake
  const pulse = 1 + Math.sin(T / 120) * 0.08;
  CTX.scale(pulse, pulse);

  const col  = flash ? '#fff' : '#440000';
  const crak = flash ? '#eee' : '#ff2200';  // cracked energy
  const core = flash ? '#fff' : '#ff8800';  // molten core
  const yel  = flash ? '#fff' : '#ffff00';  // eye/energy
  const blk  = '#0a0000';

  // Outer chaos shard ring (6 rotating blades)
  const bT = T / 200;
  for (let i = 0; i < 6; i++) {
    const a = bT + i * Math.PI / 3;
    const bx = Math.cos(a) * r * 1.6, by = Math.sin(a) * r * 1.6;
    pxRect(bx - r*0.35, by - r*0.08, r*0.7, r*0.16, crak);   // horizontal blade
    pxRect(bx - r*0.08, by - r*0.35, r*0.16, r*0.7, crak);   // vertical blade
    pxRect(bx - r*0.15, by - r*0.15, r*0.3, r*0.3, '#ff4400');
  }

  // Cross energy beams (pulsing)
  const beamA = 0.25 + Math.sin(T / 100) * 0.2;
  pxRect(-r*1.6, -r*0.06, r*3.2, r*0.12, `rgba(255,80,0,${beamA})`);
  pxRect(-r*0.06, -r*1.6, r*0.12, r*3.2, `rgba(255,80,0,${beamA})`);
  pxRect(-r*1.15, -r*1.15, r*0.12, r*2.3, `rgba(255,200,0,${beamA*0.6})`);
  pxRect(r*1.0,   -r*1.15, r*0.12, r*2.3, `rgba(255,200,0,${beamA*0.6})`);

  // Body (shattered / fractured appearance)
  pxRect(-r*1.0, -r*0.6,  r*2.0, r*1.2,  col);
  pxRect(-r*0.6, -r*1.0,  r*1.2, r*2.0,  col);
  pxRect(-r*0.85,-r*0.85, r*1.7, r*1.7,  '#330000');
  pxRect(-r*0.6, -r*0.6,  r*1.2, r*1.2,  '#550000');
  pxRect(-r*0.42,-r*0.42, r*0.84, r*0.84, '#770000');

  // Crack lines across body
  pxRect(-r*0.7, -r*0.05, r*1.4, r*0.04, crak);
  pxRect(-r*0.05,-r*0.7,  r*0.04, r*1.4, crak);
  pxRect(-r*0.5, -r*0.4,  r*0.04, r*0.8, '#ff4400');
  pxRect(r*0.3,  -r*0.45, r*0.04, r*0.9, '#ff4400');
  pxRect(-r*0.45,-r*0.35, r*0.9, r*0.04, '#ff2200');

  // Molten core
  pxRect(-r*0.32, -r*0.32, r*0.64, r*0.64, core);
  pxRect(-r*0.2,  -r*0.2,  r*0.4,  r*0.4,  yel);
  pxRect(-r*0.08, -r*0.08, r*0.16, r*0.16, '#ffffff');

  // Rage eyes ‚Äî 5 eyes in chaotic positions
  const eyePos = [
    [-r*0.52, -r*0.62, r*0.22, r*0.2],
    [ r*0.28, -r*0.62, r*0.22, r*0.2],
    [-r*0.12, -r*0.72, r*0.22, r*0.2],
    [-r*0.65,  r*0.3,  r*0.18, r*0.16],
    [ r*0.44,  r*0.3,  r*0.18, r*0.16],
  ];
  for (const [ex, ey, ew, eh] of eyePos) {
    pxRect(ex, ey, ew, eh, blk);
    const gA2 = 0.6 + Math.sin(T / 80 + ex) * 0.4;
    CTX.save(); CTX.shadowColor = crak; CTX.shadowBlur = 8 * gA2;
    pxRect(ex + ew*0.15, ey + eh*0.15, ew*0.7, eh*0.7, yel);
    CTX.restore();
  }

  // Outer jagged spikes (8 directions)
  for (let i = 0; i < 8; i++) {
    const sa = (i / 8) * Math.PI * 2 + T / 600;
    const sx = Math.cos(sa) * r * 1.05, sy = Math.sin(sa) * r * 1.05;
    pxRect(sx - r*0.07, sy - r*0.07, r*0.14, r*0.14, crak);
    pxRect(Math.cos(sa)*(r*1.25) - r*0.05, Math.sin(sa)*(r*1.25) - r*0.05, r*0.1, r*0.1, '#ff8800');
  }

  // Enrage aura
  CTX.save();
  CTX.shadowColor = '#ff2200'; CTX.shadowBlur = 24;
  pxRect(-r*1.0, -r*0.02, r*2.0, r*0.04, `rgba(255,60,0,0.3)`);
  CTX.restore();
}

function drawPixelPlayer(r, facing) {
  CTX.fillStyle = 'rgba(0,0,0,0.35)'; CTX.beginPath(); CTX.ellipse(0, r*0.85, r*0.8, r*0.22, 0, 0, PI2); CTX.fill();
  if (facing === -1) CTX.scale(-1, 1);
  pxRect(-r*0.58, r*0.52, r*0.46, r*0.42, '#2a1a08'); pxRect(r*0.12, r*0.52, r*0.46, r*0.42, '#2a1a08');
  pxRect(-r*0.58, r*0.52, r*0.46, r*0.1, '#3a2a18'); pxRect(r*0.12, r*0.52, r*0.46, r*0.1, '#3a2a18');
  pxRect(-r*0.52, r*0.08, r*0.42, r*0.5, '#1a2232'); pxRect(r*0.10, r*0.08, r*0.42, r*0.5, '#1a2232');
  pxRect(-r*0.58, -r*0.5, r*1.16, r*0.62, '#221428'); pxRect(-r*0.58, -r*0.5, r*0.14, r*0.62, '#301c38');
  pxRect(-r*0.14, -r*0.5, r*0.28, r*0.28, '#120c18');
  pxRect(-r*0.58, r*0.07, r*1.16, r*0.1, '#110a06'); pxRect(-r*0.1, r*0.07, r*0.2, r*0.1, '#b89010');
  pxRect(-r*0.82, -r*0.4, r*0.26, r*0.58, '#1e1224'); pxRect(-r*0.7, r*0.16, r*0.22, r*0.22, '#c07050');
  const armBob = Math.sin(Date.now() / 200) * r * 0.05;
  pxRect(r*0.54, -r*0.38 + armBob, r*0.28, r*0.54, '#221428'); pxRect(r*0.62, r*0.16 + armBob, r*0.22, r*0.22, '#c07050');
  pxRect(-r*0.14, -r*0.6, r*0.28, r*0.14, '#c07050');
  pxRect(-r*0.42, -r*0.92, r*0.84, r*0.9, '#c89060'); pxRect(-r*0.38, -r*0.68, r*0.76, r*0.14, 'rgba(80,50,25,0.3)');
  pxRect(-r*0.78, -r*1.0, r*1.56, r*0.14, '#141010');
  pxRect(-r*0.44, -r*1.5, r*0.88, r*0.52, '#1c1414'); pxRect(-r*0.42, -r*1.48, r*0.84, r*0.5, '#201818');
  pxRect(-r*0.44, -r*1.08, r*0.88, r*0.1, '#7a1800');
  pxRect(r*0.06, -r*0.78, r*0.24, r*0.2, '#f0e0c8'); pxRect(r*0.12, -r*0.77, r*0.14, r*0.16, '#285a80');
  pxRect(r*0.14, -r*0.76, r*0.08, r*0.1, '#080600'); pxRect(r*0.2, -r*0.79, r*0.05, r*0.05, '#fff');
  pxRect(r*0.04, -r*0.88, r*0.28, r*0.08, '#4a2c10'); pxRect(r*0.06, -r*0.62, r*0.26, r*0.06, '#8a5030');
}

// ====== MAIN UPDATE ======
function update(dt) {
  if (game.state !== 'playing') return;
  game.time += dt;
  if (game.shakeTimer > 0) game.shakeTimer -= dt;

  const dir = getInputDir();
  if (dir.x !== 0) player.facing = dir.x > 0 ? 1 : -1;
  const effSpeed = playerEffSpeed();
  player.x += dir.x * effSpeed * dt; player.y += dir.y * effSpeed * dt;
  cam.x = lerp(cam.x, player.x, 5 * dt); cam.y = lerp(cam.y, player.y, 5 * dt);
  if (player.iFrames > 0) player.iFrames -= dt;

  for (const w of player.weapons) {
    const def = WEAPON_DEFS[w.type];
    def.fire(w, dt); if (def.update) def.update(w, dt);
  }

  waveSystem.update(dt);
  bossExplosion.update(dt);
  const qt = new QuadTree(cam.x - 1500, cam.y - 1500, 3000, 3000);
  enemies.each(e => qt.insert(e));

  bullets.each(b => {
    if (b.type === 'bible') return;
    b.timer -= dt; if (b.timer <= 0) { b.active = false; return; }
    b.x += b.vx * dt; b.y += b.vy * dt;
    if (b.gravity) b.vy += b.gravity * dt;
    if (b.type === 'axe' && b.spin) b._angle = (b._angle || 0) + b.spin * dt;

    if (b.type === 'melee') {
      const candidates = qt.query(b.mx, b.my, b.mw, b.mh, []);
      for (const e of candidates) {
        if (b.hitSet.has(e)) continue;
        if (rectOverlap(b.mx, b.my, b.mw, b.mh, e.x - e.r, e.y - e.r, e.r * 2, e.r * 2)) {
          b.hitSet.add(e); damageEnemy(e, b.dmg);
        }
      }
    } else {
      const candidates = qt.query(b.x - b.r, b.y - b.r, b.r * 2, b.r * 2, []);
      for (const e of candidates) {
        if (b.hitSet.has(e)) continue;
        if (circleOverlap(b.x, b.y, b.r, e.x, e.y, e.r)) {
          b.hitSet.add(e); damageEnemy(e, b.dmg);
          if (b.type !== 'lightning') { b.pierce--; if (b.pierce <= 0) { b.active = false; return; } }
        }
      }
    }
    if (!onScreen(b.x, b.y, 250)) b.active = false;
  });

  bullets.each(b => {
    if (b.type !== 'bible' || !b.active) return;
    const candidates = qt.query(b.x - b.r, b.y - b.r, b.r * 2, b.r * 2, []);
    for (const e of candidates) {
      if (b.hitSet.has(e)) continue;
      if (circleOverlap(b.x, b.y, b.r, e.x, e.y, e.r)) {
        b.hitSet.add(e); damageEnemy(e, b.dmg);
        const a = angleTo(player, e); e.kbx += Math.cos(a) * 80 * e.knockback; e.kby += Math.sin(a) * 80 * e.knockback;
      }
    }
  });

  enemies.each(e => {
    const a = angleTo(e, player); e.x += Math.cos(a) * e.speed * dt; e.y += Math.sin(a) * e.speed * dt;
    if (Math.abs(e.kbx) > 0.1 || Math.abs(e.kby) > 0.1) { e.x += e.kbx * dt * 5; e.y += e.kby * dt * 5; e.kbx *= 0.9; e.kby *= 0.9; }
    e.hitTimer -= dt; e.flashTimer -= dt;

    if (player.iFrames <= 0 && !player.invincible && circleOverlap(player.x, player.y, player.r, e.x, e.y, e.r)) {
      const dmgTaken = e.dmg * (1 - (player.armor || 0)); player.hp -= dmgTaken; player.iFrames = 0.5;
      spawnDmgText(player.x, player.y, Math.round(dmgTaken), '#f44'); game.shake(5, 0.15);
      const pa = angleTo(e, player); player.x += Math.cos(pa) * 30; player.y += Math.sin(pa) * 30;
      if (player.hp <= 0) {
        player.hp = 0; player.alive = false;
        game.state = (game.stage >= 2) ? 'gameover2' : 'gameover';
      }
    }
    if (dist(player, e) > 1600) e.active = false;
  });

  pickups.each(p => {
    const d = dist(player, p);
    if (d < player.magnet * 3) {
      const a = angleTo(p, player); const pullSpeed = 300 * (1 - d / (player.magnet * 3));
      p.x += Math.cos(a) * pullSpeed * dt; p.y += Math.sin(a) * pullSpeed * dt;
    }
    if (d < player.magnet) {
      p.active = false;
      if (p.type === 'gem') addXP(p.value);
      else if (p.type === 'chest') openChest();
      else if (p.type === 'heal') { player.hp = Math.min(player.hp + p.value, player.maxHp); spawnDmgText(player.x, player.y, '+' + p.value, '#0f0'); }
      else if (p.type === 'weaponChest') openWeaponChest();
      else if (p.type === 'passiveChest') openPassiveChest();
      else if (p.type === 'itemChest') openItemChest();
    }
  });

  dmgTexts.each(t => { t.timer -= dt; t.y -= 40 * dt; if (t.timer <= 0) t.active = false; });
  updateActiveEffects(dt);
}

function damageEnemy(e, dmg) {
  const crit = Math.random() < (player.critChance || 0);
  const defMult = player.defenseBreak ? 1.5 : 1.0;
  let finalDmg = (crit ? dmg * 2 : dmg) * (player.mightMult || 1) * defMult;

  // Boss 3 form 2 has damage reduction
  if (e.type === 'boss3_form2') finalDmg *= 0.7;

  e.hp -= finalDmg; e.flashTimer = 0.1;
  spawnDmgText(e.x, e.y, (crit ? '‚òÖ' : '') + Math.round(finalDmg), crit ? '#ffee00' : '#ff0');
  const a = angleTo(player, e); e.kbx += Math.cos(a) * 40 * e.knockback; e.kby += Math.sin(a) * 40 * e.knockback;

  // Boss 3 Stage 2 transformation
  if (e.type === 'boss3' && e.hp <= e.maxHp * 0.1) {
    e.type = 'boss3_form2';
    // Use ENEMY_DEFS hp so 3√ó multiplier applies correctly
    e.hp   = ENEMY_DEFS['boss3_form2'].hp;
    e.maxHp = e.hp;
    e.speed = ENEMY_DEFS['boss3_form2'].speed;
    e.dmg   = ENEMY_DEFS['boss3_form2'].dmg;
    e.r     = ENEMY_DEFS['boss3_form2'].r;
    spawnDmgText(e.x, e.y - 80, '‚ö† ÁµÇÊ•µË¶∫ÈÜíÔºÅÁãÇ‰∫ÇÊ®°ÂºèÔºÅ', '#ff0000');
    game.shake(20, 1.0);
  }

  if (e.hp <= 0) {
    e.active = false; player.kills++;
    if (e.xp >= 100) spawnGem(e.x, e.y, 100); else if (e.xp >= 10) spawnGem(e.x, e.y, 10); else spawnGem(e.x, e.y, 1);
    if (e.type === 'boss' || e.type === 'boss2' || e.type.startsWith('boss3')) spawnChest(e.x, e.y);
    if (Math.random() < 0.02) spawnHeal(e.x, e.y);
    
    // Victory for Boss 3 ‚Äî trigger cinematic explosion first
    if (e.type === 'boss3_form2') {
      enemies.items.forEach(en => en.active = false); // clear all enemies
      bossExplosion.start(e.x, e.y);   // explosion handles state transition to victory3
      game.shake(50, 3.0);             // massive screen shake
      spawnDmgText(e.x, e.y - 60, '‚ò† ÁµÇÊ•µÈªëÊöóÊ∂àÊªÖÔºÅ', '#ffd700');
    }
  }
}

// ====== RENDER ======
function render() {
  _uiButtons.length = 0; CTX.imageSmoothingEnabled = false; CTX.save();

  let sx = 0, sy = 0;
  if (game.shakeTimer > 0) {
    sx = Math.round(rand(-game.shakeIntensity, game.shakeIntensity));
    sy = Math.round(rand(-game.shakeIntensity, game.shakeIntensity));
    CTX.translate(sx, sy);
  }

  drawGround();

  pickups.each(p => {
    if (!onScreen(p.x, p.y)) return;
    const s = toScreen(p.x, p.y);
    if (p.type === 'gem') {
      const gc = GEM_COLORS[p.value] || '#4466ff';
      pxRect(s.x - p.r * 0.6, s.y - p.r, p.r * 1.2, p.r * 0.9, gc); pxRect(s.x - p.r * 0.9, s.y - p.r * 0.15, p.r * 1.8, p.r * 0.5, gc);
      pxRect(s.x - p.r * 0.6, s.y + p.r * 0.32, p.r * 1.2, p.r * 0.6, gc + 'aa'); pxRect(s.x - p.r * 0.3, s.y - p.r * 0.85, p.r * 0.5, p.r * 0.4, 'rgba(255,255,255,0.5)');
    } else if (p.type === 'chest') {
      pxRect(s.x - 18, s.y - 12, 36, 24, '#c8880a'); pxRect(s.x - 18, s.y - 12, 36, 7, '#8a5800');
      pxRect(s.x - 4, s.y - 4, 8, 8, '#ffe000'); pxRectOutline(s.x - 18, s.y - 12, 36, 24, '#ffa000', 2);
    } else if (p.type === 'heal') {
      pxRect(s.x - 3, s.y - 9, 6, 18, '#00ee44'); pxRect(s.x - 9, s.y - 3, 18, 6, '#00ee44');
    } else if (p.type === 'weaponChest') {
      const bob2 = Math.sin(Date.now() / 300 + p.x) * 2;
      pxRect(s.x - 17, s.y - 14 + bob2, 34, 22, '#8a5800'); pxRect(s.x - 17, s.y - 14 + bob2, 34, 7, '#6a3e00'); pxRectOutline(s.x - 17, s.y - 14 + bob2, 34, 22, '#ffd700', 2);
      pxRect(s.x - 3, s.y - 9 + bob2, 6, 6, '#ffd700');
      CTX.save(); CTX.fillStyle = '#ffd700'; CTX.font = 'bold 9px "Cinzel",serif'; CTX.textAlign = 'center'; CTX.fillText('‚öî', s.x, s.y - 17 + bob2); CTX.restore();
    } else if (p.type === 'passiveChest') {
      const bob3 = Math.sin(Date.now() / 350 + p.y) * 2;
      pxRect(s.x - 17, s.y - 14 + bob3, 34, 22, '#1a5800'); pxRect(s.x - 17, s.y - 14 + bob3, 34, 7, '#0e3800'); pxRectOutline(s.x - 17, s.y - 14 + bob3, 34, 22, '#44ff88', 2);
      pxRect(s.x - 3, s.y - 9 + bob3, 6, 6, '#44ff88');
      CTX.save(); CTX.fillStyle = '#44ff88'; CTX.font = 'bold 9px "Cinzel",serif'; CTX.textAlign = 'center'; CTX.fillText('‚ú¶', s.x, s.y - 17 + bob3); CTX.restore();
    } else if (p.type === 'itemChest') {
      const bob4 = Math.sin(Date.now() / 280 + p.x * 0.01) * 3; const gA = 0.35 + Math.sin(Date.now() / 200) * 0.25;
      CTX.save(); CTX.shadowColor = '#44ddff'; CTX.shadowBlur = 10 + 8 * gA;
      pxRect(s.x - 17, s.y - 14 + bob4, 34, 22, '#001840'); pxRect(s.x - 17, s.y - 14 + bob4, 34, 7, '#000e28'); pxRectOutline(s.x - 17, s.y - 14 + bob4, 34, 22, '#44ddff', 2);
      pxRect(s.x - 3, s.y - 9 + bob4, 6, 6, '#44ddff'); CTX.fillStyle = '#44ddff'; CTX.font = 'bold 10px serif'; CTX.textAlign = 'center'; CTX.fillText('üéÅ', s.x, s.y - 15 + bob4); CTX.restore();
    }
  });

  enemies.each(e => {
    if (!onScreen(e.x, e.y)) return;
    const s = toScreen(e.x, e.y); const flash = e.flashTimer > 0;
    CTX.save(); CTX.translate(s.x, s.y);
    if (e.type === 'bat') drawPixelBat(e.r, flash); else if (e.type === 'skeleton') drawPixelSkeleton(e.r, flash);
    else if (e.type === 'ghost') drawPixelGhost(e.r, flash); else if (e.type === 'zombie') drawPixelZombie(e.r, flash);
    else if (e.type === 'boss') drawPixelBoss(e.r, flash); else if (e.type === 'reaper') drawPixelReaper(e.r, flash);
    else if (e.type === 'darkbat') drawPixelDarkBat(e.r, flash); else if (e.type === 'lich') drawPixelLich(e.r, flash);
    else if (e.type === 'gargoyle') drawPixelGargoyle(e.r, flash); else if (e.type === 'boss2') drawPixelBoss2(e.r, flash);
    else if (e.type === 'boss3') drawPixelBoss3(e.r, flash); else if (e.type === 'boss3_form2') drawPixelBoss3Form2(e.r, flash);
    else pxRect(-e.r, -e.r, e.r * 2, e.r * 2, flash ? '#fff' : e.color);
    CTX.restore();

    if (e.type === 'boss' || e.type === 'boss2' || e.type === 'reaper' || e.type.startsWith('boss3')) {
      const ss = toScreen(e.x, e.y); const bw = e.r * 3.2;
      pxRect(ss.x - bw/2 - 2, ss.y - e.r * 2 - 12, bw + 4, 12, 'rgba(0,0,0,0.8)'); pxRect(ss.x - bw/2, ss.y - e.r * 2 - 10, bw, 8, '#300');
      let hpCol = '#ff4400';
      if (e.type === 'reaper') hpCol = '#cc00ff'; else if (e.type === 'boss2') hpCol = '#ff0066'; else if (e.type.startsWith('boss3')) hpCol = '#aa00ff';
      if (e.type === 'boss3_form2') hpCol = '#ff0000';
      pxRect(ss.x - bw/2, ss.y - e.r * 2 - 10, bw * Math.max(0, e.hp / e.maxHp), 8, hpCol);
      CTX.fillStyle = 'rgba(255,255,255,0.8)'; CTX.font = 'bold 10px "Cinzel", serif'; CTX.textAlign = 'center';
      const labels = { 'boss2': '‚ò† ÈªëÊöóÊÉ°È≠îÁéã', 'boss': '‚ö† ÊÉ°È≠îÁéã', 'reaper': '‚ò† Ê≠ªÁ•û', 'boss3': 'üëÅ ÁµÇÊ•µÈªëÊöó', 'boss3_form2': 'üëÅ ÁãÇ‰∫ÇÈªëÊöó' };
      CTX.fillText(labels[e.type] || '', ss.x, ss.y - e.r * 2 - 13);
    }
  });

  bullets.each(b => {
    if (!onScreen(b.x, b.y)) return;
    const s = toScreen(b.x, b.y); CTX.save();
    if (b.type === 'melee') {
      const ms = toScreen(b.mx + b.mw / 2, b.my + b.mh / 2); CTX.globalAlpha = 0.55; pxRect(ms.x - b.mw/2, ms.y - b.mh/2, b.mw, b.mh, '#ffff88'); CTX.globalAlpha = 1;
    } else if (b.type === 'axe') {
      CTX.translate(s.x, s.y); CTX.rotate(b._angle || 0); CTX.font = Math.max(20, b.r * 2.5) + 'px serif'; CTX.textAlign = 'center'; CTX.textBaseline = 'middle'; CTX.fillText('ü™ì', 0, 0);
    } else if (b.type === 'bible') {
      CTX.translate(s.x, s.y); CTX.font = Math.max(18, b.r * 2.2) + 'px serif'; CTX.textAlign = 'center'; CTX.textBaseline = 'middle'; CTX.fillText('üìñ', 0, 0);
    } else if (b.type === 'fireball') {
      CTX.translate(s.x, s.y); CTX.shadowColor = '#ff6600'; CTX.shadowBlur = 16; CTX.font = Math.max(18, b.r * 2.5) + 'px serif'; CTX.textAlign = 'center'; CTX.textBaseline = 'middle'; CTX.fillText('üî•', 0, 0);
    } else if (b.type === 'lightning') {
      if (b.lx2 !== undefined) {
        const s2 = toScreen(b.lx2, b.ly2); CTX.strokeStyle = '#ccffff'; CTX.lineWidth = 4; CTX.globalAlpha = 0.9; CTX.shadowColor = '#44ffff'; CTX.shadowBlur = 12;
        CTX.beginPath(); CTX.moveTo(s.x, s.y); CTX.lineTo(s2.x, s2.y); CTX.stroke(); CTX.shadowBlur = 0; CTX.globalAlpha = 1;
      }
    } else if (b.type === 'cross') {
      pxRect(s.x - 2, s.y - b.r * 1.2, 4, b.r * 2.4, '#ffffcc'); pxRect(s.x - b.r * 0.8, s.y - 2, b.r * 1.6, 4, '#ffffcc');
    } else if (b.type === 'shadow') {
      CTX.globalAlpha = 0.85; pxRect(s.x - b.r, s.y - b.r, b.r * 2, b.r * 2, '#aa44ff'); pxRect(s.x - b.r + 2, s.y - b.r + 2, b.r * 2 - 4, b.r * 2 - 4, '#cc88ff');
    } else {
      pxRect(s.x - b.r, s.y - b.r, b.r * 2, b.r * 2, b.color); pxRect(s.x - b.r + 2, s.y - b.r + 2, b.r * 2 - 4, b.r * 2 - 4, '#ddeeff');
    }
    CTX.restore();
  });

  if (player.alive) {
    const ps = toScreen(player.x, player.y); const blink = player.iFrames > 0 && Math.floor(player.iFrames * 14) % 2 === 0;
    if (!blink) {
      CTX.save(); CTX.translate(ps.x, ps.y); drawPixelPlayer(player.r, player.facing);
      if (player.hp / player.maxHp < 0.3) {
        const pulseA = 0.3 + Math.sin(Date.now() / 120) * 0.3; CTX.strokeStyle = 'rgba(255,0,0,' + pulseA + ')'; CTX.lineWidth = 3;
        CTX.strokeRect(-player.r - 4, -player.r * 1.4, (player.r + 4) * 2, player.r * 2.6);
      }
      CTX.restore();
    }
  }

  dmgTexts.each(t => {
    if (!onScreen(t.x, t.y)) return;
    const s = toScreen(t.x, t.y); CTX.save(); CTX.font = 'bold 13px "Cinzel", serif'; CTX.fillStyle = t.color;
    CTX.shadowColor = t.color; CTX.shadowBlur = 5; CTX.globalAlpha = clamp(t.timer / 0.3, 0, 1); CTX.textAlign = 'center';
    CTX.fillText(t.text, s.x, s.y); CTX.globalAlpha = 1; CTX.restore();
  });

  // Boss explosion (world-space particles + screen effects)
  CTX.restore();
  bossExplosion.render();

  if (game.state === 'playing' || game.state === 'levelup' || bossExplosion.active) drawHUD();
  if (game.state === 'title') drawTitle();
  if (game.state === 'weaponSelect') drawWeaponSelect();
  if (game.state === 'stage3Select') drawStage3Select();
  if (game.state === 'levelup') drawLevelUp();
  if (game.state === 'gameover') drawGameOver();
  if (game.state === 'gameover2') drawGameOver2();
  if (game.state === 'victory') drawVictory();
  if (game.state === 'victory3') drawVictory3();

  if (touchActive && game.state === 'playing') {
    CTX.globalAlpha = 0.28; CTX.strokeStyle = '#fff'; CTX.lineWidth = 2;
    CTX.beginPath(); CTX.arc(touchStartX, touchStartY, 50, 0, PI2); CTX.stroke();
    CTX.beginPath(); CTX.arc(touchStartX + touchDX, touchStartY + touchDY, 20, 0, PI2); CTX.fillStyle = '#fff'; CTX.fill();
    CTX.globalAlpha = 1;
  }
}

// ====== HUD ======
function drawHUD() {
  const isMobile = W < 600;
  const barW = W * (isMobile ? 0.5 : 0.55), barH = isMobile ? 10 : 14; const barX = (W - barW) / 2, barY = 8;
  const xpRatio = player.xp / player.xpToNext;
  pxRect(barX - 2, barY - 2, barW + 4, barH + 4, 'rgba(0,0,0,0.7)'); pxRect(barX, barY, barW, barH, '#1a0a2e');
  if (xpRatio > 0) { pxRect(barX, barY, barW * xpRatio, barH, '#9b5de5'); pxRect(barX, barY, barW * xpRatio, barH / 2, 'rgba(200,150,255,0.25)'); }
  pxRectOutline(barX, barY, barW, barH, 'rgba(180,100,255,0.6)', 1);
  CTX.save(); CTX.shadowColor = '#b060ff'; CTX.shadowBlur = 6; CTX.fillStyle = '#e8d4ff'; CTX.font = `bold ${isMobile ? 9 : 11}px "Cinzel", serif`;
  CTX.textAlign = 'center';
  const stgLabel = game.stage === 3 ? ' ‚òÖÊúÄÁµÇÈóú' : (game.stage === 2 ? ' ‚òÖÁ¨¨‰∫åÈóú' : '');
  CTX.fillText('LV ' + player.level + stgLabel, W / 2, barY + barH - 1); CTX.restore();

  const hpW = isMobile ? Math.min(110, W * 0.28) : 140, hpH = isMobile ? 10 : 14; const hpX = 8, hpY = barY + barH + 6;
  const hpRatio = player.hp / player.maxHp;
  pxRect(hpX - 2, hpY - 2, hpW + 4, hpH + 4, 'rgba(0,0,0,0.7)'); pxRect(hpX, hpY, hpW, hpH, '#1a0005');
  if (hpRatio > 0) { const hpCol = hpRatio > 0.5 ? '#e8102a' : hpRatio > 0.25 ? '#ff6600' : '#ff0000'; pxRect(hpX, hpY, hpW * hpRatio, hpH, hpCol); }
  pxRectOutline(hpX, hpY, hpW, hpH, 'rgba(200,50,70,0.7)', 1);
  CTX.save(); CTX.fillStyle = '#ffccd5'; CTX.font = `bold ${isMobile ? 8 : 10}px "Cinzel", serif`; CTX.textAlign = 'left';
  CTX.fillText('‚ù§ ' + Math.ceil(player.hp) + '/' + Math.ceil(player.maxHp), hpX + 2, hpY + hpH - 1); CTX.restore();

  const mins = Math.floor(game.time / 60), secs = Math.floor(game.time % 60);
  const timeStr = String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
  CTX.save(); CTX.shadowColor = '#e8b84b'; CTX.shadowBlur = 8; CTX.font = `bold ${isMobile ? 14 : 18}px "Cinzel", serif`;
  CTX.textAlign = 'right'; CTX.fillStyle = '#ffe066'; CTX.fillText('‚è± ' + timeStr, W - 8, barY + barH + 2);
  CTX.shadowBlur = 4; CTX.font = `${isMobile ? 10 : 12}px "Cinzel", serif`; CTX.fillStyle = '#e8c87a';
  CTX.fillText('‚ò† ' + player.kills, W - 8, barY + barH + (isMobile ? 16 : 20)); CTX.restore();

  const slotSize = isMobile ? 36 : 44, slotPad = isMobile ? 4 : 6; const bottomY = H - slotSize - 8; let wx = 8;
  for (const w of player.weapons) {
    const def = WEAPON_DEFS[w.type]; pxRect(wx, bottomY, slotSize, slotSize, 'rgba(0,0,0,0.75)'); pxRectOutline(wx, bottomY, slotSize, slotSize, 'rgba(100,60,200,0.8)', 2);
    CTX.font = `${isMobile ? 18 : 22}px serif`; CTX.textAlign = 'center'; CTX.fillText(def.icon, wx + slotSize / 2, bottomY + slotSize * 0.68);
    pxRect(wx + slotSize - 12, bottomY - 1, 12, 10, '#9b5de5'); CTX.fillStyle = '#fff'; CTX.font = `bold ${isMobile ? 8 : 9}px "Cinzel", serif`; CTX.fillText(w.level, wx + slotSize - 6, bottomY + 8); wx += slotSize + slotPad;
  }
  let ppx = W - slotSize - 8;
  for (const p of player.passives) {
    const def = PASSIVE_DEFS[p.type]; pxRect(ppx, bottomY, slotSize, slotSize, 'rgba(0,0,0,0.75)'); pxRectOutline(ppx, bottomY, slotSize, slotSize, 'rgba(40,160,80,0.8)', 2);
    CTX.font = `${isMobile ? 18 : 22}px serif`; CTX.textAlign = 'center'; CTX.fillText(def.icon, ppx + slotSize / 2, bottomY + slotSize * 0.68);
    pxRect(ppx + slotSize - 12, bottomY - 1, 12, 10, '#2ecc71'); CTX.fillStyle = '#fff'; CTX.font = `bold ${isMobile ? 8 : 9}px "Cinzel", serif`; CTX.fillText(p.level, ppx + slotSize - 6, bottomY + 8); ppx -= slotSize + slotPad;
  }

  if (activeEffects.length > 0 && game.stage >= 2) {
    const efW = isMobile ? 90 : 120, efH = isMobile ? 14 : 18; const efX = W / 2 - (activeEffects.length * (efW + 4)) / 2, efY = bottomY - efH - 6;
    for (let i = 0; i < activeEffects.length; i++) {
      const ef = activeEffects[i], x = efX + i * (efW + 4), ratio = ef.timer / ef.duration;
      const cols = { mightBoost: '#ff6600', defenseBreak: '#ff88ff', invincible: '#44ddff' }; const col = cols[ef.type] || '#ffff00';
      const labels = { mightBoost: '‚öî√ó2', defenseBreak: 'üí•Èò≤Á¢é', invincible: 'üõ°ÁÑ°Êïµ' };
      pxRect(x, efY, efW, efH, 'rgba(0,0,0,0.7)'); pxRect(x, efY, efW * ratio, efH, col + '99'); pxRectOutline(x, efY, efW, efH, col, 1);
      CTX.save(); CTX.fillStyle = '#fff'; CTX.font = `bold ${isMobile ? 8 : 10}px "Cinzel",serif`; CTX.textAlign = 'center'; CTX.fillText((labels[ef.type] || ef.type) + ' ' + Math.ceil(ef.timer) + 's', x + efW / 2, efY + efH - 2); CTX.restore();
    }
  }
}

// ====== TITLE SCREEN ======
function drawTitle() {
  CTX.fillStyle = 'rgba(0,0,0,0.94)'; CTX.fillRect(0, 0, W, H);
  const moonGrad = CTX.createRadialGradient(W/2, H/2 - 80, 0, W/2, H/2 - 80, 350);
  moonGrad.addColorStop(0, 'rgba(180,10,30,0.22)'); moonGrad.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = moonGrad; CTX.fillRect(0, 0, W, H); CTX.textAlign = 'center';

  const titleSize = Math.min(52, rw(52));
  CTX.save(); CTX.shadowColor = '#c0102a'; CTX.shadowBlur = 38; CTX.fillStyle = '#ff2040'; CTX.font = `bold ${titleSize}px "Cinzel Decorative", serif`; CTX.fillText('ÁçµÈ≠îÂÄñÂ≠òËÄÖ', W/2, H/2 - rh(65)); CTX.restore();
  CTX.save(); CTX.shadowColor = '#e8b84b'; CTX.shadowBlur = 10; CTX.fillStyle = '#e8b84b'; CTX.font = `600 ${Math.min(18, rw(18))}px "Cinzel", serif`; CTX.fillText('DEMON HUNTER SURVIVORS', W/2, H/2 - rh(22)); CTX.restore();

  const bx8 = W/2 - 42, by8 = H/2 - rh(14);
  pxRect(bx8, by8, 84, 20, '#220044'); pxRectOutline(bx8, by8, 84, 20, '#aa44ff', 2);
  CTX.fillStyle = '#cc88ff'; CTX.font = 'bold 11px "Cinzel", serif'; CTX.fillText('[ 8‰ΩçÂÖÉÂÉèÁ¥†Áâà ]', W/2, by8 + 14);

  CTX.fillStyle = 'rgba(200,180,220,0.6)'; CTX.font = `${Math.min(12, rw(12))}px "Cinzel", serif`; CTX.fillText('WASD / ÊñπÂêëÈçµ ÁßªÂãï  ¬∑  Ëá™ÂãïÊîªÊìä', W/2, H/2 + rh(36));

  const bw = Math.min(200, rw(200)), bh = Math.min(50, rh(50)); const bx = W/2 - bw/2, by = H/2 + rh(62);
  pxRect(bx, by, bw, bh, '#6a000f'); pxRect(bx + 4, by + 4, bw - 8, bh - 8, '#c0102a'); pxRectOutline(bx, by, bw, bh, '#e8b84b', 2);
  CTX.save(); CTX.shadowColor = '#ffe066'; CTX.shadowBlur = 8; CTX.fillStyle = '#ffe066'; CTX.font = `bold ${Math.min(19, rw(19))}px "Cinzel", serif`; CTX.fillText('‚öî  ÈñãÂßãÈÅäÊà≤  ‚öî', W/2, by + bh * 0.65); CTX.restore();
  registerBtn(bx, by, bw, bh, 'title', () => game.start());
  if (!drawTitle._keyBound) { drawTitle._keyBound = true; window.addEventListener('keydown', function _tk(ev) { if (game.state === 'title') { game.start(); window.removeEventListener('keydown', _tk); drawTitle._keyBound = false; } }); }
}

const WEAPON_SELECT_OPTIONS_S1 = [
  { type: 'whip',     label: 'ÁöÆÈû≠',  subtitle: 'Whip',       desc: 'ËøëË∑ùÂ§ßÁØÑÂúçÊèÆÁ†ç',   color: '#c8a020', border: '#ffd040',
    howto: 'Ëá™ÂãïÂêëÂâçÊñπÊâáÂΩ¢ÊèÆÁ†çÔºåÁØÑÂúçÂª£ÂÇ∑ÂÆ≥Á©©ÂÆö', stats: 'ÂÇ∑ÂÆ≥:10 | ÂÜ∑Âçª:1.5s | Á©øÈÄè:‚àû' },
  { type: 'wand',     label: 'È≠îÊùñ',  subtitle: 'Magic Wand', desc: 'ÈéñÂÆöÊúÄËøëÊïµ‰∫∫',     color: '#4488ff', border: '#88aaff',
    howto: 'Ëá™ÂãïÁûÑÊ∫ñÊúÄËøëÊïµ‰∫∫Â∞ÑÂá∫È≠îÊ≥ïÂΩàÔºåÂ§öÁ¥öÂçáÂèØÂ§öÁôº', stats: 'ÂÇ∑ÂÆ≥:15 | ÂÜ∑Âçª:1.0s | Á©øÈÄè:1' },
  { type: 'axe',      label: 'È£õÊñß',  subtitle: 'Axe',        desc: 'ÊããÁâ©Á∑öÈ´òÂÇ∑ÂÆ≥Á©øÈÄè', color: '#cc5500', border: '#ff8822',
    howto: 'Âêë‰∏äÊããÂá∫È£õÊñßÔºåÂèóÈáçÂäõÂΩ±ÈüøÂºßÁ∑öÈ£õË°åÔºåÂèØÁ©øÈÄèÂ§öÊïµ', stats: 'ÂÇ∑ÂÆ≥:20 | ÂÜ∑Âçª:1.5s | Á©øÈÄè:2' },
  { type: 'bible',    label: 'ËÅñÁ∂ì',  subtitle: 'King Bible', desc: 'ÁπûË∫´ÊóãËΩâË≠∑Áõæ',     color: '#8844ff', border: '#bb88ff',
    howto: 'Âè¨ÂñöËÅñÁ∂ìÁπûÁé©ÂÆ∂ÊóãËΩâÔºåÊåÅÁ∫åÁ¢∞Ëß∏ÂÇ∑ÂÆ≥ÔºåÂçáÁ¥öÂ¢ûÂä†Êï∏Èáè', stats: 'ÂÇ∑ÂÆ≥:5/hit | ÊåÅÁ∫å:3s | ÂàùÂßã:1Êú¨' },
  { type: 'firewand', label: 'ÁÅ´ÁêÉ',  subtitle: 'Fire Wand',  desc: 'Èö®Ê©üÈéñÂÆöÁÅ´ÁêÉ',     color: '#ff3300', border: '#ff6644',
    howto: 'Èö®Ê©üÈéñÂÆöÁØÑÂúçÂÖßÊïµ‰∫∫Â∞ÑÂá∫ÁÅ´ÁêÉÔºåÂ∞ÑÈÄüÂø´', stats: 'ÂÇ∑ÂÆ≥:30 | ÂÜ∑Âçª:1.2s | Á©øÈÄè:1' },
];
const WEAPON_SELECT_OPTIONS_S2 = [
  { type: 'whip',     label: 'ÁöÆÈû≠',  subtitle: 'Whip',         desc: 'ËøëË∑ùÂ§ßÁØÑÂúçÊèÆÁ†ç', color: '#c8a020', border: '#ffd040',
    howto: 'Ëá™ÂãïÂêëÂâçÊñπÊâáÂΩ¢ÊèÆÁ†çÔºåÁØÑÂúçÂª£ÂÇ∑ÂÆ≥Á©©ÂÆö', stats: 'ÂÇ∑ÂÆ≥:10 | ÂÜ∑Âçª:1.5s | Á©øÈÄè:‚àû' },
  { type: 'wand',     label: 'È≠îÊùñ',  subtitle: 'Magic Wand',   desc: 'ÈéñÂÆöÊúÄËøëÊïµ‰∫∫',   color: '#4488ff', border: '#88aaff',
    howto: 'Ëá™ÂãïÁûÑÊ∫ñÊúÄËøëÊïµ‰∫∫Â∞ÑÂá∫È≠îÊ≥ïÂΩàÔºåÂ§öÁ¥öÂçáÂèØÂ§öÁôº', stats: 'ÂÇ∑ÂÆ≥:15 | ÂÜ∑Âçª:1.0s | Á©øÈÄè:1' },
  { type: 'firewand', label: 'ÁÅ´ÁêÉ',  subtitle: 'Fire Wand',    desc: 'Èö®Ê©üÈéñÂÆöÁÅ´ÁêÉ',   color: '#ff3300', border: '#ff6644',
    howto: 'Èö®Ê©üÈéñÂÆöÁØÑÂúçÂÖßÊïµ‰∫∫Â∞ÑÂá∫ÁÅ´ÁêÉÔºåÂ∞ÑÈÄüÂø´', stats: 'ÂÇ∑ÂÆ≥:30 | ÂÜ∑Âçª:1.2s | Á©øÈÄè:1' },
  { type: 'lightning',label: 'ÈñÉÈõª',  subtitle: 'Lightning',    desc: 'ÈÄ£ÈéñÈõªÊìäÊïµ‰∫∫',   color: '#44ddff', border: '#aaeeff',
    howto: 'ÊâìÊìäÊúÄËøëÊïµ‰∫∫‰∏¶ÈÄ£ÈéñË∑≥Ë∫çËá≥ÈôÑËøëÂÖ∂‰ªñÊïµ‰∫∫', stats: 'ÂÇ∑ÂÆ≥:40 | ÂÜ∑Âçª:1.8s | ÈÄ£Èéñ:2' },
  { type: 'cross',    label: 'ÂçÅÂ≠óÊû∂',subtitle: 'Holy Cross',   desc: '4ÊñπÂêëË≤´Á©øÂ∞ÑÊìä',  color: '#eeeeaa', border: '#ffffdd',
    howto: 'ÂêåÊôÇÂêë‰∏ä‰∏ãÂ∑¶Âè≥4ÂÄãÊñπÂêëÂ∞ÑÂá∫ÂçÅÂ≠óÂÖâÊùü', stats: 'ÂÇ∑ÂÆ≥:25 | ÂÜ∑Âçª:2.0s | Á©øÈÄè:5' },
  { type: 'shadow',   label: 'ÊöóÂΩ±ÂàÉ',subtitle: 'Shadow Blade', desc: 'ÊâáÂΩ¢ÊöóÂΩ±Êñ¨',     color: '#9944ff', border: '#cc88ff',
    howto: 'ÈéñÂÆöÊúÄËøëÊïµ‰∫∫ÊâáÂΩ¢Âô¥Â∞Ñ3ÈÅìÊöóÂΩ±ÂàÄÂàÉ', stats: 'ÂÇ∑ÂÆ≥:50 | ÂÜ∑Âçª:2.5s | 3Áôº' },
];

function drawWeaponSelect() {
  const opts = game.stage === 2 ? WEAPON_SELECT_OPTIONS_S2 : WEAPON_SELECT_OPTIONS_S1;
  CTX.fillStyle = 'rgba(0,0,0,0.95)'; CTX.fillRect(0, 0, W, H);
  const glow = CTX.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.6);
  glow.addColorStop(0, 'rgba(80,20,120,0.22)'); glow.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = glow; CTX.fillRect(0, 0, W, H);

  const isMobile = W < 600;
  const PAD = 10, BTN_GAP = 10, TITLE_PAD_TOP = 10;
  const titleFontSz = Math.max(16, Math.min(28, W * 0.055, H * 0.048));
  const subFontSz = Math.max(10, Math.min(13, W * 0.024));
  const HEADER_H = TITLE_PAD_TOP + titleFontSz + 6 + subFontSz + 12;

  // Detail panel height ‚Äî shown below cards when card selected/hovered
  const DETAIL_H = isMobile ? 62 : 72;
  const BTN_H = Math.max(36, Math.min(50, H * 0.07));
  const BOTTOM_RESERVED = DETAIL_H + BTN_GAP + BTN_H + PAD + 6;
  const availH = H - HEADER_H - BOTTOM_RESERVED;

  const numCards = opts.length;
  const cols = W < 420 ? 2 : (isMobile ? Math.min(numCards, 3) : numCards);
  const rows = Math.ceil(numCards / cols);
  const GAP = Math.max(5, Math.min(10, W * 0.016));
  const cardW = Math.floor((W - PAD * 2 - GAP * (cols - 1)) / cols);
  const cardH = Math.max(70, Math.floor((availH - GAP * (rows - 1)) / rows));
  const startX = PAD, startY = HEADER_H;

  // Title
  CTX.textAlign = 'center';
  const titleY = TITLE_PAD_TOP + titleFontSz;
  CTX.save(); CTX.shadowColor = '#cc88ff'; CTX.shadowBlur = 20; CTX.fillStyle = '#cc88ff';
  CTX.font = 'bold ' + titleFontSz + 'px "Cinzel Decorative", serif';
  CTX.fillText(game.stage === 2 ? 'ÈÅ∏ÊìáÁ¨¨‰∫åÈóúËµ∑ÂßãÊ≠¶Âô®' : 'ÈÅ∏ÊìáÂàùÂßãÊ≠¶Âô®', W/2, titleY); CTX.restore();
  CTX.fillStyle = 'rgba(200,180,230,0.5)'; CTX.font = subFontSz + 'px "Cinzel", serif';
  CTX.fillText('Choose Your Starting Weapon', W/2, titleY + titleFontSz + 2);

  // Track which card is hovered for detail panel
  let hoveredOpt = null;

  for (let i = 0; i < numCards; i++) {
    const opt = opts[i];
    const col = i % cols, row = Math.floor(i / cols);
    const cx = startX + col * (cardW + GAP), cy = startY + row * (cardH + GAP);
    const isSelected = game.selectedWeapon === opt.type;
    const isHover = !isMobile && mouse.x >= cx && mouse.x <= cx + cardW && mouse.y >= cy && mouse.y <= cy + cardH;
    const hi = isSelected || isHover;
    if (isHover || isSelected) hoveredOpt = opt;
    const capI = i;
    registerBtn(cx, cy, cardW, cardH, 'weaponSelect', () => { game.selectedWeapon = opts[capI].type; });

    if (isSelected) { CTX.save(); CTX.shadowColor = opt.border; CTX.shadowBlur = 20; CTX.fillStyle = 'rgba(0,0,0,0)'; CTX.fillRect(cx - 3, cy - 3, cardW + 6, cardH + 6); CTX.restore(); }
    const bgCol = isSelected ? '#3a1860' : (hi ? '#2a1248' : '#120a22');
    pxRect(cx, cy, cardW, cardH, bgCol);
    pxRect(cx, cy, cardW, isSelected ? 4 : 2, opt.border);
    pxRectOutline(cx, cy, cardW, cardH, isSelected ? opt.border : (hi ? opt.color : 'rgba(80,60,100,0.55)'), isSelected ? 2 : 1);

    const iconSize = Math.max(14, Math.min(cardW * 0.35, cardH * 0.28, 36));
    const iconY = cy + cardH * (cardH > 110 ? 0.35 : 0.38);
    CTX.save(); if (isSelected) { CTX.shadowColor = opt.border; CTX.shadowBlur = 12; }
    CTX.font = iconSize + 'px serif'; CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
    CTX.fillText({ whip:'ü™¢', wand:'ü™Ñ', axe:'ü™ì', bible:'üìñ', firewand:'üî•', lightning:'‚ö°', cross:'‚úùÔ∏è', shadow:'üó°' }[opt.type] || '‚öî', cx + cardW/2, iconY);
    CTX.restore(); CTX.textBaseline = 'alphabetic';

    const nameFontSz = Math.max(9, Math.min(13, cardW * 0.1, cardH * 0.09));
    CTX.fillStyle = isSelected ? opt.border : '#e8e0f8';
    CTX.font = 'bold ' + nameFontSz + 'px "Cinzel", serif'; CTX.textAlign = 'center';
    CTX.fillText(opt.label, cx + cardW/2, cy + cardH * 0.6);

    if (cardH > 90) {
      CTX.fillStyle = opt.color;
      CTX.font = Math.max(7, Math.min(10, cardW * 0.075)) + 'px "Cinzel", serif';
      CTX.fillText(opt.subtitle, cx + cardW/2, cy + cardH * 0.75);
    }
    if (isSelected) {
      CTX.save(); CTX.fillStyle = opt.border; CTX.shadowColor = opt.border; CTX.shadowBlur = 6;
      CTX.font = 'bold ' + Math.max(7, Math.min(9, cardW * 0.062)) + 'px "Cinzel", serif';
      CTX.fillText('‚úì Â∑≤ÈÅ∏Êìá', cx + cardW/2, cy + cardH - 6); CTX.restore();
    }
  }

  // ‚îÄ‚îÄ Detail panel: show for selected weapon (fallback to hovered) ‚îÄ‚îÄ
  const selectedOpt = opts.find(o => o.type === game.selectedWeapon) || hoveredOpt;
  const cardsBottom = startY + rows * cardH + (rows - 1) * GAP;
  const detailY = cardsBottom + BTN_GAP;
  const detailW = Math.min(W - PAD * 2, 600), detailX = W/2 - detailW/2;

  if (selectedOpt) {
    pxRect(detailX, detailY, detailW, DETAIL_H, 'rgba(10,0,25,0.85)');
    pxRectOutline(detailX, detailY, detailW, DETAIL_H, selectedOpt.border, 1);
    pxRect(detailX, detailY, detailW, 3, selectedOpt.border);

    CTX.textAlign = 'left';
    const dPad = 10, lineH = isMobile ? 13 : 15;
    const fSz = isMobile ? 10 : 12;

    // Weapon name
    CTX.save(); CTX.fillStyle = selectedOpt.border; CTX.shadowColor = selectedOpt.border; CTX.shadowBlur = 6;
    CTX.font = 'bold ' + (fSz + 2) + 'px "Cinzel", serif';
    CTX.fillText(selectedOpt.label + '  ' + selectedOpt.subtitle, detailX + dPad, detailY + lineH + 2);
    CTX.restore();

    // Attack method
    CTX.fillStyle = '#e8d8ff';
    CTX.font = fSz + 'px "Cinzel", serif';
    CTX.fillText('‚öî ÊîªÊìäÊñπÂºèÔºö' + (selectedOpt.howto || selectedOpt.desc), detailX + dPad, detailY + lineH * 2 + 4);

    // Stats
    CTX.fillStyle = selectedOpt.color;
    CTX.font = fSz + 'px "Cinzel", serif';
    CTX.fillText('üìä ' + (selectedOpt.stats || ''), detailX + dPad, detailY + lineH * 3 + 6);
  }

  // ‚îÄ‚îÄ Confirm button ‚îÄ‚îÄ
  const btnW = Math.min(220, W - PAD * 2), btnX = W/2 - btnW/2;
  const btnY = Math.min(detailY + DETAIL_H + BTN_GAP, H - BTN_H - PAD);
  pxRect(btnX, btnY, btnW, BTN_H, '#280a50'); pxRect(btnX + 3, btnY + 3, btnW - 6, BTN_H - 6, '#4a2080');
  pxRectOutline(btnX, btnY, btnW, BTN_H, '#cc88ff', 2);
  CTX.save(); CTX.shadowColor = '#eeccff'; CTX.shadowBlur = 8; CTX.fillStyle = '#eeccff';
  CTX.font = 'bold ' + Math.max(13, Math.min(17, W * 0.034)) + 'px "Cinzel", serif';
  CTX.textAlign = 'center'; CTX.fillText('‚öî  Âá∫ÁôºÂÜíÈö™  ‚öî', W/2, btnY + BTN_H * 0.67); CTX.restore();
  registerBtn(btnX, btnY, btnW, BTN_H, 'weaponSelect', () => { game.reset(game.selectedWeapon, game.stage); });
}

// ====== STAGE 3 SELECT SCREEN (4 Weapons + 4 Passives) ‚Äî Card layout with descriptions ======
// Hover state for detail display
const _s3Hover = { type: null, cat: null };

function drawStage3Select() {
  CTX.fillStyle = 'rgba(10,0,20,0.98)'; CTX.fillRect(0, 0, W, H);
  const glow = CTX.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.7);
  glow.addColorStop(0, 'rgba(80,0,120,0.3)'); glow.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = glow; CTX.fillRect(0, 0, W, H);
  CTX.textAlign = 'center';

  const isMobile = W < 600;
  const fTitle = Math.min(22, W * 0.055);

  CTX.save(); CTX.shadowColor = '#cc44ff'; CTX.shadowBlur = 24; CTX.fillStyle = '#cc44ff';
  CTX.font = 'bold ' + fTitle + 'px "Cinzel Decorative", serif';
  CTX.fillText('ÁµÇÂ±ÄÂÇôÊà∞ÔºöÈÅ∏Êìá4Ê≠¶Âô®Ëàá4ÊäÄËÉΩ', W/2, fTitle + 8); CTX.restore();

  const wps = getAvailableWeapons();  // all available weapon types
  const psv = getAvailablePassives(); // all available passive types

  // Card dimensions
  const PAD = 8;
  const COLS_W = isMobile ? 4 : Math.min(8, wps.length);
  const COLS_P = isMobile ? 5 : Math.min(10, psv.length);
  const GAP = 6;
  const cardW = Math.floor((W - PAD*2 - GAP*(COLS_W-1)) / COLS_W);
  const cardH = Math.max(56, Math.min(80, cardW * 1.3));

  // Section Y positions
  const WPN_LABEL_Y = fTitle + 28;
  const WPN_Y = WPN_LABEL_Y + 18;
  const wRows = Math.ceil(wps.length / COLS_W);
  const PSV_LABEL_Y = WPN_Y + wRows*(cardH+GAP) + 10;
  const PSV_Y = PSV_LABEL_Y + 18;

  // Weapon section label
  const wSel = stage3Selections.weapons.length;
  CTX.fillStyle = wSel === 4 ? '#44ff88' : '#cc88ff';
  CTX.font = 'bold ' + Math.min(13, W*0.03) + 'px "Cinzel", serif';
  CTX.fillText(`‚öî Ê≠¶Âô® (${wSel}/4)  ‚Äî ÈÅ∏Êìá4Á®ÆÂàùÂßãÊ≠¶Âô®`, W/2, WPN_LABEL_Y);

  // Weapon cards
  _s3Hover.type = null;
  for (let i = 0; i < wps.length; i++) {
    const t = wps[i];
    const col = i % COLS_W, row = Math.floor(i / COLS_W);
    const cx = PAD + col * (cardW + GAP);
    const cy = WPN_Y + row * (cardH + GAP);
    const sel = stage3Selections.weapons.includes(t);
    const isHov = !isMobile && mouse.x >= cx && mouse.x <= cx+cardW && mouse.y >= cy && mouse.y <= cy+cardH;
    if (isHov) { _s3Hover.type = t; _s3Hover.cat = 'weapon'; }

    // Card bg
    pxRect(cx, cy, cardW, cardH, sel ? '#2a1060' : (isHov ? '#1e0848' : '#0e0420'));
    pxRect(cx, cy, cardW, 3, sel ? '#cc88ff' : (isHov ? '#9955cc' : '#441188'));
    pxRectOutline(cx, cy, cardW, cardH, sel ? '#cc88ff' : (isHov ? '#9955cc' : '#330066'), sel ? 2 : 1);

    // Icon
    const iconSz = Math.max(16, Math.min(cardW * 0.45, cardH * 0.4, 28));
    CTX.save(); if (sel) { CTX.shadowColor = '#cc88ff'; CTX.shadowBlur = 10; }
    CTX.font = iconSz + 'px serif'; CTX.textBaseline = 'middle';
    CTX.fillText(WEAPON_DEFS[t].icon, cx + cardW/2, cy + cardH * 0.36); CTX.restore();
    CTX.textBaseline = 'alphabetic';

    // Name
    const nameArr = WEAPON_DEFS[t].name.split(' ');
    const chName = nameArr[0];
    CTX.fillStyle = sel ? '#ffd700' : (isHov ? '#e8e0f8' : '#c0b0d8');
    CTX.font = 'bold ' + Math.max(7, Math.min(10, cardW*0.13)) + 'px "Cinzel", serif';
    CTX.fillText(chName, cx + cardW/2, cy + cardH * 0.72);

    // Selected check
    if (sel) {
      CTX.fillStyle = '#44ff88'; CTX.font = 'bold ' + Math.max(7, Math.min(9, cardW*0.1)) + 'px "Cinzel", serif';
      CTX.fillText('‚úì', cx + cardW - 8, cy + 10);
    }

    registerBtn(cx, cy, cardW, cardH, 'stage3Select', () => {
      if (sel) stage3Selections.weapons = stage3Selections.weapons.filter(x => x !== t);
      else if (stage3Selections.weapons.length < 4) stage3Selections.weapons.push(t);
    });
  }

  // Passive section label
  const pSel = stage3Selections.passives.length;
  CTX.fillStyle = pSel === 4 ? '#44ff88' : '#44ddff';
  CTX.font = 'bold ' + Math.min(13, W*0.03) + 'px "Cinzel", serif';
  CTX.textAlign = 'center';
  CTX.fillText(`‚ú¶ ÊäÄËÉΩ (${pSel}/4)  ‚Äî ÈÅ∏Êìá4Á®ÆË¢´ÂãïÊäÄËÉΩ`, W/2, PSV_LABEL_Y);

  // Passive cards
  const pCardW = Math.floor((W - PAD*2 - GAP*(COLS_P-1)) / COLS_P);
  const pCardH = Math.max(52, Math.min(72, pCardW * 1.25));
  for (let i = 0; i < psv.length; i++) {
    const t = psv[i];
    const col = i % COLS_P, row = Math.floor(i / COLS_P);
    const cx = PAD + col * (pCardW + GAP);
    const cy = PSV_Y + row * (pCardH + GAP);
    const sel = stage3Selections.passives.includes(t);
    const isHov = !isMobile && mouse.x >= cx && mouse.x <= cx+pCardW && mouse.y >= cy && mouse.y <= cy+pCardH;
    if (isHov) { _s3Hover.type = t; _s3Hover.cat = 'passive'; }

    pxRect(cx, cy, pCardW, pCardH, sel ? '#0a2818' : (isHov ? '#0d3520' : '#051208'));
    pxRect(cx, cy, pCardW, 3, sel ? '#44ff88' : (isHov ? '#22aa55' : '#115522'));
    pxRectOutline(cx, cy, pCardW, pCardH, sel ? '#44ff88' : (isHov ? '#22aa55' : '#114422'), sel ? 2 : 1);

    const iconSz2 = Math.max(14, Math.min(pCardW * 0.45, pCardH * 0.4, 24));
    CTX.save(); if (sel) { CTX.shadowColor = '#44ff88'; CTX.shadowBlur = 8; }
    CTX.font = iconSz2 + 'px serif'; CTX.textBaseline = 'middle';
    CTX.fillText(PASSIVE_DEFS[t].icon, cx + pCardW/2, cy + pCardH * 0.36); CTX.restore();
    CTX.textBaseline = 'alphabetic';

    const pNameArr = PASSIVE_DEFS[t].name.split(' ');
    const pChName = pNameArr[0];
    CTX.fillStyle = sel ? '#44ff88' : (isHov ? '#e8f8e8' : '#b0d0b8');
    CTX.font = 'bold ' + Math.max(6, Math.min(9, pCardW*0.13)) + 'px "Cinzel", serif';
    CTX.fillText(pChName, cx + pCardW/2, cy + pCardH * 0.72);

    if (sel) {
      CTX.fillStyle = '#44ff88'; CTX.font = 'bold ' + Math.max(7, Math.min(9, pCardW*0.1)) + 'px "Cinzel", serif';
      CTX.fillText('‚úì', cx + pCardW - 8, cy + 10);
    }

    registerBtn(cx, cy, pCardW, pCardH, 'stage3Select', () => {
      if (sel) stage3Selections.passives = stage3Selections.passives.filter(x => x !== t);
      else if (stage3Selections.passives.length < 4) stage3Selections.passives.push(t);
    });
  }

  // ‚îÄ‚îÄ Detail panel: show description of hovered or one selected item ‚îÄ‚îÄ
  const pRows = Math.ceil(psv.length / COLS_P);
  const psvBottom = PSV_Y + pRows * (pCardH + GAP);
  const detailY = psvBottom + 8;
  const detailH = isMobile ? 52 : 60;
  const detailW = Math.min(W - PAD*2, 560), detailX = W/2 - detailW/2;

  // Pick: hovered item, else first selected weapon, else first selected passive
  let detailDef = null, detailCat = null;
  if (_s3Hover.type) {
    detailDef = _s3Hover.cat === 'weapon' ? WEAPON_DEFS[_s3Hover.type] : PASSIVE_DEFS[_s3Hover.type];
    detailCat = _s3Hover.cat;
  } else if (stage3Selections.weapons.length > 0) {
    const lt = stage3Selections.weapons[stage3Selections.weapons.length - 1];
    detailDef = WEAPON_DEFS[lt]; detailCat = 'weapon';
  } else if (stage3Selections.passives.length > 0) {
    const lt = stage3Selections.passives[stage3Selections.passives.length - 1];
    detailDef = PASSIVE_DEFS[lt]; detailCat = 'passive';
  }

  if (detailDef) {
    const dcol = detailCat === 'weapon' ? '#cc88ff' : '#44ff88';
    pxRect(detailX, detailY, detailW, detailH, 'rgba(8,0,20,0.9)');
    pxRect(detailX, detailY, detailW, 3, dcol);
    pxRectOutline(detailX, detailY, detailW, detailH, dcol + '88', 1);
    const fSz = isMobile ? 9 : 11;
    const dPad = 10, lH = fSz + 4;
    CTX.textAlign = 'left';
    CTX.save(); CTX.fillStyle = dcol; CTX.shadowColor = dcol; CTX.shadowBlur = 4;
    CTX.font = 'bold ' + (fSz+2) + 'px "Cinzel", serif';
    CTX.fillText(detailDef.name, detailX + dPad, detailY + lH + 2); CTX.restore();
    CTX.fillStyle = '#d8d0f0'; CTX.font = fSz + 'px "Cinzel", serif';
    if (detailCat === 'weapon') {
      // Find matching weapon option for howto/stats
      // Combine both option arrays to find the matching weapon option (has howto+stats)
      const _allWOpts = [...WEAPON_SELECT_OPTIONS_S1, ...WEAPON_SELECT_OPTIONS_S2];
      const _targetType = _s3Hover.type || (stage3Selections.weapons.length > 0 ? stage3Selections.weapons[stage3Selections.weapons.length - 1] : null);
      const wOptMatch = _allWOpts.find(o => o.type === _targetType);
      CTX.fillText('‚öî ' + (wOptMatch ? wOptMatch.howto : detailDef.name), detailX + dPad, detailY + lH*2 + 2);
      CTX.fillStyle = '#c0a8e8';
      CTX.fillText('üìä ' + (wOptMatch ? wOptMatch.stats : ''), detailX + dPad, detailY + lH*3 + 2);
    } else {
      CTX.fillText('‚ú¶ ÊïàÊûúÔºö' + detailDef.desc, detailX + dPad, detailY + lH*2 + 2);
      CTX.fillStyle = '#a0c8a0';
      CTX.fillText('üìà ÊØèÂçá1Á¥öÂ¢ûÂä†ÊïàÊûúÔºåÊúÄÈ´ò5Á¥ö', detailX + dPad, detailY + lH*3 + 2);
    }
    CTX.textAlign = 'center';
  }

  // ‚îÄ‚îÄ Confirm Button ‚îÄ‚îÄ
  const allReady = stage3Selections.weapons.length === 4 && stage3Selections.passives.length === 4;
  const btnW = Math.min(240, W - PAD*2), btnH = Math.min(48, rh(48));
  const bx = W/2 - btnW/2, by = H - btnH - 8;
  pxRect(bx, by, btnW, btnH, allReady ? '#3a0000' : '#1a1030');
  pxRect(bx+3, by+3, btnW-6, btnH-6, allReady ? '#6a0000' : '#2a1a50');
  pxRectOutline(bx, by, btnW, btnH, allReady ? '#ff4444' : '#443366', 2);
  CTX.save(); CTX.fillStyle = allReady ? '#ff8888' : '#665588';
  if (allReady) { CTX.shadowColor = '#ff8888'; CTX.shadowBlur = 8; }
  CTX.font = 'bold ' + Math.min(16, W*0.035) + 'px "Cinzel", serif';
  CTX.fillText(allReady ? '‚öî ÈÄ≤ÂÖ•Èö±ËóèÈóúÂç° ‚öî' : `Â∞öÈúÄÈÅ∏Êìá ${4 - stage3Selections.weapons.length} Ê≠¶Âô® / ${4 - stage3Selections.passives.length} ÊäÄËÉΩ`, W/2, by + btnH * 0.65);
  CTX.restore();
  if (allReady) registerBtn(bx, by, btnW, btnH, 'stage3Select', () => { game.reset(null, 3); });
}

// ====== LEVEL UP SCREEN ======
function drawLevelUp() {
  CTX.fillStyle = 'rgba(5,0,15,0.84)'; CTX.fillRect(0, 0, W, H);
  const vig = CTX.createRadialGradient(W/2, H/2, 100, W/2, H/2, Math.max(W,H)*0.7);
  vig.addColorStop(0, 'rgba(0,0,0,0)'); vig.addColorStop(1, 'rgba(0,0,0,0.6)');
  CTX.fillStyle = vig; CTX.fillRect(0, 0, W, H); CTX.textAlign = 'center';

  const isMobile = W < 600;
  CTX.save(); CTX.shadowColor = '#ffe066'; CTX.shadowBlur = 28; CTX.fillStyle = '#ffe066'; CTX.font = `bold ${Math.min(40, rw(40))}px "Cinzel Decorative", serif`; CTX.fillText('‚¨Ü LEVEL UP! ‚¨Ü', W/2, isMobile ? 48 : H/2 - 140); CTX.restore();
  CTX.fillStyle = 'rgba(200,180,230,0.6)'; CTX.font = `${Math.min(13, rw(13))}px "Cinzel", serif`; CTX.fillText('ÈªûÊìäÂç°ÁâáÈÅ∏ÊìáÂçáÁ¥ö', W/2, isMobile ? 70 : H/2 - 100);

  const maxCardW = isMobile ? Math.min(155, (W - 30) / 3 - 8) : 185;
  const cardW = maxCardW, cardH = isMobile ? Math.min(185, H - 105) : 215; const gap = isMobile ? 8 : 20;
  const totalW = levelUpChoices.length * cardW + (levelUpChoices.length - 1) * gap;
  const startX = Math.max(4, (W - totalW) / 2), startY = isMobile ? 82 : H / 2 - 85;

  for (let i = 0; i < levelUpChoices.length; i++) {
    const c = levelUpChoices[i], cx = startX + i * (cardW + gap), cy = startY;
    registerBtn(cx, cy, cardW, cardH, 'levelup', () => selectChoice(i));
    const isWeapon = c.cat === 'weapon', def = isWeapon ? WEAPON_DEFS[c.type] : PASSIVE_DEFS[c.type];
    const isHover = !isMobile && mouse.x >= cx && mouse.x <= cx + cardW && mouse.y >= cy && mouse.y <= cy + cardH;

    pxRect(cx, cy, cardW, cardH, isWeapon ? (isHover ? '#2a1a5a' : '#1e1440') : (isHover ? '#0f3020' : '#0a2218'));
    pxRect(cx, cy, cardW, 3, isWeapon ? '#9b5de5' : '#2ecc71');
    pxRectOutline(cx, cy, cardW, cardH, isHover ? (isWeapon ? '#9b5de5' : '#2ecc71') : (isWeapon ? 'rgba(100,60,180,0.55)' : 'rgba(40,140,70,0.55)'), isHover ? 2 : 1);

    const iconSize = Math.min(38, cardW * 0.21);
    CTX.save(); if (isHover) { CTX.shadowColor = isWeapon ? '#cc88ff' : '#44ee88'; CTX.shadowBlur = 18; }
    CTX.font = `${iconSize}px serif`; CTX.textAlign = 'center'; CTX.fillText(def.icon, cx + cardW/2, cy + cardH * 0.27); CTX.restore();

    const nameFontSize = Math.min(12, cardW * 0.073); CTX.fillStyle = '#e8e0f8'; CTX.font = `bold ${nameFontSize}px "Cinzel", serif`;
    let displayName = def.name; if (isMobile) displayName = def.name.split(' ')[0];
    CTX.fillText(displayName, cx + cardW/2, cy + cardH * 0.43);

    CTX.save(); CTX.shadowColor = '#ffe066'; CTX.shadowBlur = c.isNew ? 10 : 3; CTX.fillStyle = c.isNew ? '#ffe066' : '#c0a830';
    CTX.font = `bold ${Math.min(11, cardW * 0.068)}px "Cinzel", serif`;
    CTX.fillText(c.isNew ? '‚ú¶ NEW ‚ú¶' : `Lv${c.level-1}‚Üí${c.level}`, cx + cardW/2, cy + cardH * 0.56); CTX.restore();

    CTX.fillStyle = isWeapon ? '#9b5de5' : '#2ecc71'; CTX.font = `${Math.min(11, cardW * 0.063)}px "Cinzel", serif`;
    CTX.fillText(isWeapon ? 'Ê≠¶Âô®' : 'Ë¢´Âãï', cx + cardW/2, cy + cardH * 0.68);

    if (!isWeapon && cardH > 160) { CTX.fillStyle = 'rgba(200,230,200,0.75)'; CTX.font = `${Math.min(11, cardW * 0.062)}px "Cinzel", serif`; CTX.fillText(def.desc, cx + cardW/2, cy + cardH * 0.79); }
    const tapHint = isMobile ? 'ÈªûÊìä' : (isHover ? 'ÈªûÊìäÈÅ∏Êìá' : '');
    if (tapHint) { CTX.fillStyle = 'rgba(255,255,255,0.3)'; CTX.font = `${Math.min(10, cardW * 0.058)}px "Cinzel", serif`; CTX.fillText(tapHint, cx + cardW/2, cy + cardH - 10); }
  }
}

// ====== GAME OVER UI HELPERS ======
function drawPxBtn(label, x, y, w, h, bgDark, bgLight, borderCol, textCol, state, fn) {
  pxRect(x, y, w, h, bgDark); pxRect(x+3, y+3, w-6, h-6, bgLight); pxRectOutline(x, y, w, h, borderCol, 2);
  CTX.save(); CTX.shadowColor = textCol; CTX.shadowBlur = 6; CTX.fillStyle = textCol; CTX.font = `bold ${Math.min(14, rw(14))}px "Cinzel", serif`; CTX.textAlign = 'center'; CTX.fillText(label, x + w/2, y + h * 0.67); CTX.restore();
  registerBtn(x, y, w, h, state, fn);
}

function drawGameOver() {
  CTX.fillStyle = 'rgba(0,0,0,0.93)'; CTX.fillRect(0, 0, W, H);
  const glow = CTX.createRadialGradient(W/2, H/2, 0, W/2, H/2, 400); glow.addColorStop(0, 'rgba(150,0,20,0.25)'); glow.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = glow; CTX.fillRect(0, 0, W, H); CTX.textAlign = 'center';

  CTX.save(); CTX.shadowColor = '#ff0000'; CTX.shadowBlur = 48; CTX.fillStyle = '#cc1020'; CTX.font = `bold ${Math.min(58, rw(58))}px "Cinzel Decorative", serif`; CTX.fillText('GAME OVER', W/2, H/2 - rh(82)); CTX.restore();

  const panW = Math.min(320, W - 40); pxRect(W/2 - panW/2, H/2 - rh(52), panW, rh(112), 'rgba(0,0,0,0.55)'); pxRectOutline(W/2 - panW/2, H/2 - rh(52), panW, rh(112), 'rgba(180,20,30,0.6)', 1);
  const mins = Math.floor(game.time / 60), secs = Math.floor(game.time % 60);
  CTX.fillStyle = '#e8d0d8'; CTX.font = `${Math.min(15, rw(15))}px "Cinzel", serif`;
  CTX.fillText('\u23f1  \u5b58\u6d3b\u6642\u9593  ' + String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0'), W/2, H/2 - rh(20));
  CTX.fillText('\u2620  \u7e3d\u64ca\u6bba    ' + player.kills, W/2, H/2 + rh(12));
  CTX.fillText('\u2b06  \u9054\u5230\u7b49\u7d1a  ' + player.level, W/2, H/2 + rh(44));

  const bw = Math.min(190, W - 40), bh = Math.min(46, rh(46)), bx = W/2 - bw/2, by = H/2 + rh(80);
  drawPxBtn('\u21ba  \u91cd\u65b0\u958b\u59cb', bx, by, bw, bh, '#3a0008', '#6a0010', 'rgba(200,50,60,0.85)', '#ffcccc', 'gameover', () => game.startNewGame(1));
  if (!drawGameOver._keyBound) {
    drawGameOver._keyBound = true;
    function _goKey(ev) { if (game.state === 'gameover') { game.startNewGame(1); window.removeEventListener('keydown', _goKey); } }
    window.addEventListener('keydown', _goKey);
  }
}

function drawGameOver2() {
  CTX.fillStyle = 'rgba(0,0,0,0.82)'; CTX.fillRect(0, 0, W, H);
  const glow = CTX.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.55); glow.addColorStop(0, 'rgba(120,0,180,0.2)'); glow.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = glow; CTX.fillRect(0, 0, W, H); CTX.textAlign = 'center';

  const remaining = game.MAX_REVIVES - game.reviveCount; const isMobile = W < 600;

  if (remaining > 0) {
    CTX.save(); CTX.shadowColor = '#cc44ff'; CTX.shadowBlur = 36; CTX.fillStyle = '#dd66ff'; CTX.font = `bold ${Math.min(44, rw(44))}px "Cinzel Decorative", serif`; CTX.fillText('\u2620 \u9670\u4ea1 \u2620', W/2, H/2 - rh(110)); CTX.restore();
    CTX.fillStyle = 'rgba(220,180,255,0.8)'; CTX.font = `${Math.min(14, rw(14))}px "Cinzel", serif`; CTX.fillText('ÊòØÂê¶Ê∂àËÄóÂæ©Ê¥ªÂãïÂäõÁπºÁ∫åÊà∞È¨•Ôºü', W/2, H/2 - rh(68));

    const heartSize = isMobile ? 22 : 28, heartGap = isMobile ? 6 : 8; const totalHW = game.MAX_REVIVES * (heartSize + heartGap) - heartGap; const heartX0 = W/2 - totalHW/2, heartY = H/2 - rh(42);
    for (let i = 0; i < game.MAX_REVIVES; i++) {
      const hx = heartX0 + i * (heartSize + heartGap), used = i >= remaining;
      CTX.font = heartSize + 'px serif'; CTX.globalAlpha = used ? 0.22 : 1.0; CTX.fillText(used ? '\u2661' : '\u2764', hx + heartSize/2, heartY + heartSize); CTX.globalAlpha = 1;
    }
    CTX.save(); CTX.fillStyle = 'rgba(200,160,240,0.6)'; CTX.font = `${Math.min(12, rw(12))}px "Cinzel", serif`; CTX.fillText('\u5269\u9918\u5fa9\u6d3b\u6a5f\u6703: ' + remaining + ' / ' + game.MAX_REVIVES, W/2, H/2 - rh(4)); CTX.restore();

    const panW = Math.min(300, W - 40), panH = rh(60), panX = W/2 - panW/2, panY = H/2 + rh(4);
    pxRect(panX, panY, panW, panH, 'rgba(20,0,40,0.7)'); pxRectOutline(panX, panY, panW, panH, 'rgba(140,60,200,0.5)', 1);
    const mins = Math.floor(game.time / 60), secs = Math.floor(game.time % 60);
    CTX.fillStyle = 'rgba(220,200,240,0.75)'; CTX.font = `${Math.min(13, rw(13))}px "Cinzel", serif`;
    CTX.fillText('\u23f1 ' + String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0') + '   \u2620 ' + player.kills + '\u6bba   \u2b06 Lv.' + player.level, W/2, panY + panH * 0.6);

    const btnW = Math.min(isMobile ? 140 : 170, (W - 50) / 2), btnH = Math.min(48, rh(48)), gap = 12, totalBW = btnW * 2 + gap, b1x = W/2 - totalBW/2, b2x = b1x + btnW + gap, bY = H/2 + rh(72);
    drawPxBtn('\u2728 \u5fa9\u6d3b\u7e7c\u7e8c', b1x, bY, btnW, btnH, '#240048', '#4a0090', '#cc44ff', '#eeccff', 'gameover2', () => {
      game.reviveCount++; player.hp = player.maxHp; player.alive = true; player.iFrames = 3.0;
      enemies.each(e => { if (dist(player, e) < 200) { const ang = angleTo(player, e); e.x = player.x + Math.cos(ang) * 220; e.y = player.y + Math.sin(ang) * 220; } });
      spawnDmgText(player.x, player.y - 30, '\u5fa9\u6d3b! HP\u6062\u5fa9', '#ee88ff'); game.shake(6, 0.3); game.state = 'playing';
    });
    drawPxBtn('\u2620 \u653e\u68c4\u904a\u6232', b2x, bY, btnW, btnH, '#3a0008', '#6a0010', 'rgba(200,50,60,0.85)', '#ffcccc', 'gameover2', () => { game.state = 'gameover'; });

  } else {
    CTX.save(); CTX.shadowColor = '#ff0000'; CTX.shadowBlur = 44; CTX.fillStyle = '#cc1020'; CTX.font = `bold ${Math.min(48, rw(48))}px "Cinzel Decorative", serif`; CTX.fillText('GAME OVER', W/2, H/2 - rh(105)); CTX.restore();
    CTX.fillStyle = 'rgba(255,180,180,0.8)'; CTX.font = `${Math.min(14, rw(14))}px "Cinzel", serif`; CTX.fillText('\u5fa9\u6d3b\u6a5f\u6703\u5df2\u7528\u76e1', W/2, H/2 - rh(62));

    const panW = Math.min(300, W - 40); pxRect(W/2 - panW/2, H/2 - rh(46), panW, rh(80), 'rgba(0,0,0,0.55)'); pxRectOutline(W/2 - panW/2, H/2 - rh(46), panW, rh(80), 'rgba(180,20,30,0.6)', 1);
    const mins = Math.floor(game.time / 60), secs = Math.floor(game.time % 60);
    CTX.fillStyle = '#e8d0d8'; CTX.font = `${Math.min(14, rw(14))}px "Cinzel", serif`;
    CTX.fillText('\u23f1  \u5b58\u6d3b  ' + String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0') + '   \u2620  ' + player.kills + '\u6bba', W/2, H/2 - rh(14));

    const btnW = Math.min(isMobile ? 140 : 170, (W - 50) / 2), btnH = Math.min(46, rh(46)), gap = 12, totalBW = btnW * 2 + gap, b1x = W/2 - totalBW/2, b2x = b1x + btnW + gap, bY = H/2 + rh(44);
    drawPxBtn('\u21ba \u91cd\u6311\u672c\u95dc', b1x, bY, btnW, btnH, '#3a2800', '#6a5000', '#e8b84b', '#ffe066', 'gameover2', () => { game.reviveCount = 0; game.startNewGame(game.stage); });
    drawPxBtn('\u25b6 \u56de\u7b2c\u4e00\u95dc', b2x, bY, btnW, btnH, '#3a0008', '#6a0010', 'rgba(200,50,60,0.85)', '#ffcccc', 'gameover2', () => { game.reviveCount = 0; game.startNewGame(1); });
  }
}

function drawVictory() {
  const T = Date.now();
  const isMobile = W < 600;
  const isS1 = game.stage === 1;

  // ‚îÄ‚îÄ Background: animated rays of light ‚îÄ‚îÄ
  CTX.fillStyle = 'rgba(0,0,0,0.96)'; CTX.fillRect(0, 0, W, H);

  // Rotating light rays
  CTX.save();
  CTX.translate(W/2, H/2);
  for (let i = 0; i < 12; i++) {
    const a = (i / 12) * Math.PI * 2 + T / 4000;
    const rayLen = Math.max(W, H) * 0.8;
    CTX.save();
    CTX.rotate(a);
    const rayGrad = CTX.createLinearGradient(0, 0, rayLen, 0);
    rayGrad.addColorStop(0, isS1 ? 'rgba(232,184,75,0.12)' : 'rgba(180,80,255,0.12)');
    rayGrad.addColorStop(1, 'rgba(0,0,0,0)');
    CTX.fillStyle = rayGrad;
    CTX.beginPath(); CTX.moveTo(0, 0); CTX.lineTo(rayLen, -30); CTX.lineTo(rayLen, 30); CTX.closePath(); CTX.fill();
    CTX.restore();
  }
  CTX.restore();

  // Center radial glow
  const mainCol  = isS1 ? [232, 184, 75]  : [180, 80, 255];
  const mainCol2 = isS1 ? [255, 120, 0]   : [100, 0, 220];
  const glow = CTX.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.55);
  glow.addColorStop(0, `rgba(${mainCol.join(',')},0.18)`);
  glow.addColorStop(0.5, `rgba(${mainCol2.join(',')},0.08)`);
  glow.addColorStop(1, 'rgba(0,0,0,0)');
  CTX.fillStyle = glow; CTX.fillRect(0, 0, W, H);

  CTX.textAlign = 'center';

  // ‚îÄ‚îÄ Floating star particles ‚îÄ‚îÄ
  for (let i = 0; i < 30; i++) {
    const px = ((i * 137 + T * 0.015) % W);
    const py = ((i * 89  + T * 0.008) % H);
    const alpha = (Math.sin(T / 600 + i) * 0.5 + 0.5) * 0.6;
    CTX.save(); CTX.globalAlpha = alpha;
    CTX.fillStyle = isS1 ? '#ffe066' : '#cc88ff';
    CTX.shadowColor = isS1 ? '#ffe066' : '#cc88ff'; CTX.shadowBlur = 6;
    CTX.fillRect(Math.round(px), Math.round(py), 2, 2);
    CTX.restore();
  }

  // ‚îÄ‚îÄ Stage badge ‚îÄ‚îÄ
  const badgeY = H/2 - rh(isMobile ? 115 : 130);
  const badgeW = Math.min(200, W * 0.45), badgeH = isMobile ? 22 : 28;
  pxRect(W/2 - badgeW/2, badgeY - badgeH/2, badgeW, badgeH,
    isS1 ? 'rgba(100,70,0,0.7)' : 'rgba(60,0,100,0.7)');
  pxRectOutline(W/2 - badgeW/2, badgeY - badgeH/2, badgeW, badgeH,
    isS1 ? '#ffd700' : '#cc44ff', 2);
  CTX.save(); CTX.fillStyle = isS1 ? '#ffd700' : '#cc88ff';
  CTX.font = `bold ${isMobile ? 10 : 12}px "Cinzel", serif`;
  CTX.fillText(isS1 ? 'STAGE 1 COMPLETE' : 'STAGE 2 COMPLETE', W/2, badgeY + (isMobile ? 4 : 5));
  CTX.restore();

  // ‚îÄ‚îÄ Main title ‚îÄ‚îÄ
  const titleY = badgeY + (isMobile ? 40 : 55);
  CTX.save();
  CTX.shadowColor = isS1 ? '#ffe066' : '#cc44ff'; CTX.shadowBlur = 40 + Math.sin(T/500)*10;
  CTX.fillStyle = isS1 ? '#ffe066' : '#dd88ff';
  CTX.font = `bold ${Math.min(isMobile ? 32 : 44, rw(44))}px "Cinzel Decorative", serif`;
  CTX.fillText(isS1 ? '‚ú¶ Á¨¨‰∏ÄÈóúÈÄöÈóú ‚ú¶' : '‚ú¶ Á¨¨‰∫åÈóúÈÄöÈóú ‚ú¶', W/2, titleY);
  CTX.restore();

  // Subtitle
  CTX.fillStyle = isS1 ? 'rgba(255,240,150,0.7)' : 'rgba(200,150,255,0.7)';
  CTX.font = `${Math.min(13, rw(13))}px "Cinzel", serif`;
  CTX.fillText(isS1 ? 'Ê∫ñÂÇôÁπºÁ∫åÊåëÊà∞Á¨¨‰∫åÈóúÔºÅ' : 'Èö±ËóèÁöÑÈªëÊöóÊ≠£Âú®Ë†¢Âãï...', W/2, titleY + (isMobile ? 22 : 30));

  // ‚îÄ‚îÄ Stats panel ‚îÄ‚îÄ
  const panY = titleY + (isMobile ? 46 : 60);
  const panW = Math.min(340, W - 40), panH = isMobile ? 80 : 100;
  // Panel bg with gradient border
  pxRect(W/2 - panW/2, panY, panW, panH, 'rgba(5,0,15,0.8)');
  pxRect(W/2 - panW/2, panY, panW, 3, isS1 ? '#ffd700' : '#cc44ff');
  pxRect(W/2 - panW/2, panY + panH - 3, panW, 3, isS1 ? '#ffd700' : '#cc44ff');
  pxRectOutline(W/2 - panW/2, panY, panW, panH, isS1 ? 'rgba(232,184,75,0.3)' : 'rgba(180,80,255,0.3)', 1);

  const statFsz = Math.min(isMobile ? 11 : 14, rw(14));
  const statColor = isS1 ? '#e8d8a0' : '#e0c8ff';
  CTX.fillStyle = statColor; CTX.font = `${statFsz}px "Cinzel", serif`;

  const statY1 = panY + panH * 0.35, statY2 = panY + panH * 0.67;
  const halfW = panW / 2;

  // Row 1: kills + time
  const mins = Math.floor(game.time / 60), secs = Math.floor(game.time % 60);
  CTX.textAlign = 'center';
  CTX.fillStyle = isS1 ? '#ffd700' : '#cc88ff';
  CTX.font = `bold ${statFsz + 1}px "Cinzel", serif`;
  CTX.fillText('‚ò† ' + player.kills + '  ÊìäÊÆ∫', W/2 - halfW * 0.5, statY1);
  CTX.fillText('‚è± ' + String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0') + '  ÊôÇÈñì', W/2 + halfW * 0.5, statY1);
  // Row 2: level + weapons
  CTX.fillStyle = statColor; CTX.font = `${statFsz}px "Cinzel", serif`;
  CTX.fillText('‚¨Ü LV.' + player.level + '  Á≠âÁ¥ö', W/2 - halfW * 0.5, statY2);
  CTX.fillText('‚öî ' + player.weapons.length + '  Ê≠¶Âô®', W/2 + halfW * 0.5, statY2);

  // Weapon icons row
  const iconY = panY + panH + 12;
  const iconSz = isMobile ? 18 : 22;
  const iconGap = iconSz + 8;
  const iconStart = W/2 - (player.weapons.length * iconGap) / 2 + iconGap / 2;
  CTX.font = `${iconSz}px serif`; CTX.textAlign = 'center';
  for (let i = 0; i < player.weapons.length; i++) {
    const w = player.weapons[i];
    const ix = iconStart + i * iconGap;
    pxRect(ix - iconSz/2 - 2, iconY - iconSz/2 - 2, iconSz + 4, iconSz + 4, 'rgba(0,0,0,0.6)');
    pxRectOutline(ix - iconSz/2 - 2, iconY - iconSz/2 - 2, iconSz + 4, iconSz + 4,
      isS1 ? 'rgba(255,215,0,0.5)' : 'rgba(180,80,255,0.5)', 1);
    CTX.fillText(WEAPON_DEFS[w.type].icon, ix, iconY + iconSz * 0.45);
    CTX.fillStyle = isS1 ? '#ffd700' : '#cc88ff';
    CTX.font = `bold ${isMobile ? 8 : 9}px "Cinzel", serif`;
    CTX.fillText('Lv' + w.level, ix, iconY + iconSz * 0.9 + 10);
    CTX.font = `${iconSz}px serif`;
  }

  // ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ
  const btnAreaY = iconY + iconSz + (isMobile ? 26 : 34);
  const bw = Math.min(180, (W - 60) / 2), bh = Math.min(48, rh(48));
  const gap = 12, totalBtnW = bw * 2 + gap;
  const bx1 = W/2 - totalBtnW/2, bx2 = bx1 + bw + gap;

  if (isS1) {
    drawPxBtn('‚öî ÊåëÊà∞Á¨¨‰∫åÈóú', bx1, btnAreaY, bw, bh, '#3a2000', '#704000', '#e8b84b', '#ffe066', 'victory', () => {
      game.stage = 2; game.selectedWeapon = 'whip'; game.state = 'weaponSelect';
    });
  } else {
    drawPxBtn('üëÅ ÊåëÊà∞Èö±ËóèÈóú', bx1, btnAreaY, bw, bh, '#1a0030', '#3a0070', '#cc44ff', '#ee88ff', 'victory', () => {
      game.startNewGame(3);
    });
  }
  drawPxBtn('‚Ü∫ ÂÜç‰æÜ‰∏ÄÂ±Ä', bx2, btnAreaY, bw, bh, '#280008', '#550010', 'rgba(200,50,60,0.85)', '#ffcccc', 'victory', () => game.startNewGame(1));
}

function drawVictory3() {
  const T = Date.now();
  const isMobile = W < 600;

  // ‚îÄ‚îÄ Deep space background with star field ‚îÄ‚îÄ
  CTX.fillStyle = '#000005'; CTX.fillRect(0, 0, W, H);

  // Slowly drifting stars (3 layers)
  for (let layer = 0; layer < 3; layer++) {
    const speed = (layer + 1) * 0.003;
    const starCount = 40 + layer * 20;
    const starSz = layer + 1;
    for (let i = 0; i < starCount; i++) {
      const px = ((i * (137 + layer * 17) + T * speed) % W + W) % W;
      const py = ((i * (89  + layer * 23) + T * speed * 0.4) % H + H) % H;
      const twinkle = Math.sin(T / (400 + i * 17) + i) * 0.4 + 0.6;
      CTX.save(); CTX.globalAlpha = twinkle * (0.4 + layer * 0.2);
      CTX.fillStyle = layer === 2 ? '#ffd700' : '#ffffff';
      CTX.shadowColor = layer === 2 ? '#ffd700' : '#aaaaff'; CTX.shadowBlur = 3;
      CTX.fillRect(Math.round(px), Math.round(py), starSz, starSz);
      CTX.restore();
    }
  }

  // ‚îÄ‚îÄ Massive multi-layer radial aurora ‚îÄ‚îÄ
  const auroraColors = [
    [255, 215, 0, 0.14],    // gold
    [180, 80, 255, 0.10],   // purple
    [255, 120, 0,  0.08],   // orange
    [0,   200, 255, 0.06],  // cyan accent
  ];
  for (let i = 0; i < auroraColors.length; i++) {
    const [r, g, b, a] = auroraColors[i];
    const offset = Math.sin(T / (800 + i * 200)) * 60;
    const ag = CTX.createRadialGradient(W/2 + offset, H/2, 0, W/2, H/2, Math.max(W, H) * (0.55 + i * 0.12));
    ag.addColorStop(0, `rgba(${r},${g},${b},${a})`);
    ag.addColorStop(1, 'rgba(0,0,0,0)');
    CTX.fillStyle = ag; CTX.fillRect(0, 0, W, H);
  }

  // Slow rotating light beams from center
  CTX.save(); CTX.translate(W/2, H * 0.38);
  for (let i = 0; i < 16; i++) {
    const a = (i / 16) * Math.PI * 2 + T / 8000;
    const len = Math.max(W, H) * 0.9;
    const alpha = (Math.sin(T / 1200 + i * 0.8) * 0.5 + 0.5) * 0.06;
    CTX.save(); CTX.rotate(a);
    const rg = CTX.createLinearGradient(0, 0, len, 0);
    rg.addColorStop(0, `rgba(255,215,0,${alpha})`);
    rg.addColorStop(1, 'rgba(0,0,0,0)');
    CTX.fillStyle = rg;
    CTX.beginPath(); CTX.moveTo(0,0); CTX.lineTo(len,-40); CTX.lineTo(len,40); CTX.closePath(); CTX.fill();
    CTX.restore();
  }
  CTX.restore();

  CTX.textAlign = 'center';
  const vCenterY = H * 0.36;

  // ‚îÄ‚îÄ ALL CLEAR badge ‚îÄ‚îÄ
  const badgeW = Math.min(260, W * 0.6), badgeH = isMobile ? 26 : 32;
  const badgeY = vCenterY - rh(isMobile ? 145 : 170);
  const badgePulse = Math.sin(T / 600) * 0.3 + 0.7;
  CTX.save();
  CTX.shadowColor = '#ffd700'; CTX.shadowBlur = 20 * badgePulse;
  pxRect(W/2 - badgeW/2, badgeY, badgeW, badgeH, 'rgba(60,40,0,0.85)');
  pxRect(W/2 - badgeW/2, badgeY, badgeW, 3, '#ffd700');
  pxRect(W/2 - badgeW/2, badgeY + badgeH - 3, badgeW, 3, '#ffd700');
  CTX.fillStyle = '#ffd700'; CTX.font = `bold ${isMobile ? 11 : 14}px "Cinzel", serif`;
  CTX.fillText('‚ú¶  ALL CLEAR  ‚ú¶  HIDDEN STAGE COMPLETE  ‚ú¶', W/2, badgeY + badgeH * 0.72);
  CTX.restore();

  // ‚îÄ‚îÄ Main title ‚Äî two lines with glow ‚îÄ‚îÄ
  const t1Y = badgeY + badgeH + (isMobile ? 30 : 44);
  const t1Sz = Math.min(isMobile ? 26 : 38, rw(38));
  CTX.save();
  CTX.shadowColor = '#ffd700'; CTX.shadowBlur = 50 + Math.sin(T/700)*15;
  CTX.fillStyle = '#ffe566';
  CTX.font = `bold ${t1Sz}px "Cinzel Decorative", serif`;
  CTX.fillText('ÈªëÊöóÁµÇÁ©∂ÊúÉÈÅéÂéª', W/2, t1Y);
  CTX.restore();
  const t2Sz = Math.min(isMobile ? 20 : 30, rw(30));
  CTX.save();
  CTX.shadowColor = '#cc88ff'; CTX.shadowBlur = 35 + Math.sin(T/600+1)*10;
  CTX.fillStyle = '#e8ccff';
  CTX.font = `bold ${t2Sz}px "Cinzel Decorative", serif`;
  CTX.fillText('‰∏ñÁïåÂõ†‰Ω†ÊÅ¢Âæ©‰∫ÜÂíåÂπ≥', W/2, t1Y + t1Sz + (isMobile ? 10 : 16));
  CTX.restore();

  // Decorative divider
  const divY = t1Y + t1Sz + (isMobile ? 34 : 54);
  const divW = Math.min(320, W - 60);
  pxRect(W/2 - divW/2, divY, divW, 1, 'rgba(255,215,0,0.4)');
  CTX.fillStyle = '#ffd700'; CTX.font = `${isMobile ? 16 : 20}px serif`;
  CTX.fillText('‚ú¶', W/2, divY + (isMobile ? 12 : 14));
  pxRect(W/2 - divW/2, divY + (isMobile ? 17 : 20), divW, 1, 'rgba(255,215,0,0.4)');

  // ‚îÄ‚îÄ Stats panel ‚îÄ‚îÄ
  const statPanY = divY + (isMobile ? 24 : 34);
  const statPanW = Math.min(380, W - 30), statPanH = isMobile ? 88 : 110;
  pxRect(W/2 - statPanW/2, statPanY, statPanW, statPanH, 'rgba(4,0,12,0.85)');
  pxRect(W/2 - statPanW/2, statPanY, statPanW, 3, '#ffd700');
  pxRectOutline(W/2 - statPanW/2, statPanY, statPanW, statPanH, 'rgba(255,215,0,0.25)', 1);

  const sf = Math.min(isMobile ? 10 : 13, rw(13));
  const hPan = statPanW / 2;
  const sRow1 = statPanY + statPanH * 0.28, sRow2 = statPanY + statPanH * 0.58, sRow3 = statPanY + statPanH * 0.85;
  const mins3 = Math.floor(game.time / 60), secs3 = Math.floor(game.time % 60);

  CTX.font = `bold ${sf + 1}px "Cinzel", serif`;
  CTX.fillStyle = '#ffd700';
  CTX.fillText('‚ò†  ÊìäÊÆ∫Ôºö' + player.kills, W/2 - hPan * 0.5, sRow1);
  CTX.fillText('‚è±  ' + String(mins3).padStart(2,'0') + ':' + String(secs3).padStart(2,'0'), W/2 + hPan * 0.5, sRow1);
  CTX.fillStyle = '#e8d0ff';
  CTX.font = `${sf}px "Cinzel", serif`;
  CTX.fillText('‚¨Ü  Á≠âÁ¥öÔºöLV.' + player.level, W/2 - hPan * 0.5, sRow2);
  CTX.fillText('‚öî  Ê≠¶Âô®Ôºö' + player.weapons.length + ' Êää', W/2 + hPan * 0.5, sRow2);
  CTX.fillStyle = '#c0b870';
  CTX.fillText('‚ú¶  ÊäÄËÉΩÔºö' + player.passives.length + ' È†Ö', W/2, sRow3);

  // Weapon icons
  const wIconY = statPanY + statPanH + (isMobile ? 8 : 12);
  const wIconSz = isMobile ? 18 : 22;
  const wIconGap = wIconSz + 8;
  const wStart = W/2 - (player.weapons.length * wIconGap) / 2 + wIconGap / 2;
  CTX.font = `${wIconSz}px serif`; CTX.textAlign = 'center';
  for (let i = 0; i < player.weapons.length; i++) {
    const w = player.weapons[i];
    const ix = wStart + i * wIconGap;
    pxRect(ix - wIconSz/2 - 2, wIconY - wIconSz/2 - 2, wIconSz+4, wIconSz+4, 'rgba(0,0,0,0.7)');
    pxRectOutline(ix - wIconSz/2 - 2, wIconY - wIconSz/2 - 2, wIconSz+4, wIconSz+4, 'rgba(255,215,0,0.5)', 1);
    CTX.fillText(WEAPON_DEFS[w.type].icon, ix, wIconY + wIconSz * 0.45);
    CTX.fillStyle = '#ffd700'; CTX.font = `bold ${isMobile ? 8 : 9}px "Cinzel", serif`;
    CTX.fillText('Lv' + w.level, ix, wIconY + wIconSz * 0.9 + 9);
    CTX.font = `${wIconSz}px serif`;
  }

  // ‚îÄ‚îÄ Credits panel ‚îÄ‚îÄ
  const credY = wIconY + wIconSz + (isMobile ? 16 : 22);
  const credW = Math.min(340, W - 40), credH = isMobile ? 78 : 96;
  pxRect(W/2 - credW/2, credY, credW, credH, 'rgba(3,0,10,0.85)');
  pxRect(W/2 - credW/2, credY, credW, 2, '#aa8800');
  pxRect(W/2 - credW/2, credY + credH - 2, credW, 2, '#aa8800');
  pxRectOutline(W/2 - credW/2, credY, credW, credH, 'rgba(180,140,0,0.25)', 1);

  const cf = Math.min(isMobile ? 10 : 12, rw(12));
  const credLineH = isMobile ? (credH / 4.5) : (credH / 4.2);
  CTX.fillStyle = '#c8b870'; CTX.font = `bold ${cf}px "Cinzel", serif`;
  CTX.fillText('‚îÄ‚îÄ‚îÄ Ë£Ω‰ΩúÁæ§ ‚îÄ‚îÄ‚îÄ', W/2, credY + credLineH * 0.7);
  CTX.fillStyle = '#d8c880'; CTX.font = `${cf}px "Cinzel", serif`;
  CTX.fillText('ÈÅäÊà≤Ë®≠Ë®à ¬∑ ÁæéË°ì ¬∑ ÈóúÂç°ÔºöÊ¥™ËÅÜÁ∂≠', W/2, credY + credLineH * 1.7);
  CTX.fillStyle = '#aa8844'; CTX.font = `${cf - 1}px "Cinzel", serif`;
  CTX.fillText('AI Á®ãÂºèËºîÂä©ÔºöClaude Sonnet 4.6 by Anthropic & Google Gemini 3.1', W/2, credY + credLineH * 2.7);
  CTX.fillStyle = 'rgba(200,180,100,0.4)'; CTX.font = `${cf - 1}px "Cinzel", serif`;
  CTX.fillText('ÊÑüË¨ùÊÇ®Áé©Âà∞‰∫ÜÊúÄÂæå ‚Äî Thank you for playing!', W/2, credY + credLineH * 3.7);

  // ‚îÄ‚îÄ Button ‚îÄ‚îÄ
  const btnAreaY = credY + credH + (isMobile ? 14 : 20);
  const btnW = Math.min(240, W - 40), btnH = Math.min(50, rh(50));
  const bx = W/2 - btnW/2;
  // Pulse border
  const btnPulse = Math.sin(T / 700) * 0.5 + 0.5;
  CTX.save();
  CTX.shadowColor = '#ffd700'; CTX.shadowBlur = 15 * btnPulse;
  pxRect(bx, btnAreaY, btnW, btnH, '#3a2800');
  pxRect(bx+3, btnAreaY+3, btnW-6, btnH-6, '#6a5000');
  pxRectOutline(bx, btnAreaY, btnW, btnH, '#ffd700', 2);
  CTX.fillStyle = '#ffe066'; CTX.font = `bold ${Math.min(16, W*0.035)}px "Cinzel", serif`;
  CTX.fillText('‚Ü∫  ËøîÂõû‰∏ªÁï´Èù¢', W/2, btnAreaY + btnH * 0.67);
  CTX.restore();
  registerBtn(bx, btnAreaY, btnW, btnH, 'victory3', () => { game.state = 'title'; });
}

// ====== GAME LOOP ======
let lastTime = 0;
function loop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts; update(dt); render(); requestAnimationFrame(loop);
}
requestAnimationFrame(ts => { lastTime = ts; requestAnimationFrame(loop); });
</script>
</body>
</html>
