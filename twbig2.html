<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>BIG2å¤§è€äºŒå–®äººç«¶æŠ€(å°ç£è¦å‰‡ç‰ˆ)</title>
<meta name="theme-color" content="#0f5132">
<link rel="manifest" href="manifest.json">
    
<style>
/* ===== CSS è®Šæ•¸èˆ‡ä¸»é¡Œç³»çµ± ===== */
:root {
    --bg-grad-1: #0f5132;
    --bg-grad-2: #063d25;
    --accent-color: #ffc300;
    --accent-glow: rgba(255, 195, 0, 0.4);
    --panel-bg: rgba(0, 0, 0, 0.4);
}

[data-theme="red"] {
    --bg-grad-1: #7a0016;
    --bg-grad-2: #3d000b;
    --accent-color: #ffd700;
    --accent-glow: rgba(255, 215, 0, 0.4);
}

[data-theme="blue"] {
    --bg-grad-1: #0a192f;
    --bg-grad-2: #020c1b;
    --accent-color: #64ffda;
    --accent-glow: rgba(100, 255, 218, 0.4);
}

/* ===== å…¨å±€èˆ‡èƒŒæ™¯è¨­å®š ===== */
body {
    margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: radial-gradient(circle, var(--bg-grad-1), var(--bg-grad-2));
    color: white; text-align: center; overflow-x: hidden; transition: background 0.5s ease;
}

/* ===== è¦–è¦ºç‰¹æ•ˆ (éœ‡å‹•ã€æµ®å‹•å­—ã€ç™¼ç‰Œã€å‡ºç‰Œ) ===== */
@keyframes shake {
    0%, 100% { transform: translate(1px, 1px) rotate(0deg); }
    20% { transform: translate(-3px, 0px) rotate(1deg); }
    40% { transform: translate(1px, -1px) rotate(1deg); }
    60% { transform: translate(-3px, 1px) rotate(0deg); }
    80% { transform: translate(-1px, -1px) rotate(1deg); }
}
.shake-screen { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }

@keyframes floatUp {
    0% { transform: translate(-50%, -10px) scale(0.5); opacity: 0; }
    20% { transform: translate(-50%, -50px) scale(1.3); opacity: 1; text-shadow: 0 0 20px var(--accent-color), 2px 2px 4px #000; }
    80% { transform: translate(-50%, -80px) scale(1); opacity: 1; }
    100% { transform: translate(-50%, -100px) scale(1); opacity: 0; }
}
.floating-text {
    position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
    font-size: 42px; font-weight: 900; color: #fff; text-shadow: 0 0 10px #d90429, 2px 2px 4px #000;
    z-index: 300; pointer-events: none; animation: floatUp 1.2s ease-out forwards;
}

@keyframes dealIn { from { transform: translate(0, -100vh) scale(0.5) rotate(15deg); opacity: 0; } to { transform: translate(0, 0) scale(1) rotate(0deg); opacity: 1; } }
.deal-anim { animation: dealIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) both; }

@keyframes playIn { from { transform: scale(1.8) translateY(20px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } }
.play-anim { animation: playIn 0.3s ease-out both; }

/* ===== æˆå°±è§£é–æç¤º (Toast) ===== */
@keyframes toastSlide {
    0% { transform: translateX(100%); opacity: 0; }
    10% { transform: translateX(0); opacity: 1; }
    90% { transform: translateX(0); opacity: 1; }
    100% { transform: translateX(100%); opacity: 0; }
}
.toast-container { position: fixed; top: 20px; right: 20px; z-index: 400; display: flex; flex-direction: column; gap: 10px; }
.toast { background: linear-gradient(135deg, var(--accent-color), #f59e0b); color: #111; padding: 12px 20px; border-radius: 8px; font-weight: bold; box-shadow: 0 4px 15px rgba(0,0,0,0.5); display: flex; align-items: center; gap: 10px; animation: toastSlide 4s ease-in-out forwards; border-left: 5px solid #fff; }
.toast-icon { font-size: 24px; }

/* ===== UI èˆ‡ç‰ˆé¢è¨­è¨ˆ ===== */
h2 { margin-top: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); font-size: 22px; }
#info { margin-top: 5px; font-size: 16px; font-weight: bold; color: var(--accent-color); height: 24px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); }

.top-panel { background: var(--panel-bg); border-radius: 8px; padding: 10px; margin: 10px auto; width: 90%; max-width: 600px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); z-index: 20; position: relative; }
.scoreboard-title { color: var(--accent-color); font-weight: bold; margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 3px; font-size: 14px; }
#scoreDisplay { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px 15px; font-size: 14px; margin-top: 5px; }
.score-positive { color: #4ade80; } .score-negative { color: #f87171; }
.btn-small { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 4px 10px; border-radius: 4px; font-size: 12px; cursor: pointer; margin: 3px; transition: 0.2s; }
.btn-small:hover { background: rgba(255,255,255,0.2); border-color: var(--accent-color); color: var(--accent-color); }

.opponents-hud { display: flex; justify-content: space-around; align-items: center; width: 90%; max-width: 600px; margin: 10px auto 5px auto; }
.opp-box { background: rgba(0, 0, 0, 0.3); border: 1px solid #555; border-radius: 10px; padding: 8px 12px; width: 25%; transition: 0.3s; }
.opp-box.active { border-color: var(--accent-color); background: rgba(255, 255, 255, 0.1); transform: scale(1.05); box-shadow: 0 0 10px var(--accent-glow); }
.opp-name { font-size: 13px; color: #ddd; margin-bottom: 4px; }
.opp-count { font-size: 18px; font-weight: bold; color: #fff; }

#table { min-height: 120px; margin: 5px auto 20px auto; display: flex; justify-content: center; flex-wrap: wrap; background: rgba(0,0,0,0.2); border-radius: 15px; width: 90%; max-width: 600px; padding: 20px 0; box-shadow: inset 0 0 15px rgba(0,0,0,0.6); }
.hand { display: flex; justify-content: flex-start; overflow-x: auto; padding: 15px 10px 20px 10px; width: 95%; max-width: 800px; margin: 0 auto; -webkit-overflow-scrolling: touch; }

/* ===== å¡ç‰Œè¨­è¨ˆ ===== */
.card { flex: 0 0 auto; width: 65px; height: 95px; background: #fdfdfd; border-radius: 8px; margin: 0 -10px; position: relative; cursor: pointer; transition: transform 0.2s; box-shadow: -2px 0 8px rgba(0,0,0,0.4); border: 1px solid #ccc; user-select: none; color: #111;}
.card:first-child { margin-left: 0; }
.card:hover { transform: translateY(-10px); }
.card.selected { transform: translateY(-20px); box-shadow: 0 10px 20px rgba(0,0,0,0.6); border: 2px solid var(--accent-color); }
.corner { position: absolute; font-size: 14px; font-weight: 900; z-index: 2; }
.top-left { top: 4px; left: 6px; }
.bottom-right { bottom: 4px; right: 6px; transform: rotate(180deg); }
.center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 28px; z-index: 2; width: 100%; }
.watermark { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 65px; opacity: 0.1; z-index: 1; pointer-events: none; }
.face-card-text { font-family: 'Georgia', serif; font-size: 32px; font-weight: bold; line-height: 0.9; }
.face-card-suit { font-size: 18px; display: block; margin-top: 2px; }
.red { color: #d90429; } .black { color: #111111; }

#confetti-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 99; display: none; overflow: hidden; }
.confetti { position: absolute; top: -20px; width: 10px; height: 20px; animation: fall linear forwards; opacity: 0.9; border-radius: 2px; }
@keyframes fall { to { transform: translateY(110vh) rotate(720deg); } }

.controls { position: fixed; bottom: 0; width: 100%; background: var(--panel-bg); border-top: 1px solid rgba(255,255,255,0.1); padding: 12px 0; box-shadow: 0 -4px 10px rgba(0,0,0,0.4); z-index: 50; backdrop-filter: blur(5px); }
button { padding: 10px 20px; margin: 0 8px; font-size: 16px; font-weight: bold; border-radius: 20px; border: none; cursor: pointer; transition: 0.2s; }
.btn-play { background: var(--accent-color); color: #111; } .btn-play:active { transform: scale(0.95); }
.btn-pass { background: #e0e0e0; color: #333; } .btn-pass:active { transform: scale(0.95); }
.btn-hint { background: #3b82f6; color: white; } .btn-hint:active { transform: scale(0.95); }
.copyright { font-size: 12px; color: rgba(255, 255, 255, 0.5); margin-top: 15px; padding-bottom: 80px; }

/* ===== Modal å°è©±æ¡†èˆ‡æˆ°ç¸¾ç‰ˆé¢ ===== */
.modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 100; }
.modal-content { background: #fff; color: #333; padding: 25px; border-radius: 15px; width: 85%; max-width: 400px; text-align: center; max-height: 85vh; overflow-y: auto; }
.rules-text { text-align: left; font-size: 14px; line-height: 1.6; padding: 10px; background: #f1f1f1; border-radius: 8px; margin-bottom: 15px; }
.btn-restart { background: #0f5132; color: white; width: 100%; padding: 12px; margin-bottom: 10px; }
.btn-close { background: #555; color: white; width: 100%; padding: 10px; }

/* æˆ°ç¸¾é¢æ¿å°ˆå±¬æ¨£å¼ */
.stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
.stat-box { background: #e9ecef; padding: 10px; border-radius: 8px; text-align: center; }
.stat-value { font-size: 20px; font-weight: bold; color: #0f5132; margin-top: 5px; }
.achievements-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 15px; }
.badge { display: flex; flex-direction: column; align-items: center; width: 45%; background: #f8f9fa; padding: 10px; border-radius: 8px; border: 1px solid #ddd; transition: 0.3s; }
.badge.locked { filter: grayscale(100%); opacity: 0.5; }
.badge.unlocked { border-color: var(--accent-color); background: #fffbeb; box-shadow: 0 2px 5px var(--accent-glow); }
.badge-icon { font-size: 30px; margin-bottom: 5px; }
.badge-title { font-size: 13px; font-weight: bold; color: #333; }
.badge-desc { font-size: 11px; color: #666; margin-top: 3px; }

/* ä¸»é¡Œé¸æ“‡å€å¡Š */
.theme-grid { display: flex; justify-content: space-around; gap: 10px; margin-bottom: 15px; }
.theme-btn { flex: 1; padding: 15px 5px; border-radius: 8px; font-weight: bold; cursor: pointer; border: 2px solid transparent; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); }
.theme-btn[data-color="green"] { background: linear-gradient(135deg, #0f5132, #063d25); }
.theme-btn[data-color="red"] { background: linear-gradient(135deg, #7a0016, #3d000b); }
.theme-btn[data-color="blue"] { background: linear-gradient(135deg, #0a192f, #020c1b); }
.theme-btn.active { border-color: #ffc300; transform: scale(1.05); box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
</style>
</head>
<body data-theme="green">

<div id="confetti-container"></div>
<div id="toastContainer" class="toast-container"></div>

<div class="top-panel" id="scoreboard">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <span class="scoreboard-title">ğŸ† ç´¯è¨ˆç©åˆ†æ¿ (å…ˆé” 100 åˆ†å¥ªå† )</span>
        <div>
            <button class="btn-small" onclick="document.getElementById('themeModal').style.display='flex'">ğŸ¨ ä¸»é¡Œ</button>
            <button class="btn-small" onclick="openStatsModal()">ğŸ“Š æˆ°ç¸¾</button>
            <button class="btn-small" onclick="document.getElementById('rulesModal').style.display='flex'">ğŸ“– è¦å‰‡</button>
            <select id="diffSelect" class="btn-small" onchange="changeDifficulty(this.value)">
                <option value="easy">ğŸŒŸ ç°¡å–®</option>
                <option value="hard" selected>ğŸ”¥ å›°é›£</option>
            </select>
        </div>
    </div>
    <div id="scoreDisplay"></div>
</div>

<h2>ğŸ‚¡ BIG2å¤§è€äºŒå°ç£ç«¶æŠ€ç‰ˆ ğŸ‚¡</h2>
<div id="info">æ´—ç‰Œç™¼ç‰Œä¸­...</div>

<div id="opponentsHUD" class="opponents-hud"></div>
<div id="table"></div>
<div id="player" class="hand"></div>

<div class="copyright">&copy; 2026 LinWei's Big2 Taiwan Rule Version | Themes Update By Google Gemini Pro 3</div>

<div class="controls">
    <button class="btn-play" onclick="play()">å‡ºç‰Œ</button>
    <button class="btn-pass" onclick="pass()">Pass</button>
    <button class="btn-hint" onclick="showHint()">ğŸ’¡ æç¤º</button>
</div>

<div id="themeModal" class="modal-overlay">
    <div class="modal-content">
        <h2>ğŸ¨ é¸æ“‡éŠæˆ²ä¸»é¡Œ</h2>
        <div class="theme-grid">
            <div class="theme-btn" data-color="green" onclick="setTheme('green')">ç¶“å…¸ç¶ </div>
            <div class="theme-btn" data-color="red" onclick="setTheme('red')">çš‡å®¶ç´…</div>
            <div class="theme-btn" data-color="blue" onclick="setTheme('blue')">åˆå¤œè—</div>
        </div>
        <button class="btn-close" onclick="document.getElementById('themeModal').style.display='none'">é—œé–‰</button>
    </div>
</div>

<div id="statsModal" class="modal-overlay">
    <div class="modal-content">
        <h2>ğŸ“Š ç©å®¶æˆ°ç¸¾èˆ‡æˆå°±</h2>
        <div class="stats-grid">
            <div class="stat-box"><div style="font-size:12px">ç¸½å±€æ•¸</div><div id="statMatches" class="stat-value">0</div></div>
            <div class="stat-box"><div style="font-size:12px">å‹å ´æ•¸</div><div id="statWins" class="stat-value">0</div></div>
            <div class="stat-box"><div style="font-size:12px">æ‰“å‡ºæ€ªç‰©ç‰Œ</div><div id="statMonsters" class="stat-value">0</div></div>
            <div class="stat-box"><div style="font-size:12px">å–®å±€æœ€é«˜è´åˆ†</div><div id="statMaxScore" class="stat-value">0</div></div>
        </div>
        <h3 style="font-size: 15px; color: #555; border-bottom: 1px solid #ccc; padding-bottom: 5px;">ğŸ–ï¸ æ¦®è­½å¾½ç« </h3>
        <div class="achievements-container" id="badgesContainer"></div>
        <button class="btn-close" onclick="document.getElementById('statsModal').style.display='none'">é—œé–‰</button>
    </div>
</div>

<div id="rulesModal" class="modal-overlay">
    <div class="modal-content">
        <h2>ğŸ“œ å°ç£ç©æ³•è¦å‰‡èˆ‡æ“ä½œ</h2>
        <div class="rules-text">
            <b>ã€ç¨å®¶æ“ä½œã€‘</b><br>
            â¤ <b>é›™æ“Šç‰Œé¢</b>ï¼šå¯ç¬é–“é¸å–æ‰‹ä¸­æ‰€æœ‰åŒæ•¸å­—çš„å¡ç‰Œã€‚<br>
            â¤ <b>è‡ªå‹• Pass</b>ï¼šç³»çµ±åµæ¸¬æ‚¨ç„¡ç‰Œå¯å‡ºæ™‚æœƒè‡ªå‹•ç•¥éã€‚<br><hr>
            1. æœ€å°å¼µç‰Œç‚º <b>æ¢…èŠ±3</b>ã€‚<br>
            2. åŒèŠ±è‰²å¤§å°ï¼š<b>é»‘æ¡ƒ > ç´…å¿ƒ > æ–¹å¡Š > æ¢…èŠ±</b>ã€‚<br>
            3. å¯å‡ºçµ„åˆï¼šå–®å¼µã€ä¸€å°ã€ä¸‰æ¢ã€é †å­ã€è‘«è˜†ã€éµæ”¯ã€åŒèŠ±é †ã€ä¸€æ¢é¾ã€‚<br>
            4. <b>ä¸å¯å‡ºç´”åŒèŠ±</b>ã€‚<br>
            5. å‡ºä¸€å°æ¥ä¸€å°ï¼Œé †å­æ¥é †å­ï¼Œè‘«è˜†æ¥è‘«è˜†ã€‚<br>
            6. é¦–å±€å‡ºç‰Œå¿…é ˆåŒ…å« <b>æ¢…èŠ±3</b>ã€‚<br>
            7. <b>æ€ªç‰©ç‰Œç‰¹æ¬Š</b>ï¼šå¯ç„¡è¦–ç‰Œå‹ç„¡å·®åˆ¥å£“åˆ¶ã€‚<br>
            8. æ€ªç‰©å¤§å°ï¼š<b>ä¸€æ¢é¾ > åŒèŠ±é † > éµæ”¯</b>ã€‚
        </div>
        <button class="btn-close" onclick="document.getElementById('rulesModal').style.display='none'">æˆ‘çŸ¥é“äº†</button>
    </div>
</div>

<div id="scoreModal" class="modal-overlay">
    <div class="modal-content">
        <h2 id="modalTitle">éŠæˆ²çµæŸ</h2>
        <div id="modalScores" class="rules-text"></div>
        <button class="btn-restart" onclick="location.reload()">ç¹¼çºŒä¸‹ä¸€å±€</button>
        <button class="btn-close" onclick="resetScores()">æ¸…é™¤ç©åˆ†ä¸¦é‡æ–°é–‹å§‹</button>
    </div>
</div>

<script>
/* ===== è¨»å†Š PWA Service Worker ===== */
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('PWA Service Worker è¨»å†ŠæˆåŠŸï¼', reg.scope))
      .catch(err => console.log('è¨»å†Šå¤±æ•—ï¼š', err));
  });
}
    
/* ===== ä¸»é¡Œç³»çµ± ===== */
let currentTheme = localStorage.getItem("big2_theme") || "green";
setTheme(currentTheme);

function setTheme(themeName) {
    document.body.setAttribute("data-theme", themeName);
    localStorage.setItem("big2_theme", themeName);
    
    // æ›´æ–°æŒ‰éˆ• UI ç‹€æ…‹
    document.querySelectorAll('.theme-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-color') === themeName) btn.classList.add('active');
    });
}

/* ===== æˆ°ç¸¾èˆ‡æˆå°±ç³»çµ± ===== */
const defaultStats = {
    matches: 0, wins: 0, monstersPlayed: 0, maxScore: 0,
    achievements: {
        firstBlood: { unlocked: false, title: "åˆå˜—å‹æœ", icon: "ğŸ¥‰", desc: "è´å¾—ç¬¬ä¸€å ´å‹åˆ©" },
        cleanSweep: { unlocked: false, title: "ç§‹é¢¨æƒè½è‘‰", icon: "ğŸŒªï¸", desc: "ç²å‹æ™‚æœ‰å°æ‰‹å‰©é¤˜ 13 å¼µç‰Œ" },
        dragonSlayer: { unlocked: false, title: "ç¥é¾é™è‡¨", icon: "ğŸ‰", desc: "æˆåŠŸæ‰“å‡ºä¸€æ¬¡ä¸€æ¢é¾" },
        centurion: { unlocked: false, title: "ç™¾å¸", icon: "ğŸ‘‘", desc: "ç´¯è¨ˆç©åˆ†é”åˆ° 100 åˆ†å¥ªå† " }
    }
};
let playerStats = JSON.parse(localStorage.getItem("big2_stats")) || defaultStats;
function saveStats() { localStorage.setItem("big2_stats", JSON.stringify(playerStats)); }

function unlockAchievement(id) {
    if (!playerStats.achievements[id].unlocked) {
        playerStats.achievements[id].unlocked = true;
        saveStats();
        let toast = document.createElement("div"); toast.className = "toast";
        toast.innerHTML = `<span class="toast-icon">${playerStats.achievements[id].icon}</span> 
                           <div><div style="font-size:12px; opacity:0.8;">è§£é–æˆå°±</div>
                           <div style="font-size:16px;">${playerStats.achievements[id].title}</div></div>`;
        document.getElementById("toastContainer").appendChild(toast);
        setTimeout(() => toast.remove(), 4500);
        playSound(sndWin);
    }
}

function openStatsModal() {
    document.getElementById("statMatches").innerText = playerStats.matches;
    document.getElementById("statWins").innerText = playerStats.wins;
    document.getElementById("statMonsters").innerText = playerStats.monstersPlayed;
    document.getElementById("statMaxScore").innerText = playerStats.maxScore;
    let badgesHtml = "";
    for (let key in playerStats.achievements) {
        let ach = playerStats.achievements[key]; let statusClass = ach.unlocked ? "unlocked" : "locked";
        badgesHtml += `<div class="badge ${statusClass}"><div class="badge-icon">${ach.icon}</div><div class="badge-title">${ach.title}</div><div class="badge-desc">${ach.desc}</div></div>`;
    }
    document.getElementById("badgesContainer").innerHTML = badgesHtml;
    document.getElementById("statsModal").style.display = "flex";
}

/* ===== ç³»çµ±ç‹€æ…‹èˆ‡éŸ³æ•ˆ ===== */
const sndPlayCard = new Audio('https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3'); 
const sndWin = new Audio('https://assets.mixkit.co/active_storage/sfx/2013/2013-preview.mp3');      
function playSound(snd) { snd.currentTime = 0; snd.play().catch(e => console.log(e)); }

const suits = ["â™£", "â™¦", "â™¥", "â™ "]; const suitValue = {"â™£":1, "â™¦":2, "â™¥":3, "â™ ":4};
const ranks = [3, 4, 5, 6, 7, 8, 9, 10, "J", "Q", "K", "A", 2];
const rankValue = {3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:9, 10:10, J:11, Q:12, K:13, A:14, 2:15};

let deck = [], players = [[], [], [], []];
let current = 0, selected = [], last = null;
let consecutivePasses = 0, lastPlayer = -1, isFirstTurn = true;    

let aiDifficulty = localStorage.getItem("big2_diff") || "hard";
document.getElementById("diffSelect").value = aiDifficulty;
function changeDifficulty(val) { aiDifficulty = val; localStorage.setItem("big2_diff", val); updateInfo(`å·²åˆ‡æ›è‡³ ${val==='hard'?'å›°é›£':'ç°¡å–®'} æ¨¡å¼`); }

let totalScores = JSON.parse(localStorage.getItem("big2_scores")) || [0, 0, 0, 0];

function renderScoreboard() {
    let display = document.getElementById("scoreDisplay"); let html = "";
    for(let i=0; i<4; i++){
        let colorClass = totalScores[i] >= 0 ? 'score-positive' : 'score-negative';
        html += `<div>${i===0?"ä½ ":`é›»è…¦${i}`}: <span class="${colorClass}">${totalScores[i]>0?"+":""}${totalScores[i]}</span></div>`;
    }
    display.innerHTML = html;
}

function renderOpponents() {
    let hud = document.getElementById("opponentsHUD"); let html = "";
    for (let i = 1; i <= 3; i++) {
        let count = players[i].length;
        html += `<div class="opp-box ${current===i?"active":""}"><div class="opp-name">é›»è…¦ ${i}</div><div class="opp-count ${count<=2?"warning":""}">ğŸ‚  ${count}</div></div>`;
    }
    hud.innerHTML = html;
}

function createDeck(){ deck = []; for(let r of ranks) for(let s of suits) deck.push({rank: r, suit: s}); }
function shuffle(){ for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } }
function deal(){ for(let i=0; i<52; i++) players[i%4].push(deck[i]); players.forEach(p => p.sort((a,b) => rankValue[a.rank] == rankValue[b.rank] ? suitValue[a.suit] - suitValue[b.suit] : rankValue[a.rank] - rankValue[b.rank])); }
function findStarter(){ for(let i=0; i<4; i++) if(players[i].some(c => c.rank == 3 && c.suit == "â™£")) current = i; }

function buildCardHTML(card){
    let color = (card.suit == "â™¥" || card.suit == "â™¦") ? "red" : "black";
    let center = (card.rank === "J" || card.rank === "Q" || card.rank === "K") ? `<div class="face-card-text">${card.rank}<span class="face-card-suit">${card.suit}</span></div>` : card.suit;
    return `<div class="corner top-left ${color}">${card.rank}${card.suit}</div><div class="watermark ${color}">${card.suit}</div><div class="center ${color}">${center}</div><div class="corner bottom-right ${color}">${card.rank}${card.suit}</div>`;
}

function renderPlayer(isDealing = false){
    let area = document.getElementById("player"); area.innerHTML = "";
    players[0].forEach((c, i) => {
        let div = document.createElement("div"); div.className = "card";
        if(selected.includes(i)) div.classList.add("selected");
        if(isDealing) { div.classList.add("deal-anim"); div.style.animationDelay = `${i * 0.04}s`; }
        div.innerHTML = buildCardHTML(c); 
        div.onclick = () => toggle(i); div.ondblclick = () => smartSelect(i);
        area.appendChild(div);
    });
}

function renderTable(cards){
    let t = document.getElementById("table"); t.innerHTML = "";
    cards.forEach((c, i) => {
        let div = document.createElement("div"); div.className = "card play-anim"; 
        div.style.zIndex = i; div.style.margin = "0 -15px"; div.style.animationDelay = `${i * 0.05}s`;
        div.innerHTML = buildCardHTML(c); t.appendChild(div);
    });
}

function toggle(i){ if(selected.includes(i)) selected = selected.filter(x => x != i); else selected.push(i); renderPlayer(); }
function updateInfo(msg){ document.getElementById("info").innerText = msg; }

/* ===== å°ç£è¦å‰‡ç‰Œå‹æ¼”ç®—æ³• ===== */
function getRankCounts(cards) { let counts = {}; cards.forEach(c => { counts[c.rank] = (counts[c.rank] || 0) + 1; }); return counts; }
function getPower(card){ return rankValue[card.rank] * 10 + suitValue[card.suit]; }
function sameRank(cards){ return cards.every(c => c.rank == cards[0].rank); }

function isStraight(cards) {
    let sorted = [...cards].sort((a,b) => rankValue[a.rank] - rankValue[b.rank]); let isNormal = true;
    for(let i = 1; i < 5; i++) if(rankValue[sorted[i].rank] !== rankValue[sorted[i-1].rank] + 1) { isNormal = false; break; }
    if (isNormal) return sorted[4];
    let ranks = sorted.map(c => c.rank);
    if (ranks.includes("A") && ranks.includes(2) && ranks.includes(3) && ranks.includes(4) && ranks.includes(5)) return cards.find(c => c.rank === 2); 
    return null;
}

function evaluate(cards){
    let sorted = [...cards].sort((a,b) => rankValue[a.rank] - rankValue[b.rank]);
    if(cards.length === 13) {
        let isDragon = true; for(let i=0; i<13; i++) if(rankValue[sorted[i].rank] !== i+3) isDragon = false;
        if(isDragon) return { type: 13, monsterLevel: 3, value: 900000, name: "ä¸€æ¢é¾" };
    }
    if(cards.length == 1) return {type: 1, subType: "single", monsterLevel: 0, value: getPower(cards[0])};
    if(cards.length == 2 && sameRank(cards)) return {type: 2, subType: "pair", monsterLevel: 0, value: getPower(cards[1])}; 
    if(cards.length == 3 && sameRank(cards)) return {type: 3, subType: "three", monsterLevel: 0, value: getPower(cards[0])};
    if(cards.length == 5) {
        let counts = getRankCounts(cards), countVals = Object.values(counts);
        let straightMax = isStraight(cards);
        let isFlush = cards.every(c => c.suit === cards[0].suit);
        if (straightMax && isFlush) return { type: 5, subType: "straightflush", monsterLevel: 2, value: 80000 + getPower(straightMax), name: "åŒèŠ±é †" };
        if (countVals.includes(4)) return { type: 5, subType: "four", monsterLevel: 1, value: 70000 + rankValue[Object.keys(counts).find(k => counts[k] === 4)] * 10, name: "éµæ”¯" };
        if (countVals.includes(3) && countVals.includes(2)) return { type: 5, subType: "fullhouse", monsterLevel: 0, value: 30000 + rankValue[Object.keys(counts).find(k => counts[k] === 3)] * 10, name: "è‘«è˜†" };
        if (straightMax) return { type: 5, subType: "straight", monsterLevel: 0, value: 10000 + getPower(straightMax), name: "é †å­" };
    } 
    return null;
}

function getCombinations(array, size) { let result = []; function p(t, i) { if (t.length === size) { result.push(t); return; } if (i + 1 > array.length) return; p(t.concat(array[i]), i + 1); p(t, i + 1); } p([], 0); return result; }
function canBeat(playEval, lastEval) {
    if (!lastEval) return true;
    if (playEval.monsterLevel > 0 && playEval.monsterLevel > lastEval.monsterLevel) return true;
    if (playEval.type === lastEval.type && playEval.subType === lastEval.subType && playEval.value > lastEval.value) return true;
    return false;
}

function spawnFloatingText(text, isMonster) {
    let ft = document.createElement("div"); ft.className = "floating-text"; ft.innerHTML = text;
    if(isMonster) ft.style.color = "var(--accent-color)"; else ft.style.color = "#4ade80";
    document.body.appendChild(ft); setTimeout(() => ft.remove(), 1200);
}

function executePlay(cards, r, isPlayer) {
    playSound(sndPlayCard); players[current] = players[current].filter(c => !cards.includes(c)); last = r; lastPlayer = current; consecutivePasses = 0; 
    let playName = r.name || (r.type + " å¼µç‰Œ");
    updateInfo(`ç©å®¶ ${current} å‡ºäº† ${playName}`); 
    renderTable(cards); renderOpponents(); 
    
    if (isPlayer) {
        if (r.monsterLevel > 0) {
            playerStats.monstersPlayed++; saveStats();
            if (r.type === 13) unlockAchievement("dragonSlayer");
        }
    }

    if (r.name && ['é †å­','è‘«è˜†'].includes(r.name)) spawnFloatingText(r.name, false);
    if (r.monsterLevel > 0) {
        spawnFloatingText(`ğŸ”¥${r.name}ğŸ”¥`, true);
        document.body.classList.remove("shake-screen"); void document.body.offsetWidth; 
        document.body.classList.add("shake-screen");
    }

    if (isPlayer) { selected = []; renderPlayer(); } next();
}

/* ===== æ™ºèƒ½ AI æ±ºç­–æ¨¹ (æ¥µè‡´å¿ƒæ©Ÿèˆ‡å¿«é€Ÿå»ç‰Œç‰ˆ) ===== */
function aiPlay(){
    let hand = players[current]; if(hand.length == 0) return; let chosenCards = null;
    let isDanger = players.some((p, idx) => idx !== current && p.length <= 2);
    let allPlays = []; 
    
    // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çµ„åˆ
    allPlays.push(...hand.map(c => [c])); 
    allPlays.push(...getCombinations(hand, 2).filter(c => evaluate(c)?.type === 2)); 
    allPlays.push(...getCombinations(hand, 3).filter(c => evaluate(c)?.type === 3)); 
    if (hand.length >= 5) allPlays.push(...getCombinations(hand, 5).filter(c => evaluate(c) !== null));
    
    // æƒ…å¢ƒä¸€ï¼šAI æ“æœ‰é–‹å±€å‡ºç‰Œæ¬Š (Last == null)
    if(last == null){
        if (isFirstTurn) { allPlays = allPlays.filter(play => play.some(c => c.rank == 3 && c.suit == "â™£")); isFirstTurn = false; }
        
        if (aiDifficulty === 'hard') {
            let normalPlays = allPlays.filter(p => evaluate(p).monsterLevel === 0);
            if (normalPlays.length > 0 && !isDanger && hand.length > 5) {
                
                // ğŸ”¥ å›°é›£æ¨¡å¼é€²åŒ–ï¼šåƒåœ¾ç‰Œç¶‘ç¶æ³• (æœ€å¤§åŒ–æ¶ˆè€—ç‰Œæ•¸)
                // æ‰¾å‡ºæ‰‹ä¸­å¯ä»¥åˆæ³•æ‰“å‡ºçš„ã€Œæœ€å°é‚£å¼µç‰Œã€
                let lowestCard = hand.find(c => normalPlays.some(p => p.includes(c)));
                
                if (lowestCard) {
                    // æ‰¾å‡ºæ‰€æœ‰åŒ…å«é€™å¼µã€Œæœ€å°ç‰Œã€çš„çµ„åˆ
                    let playsWithLowest = normalPlays.filter(p => p.includes(lowestCard));
                    
                    // æ’åºæ ¸å¿ƒï¼šå„ªå…ˆå‡ºã€Œå¼µæ•¸å¤šã€çš„ (5å¼µ > 3å¼µ > 2å¼µ > 1å¼µ)ï¼Œå¼µæ•¸ç›¸åŒæ‰æ¯”å¤§å°
                    playsWithLowest.sort((a, b) => {
                        if (b.length !== a.length) return b.length - a.length;
                        return evaluate(a).value - evaluate(b).value;
                    });
                    chosenCards = playsWithLowest[0];
                } else {
                    normalPlays.sort((a, b) => evaluate(a).value - evaluate(b).value);
                    chosenCards = normalPlays[0];
                }
            } else { 
                allPlays.sort((a, b) => evaluate(a).value - evaluate(b).value);
                chosenCards = allPlays[0]; 
            }
        } else { 
            // ğŸŒŸ ç°¡å–®æ¨¡å¼ï¼šç¶­æŒç„¡è…¦å‡ºæœ€å°å–®å¼µ/å°ç‰Œçš„è¦å¾‹
            allPlays.sort((a, b) => evaluate(a).value - evaluate(b).value);
            if (allPlays.length > 0) chosenCards = allPlays[0]; 
        }
    } 
    // æƒ…å¢ƒäºŒï¼šAI éœ€è¦å£“åˆ¶å°æ‰‹ (Last != null)
    else {
        let validPlays = allPlays.filter(combo => { let evalC = evaluate(combo); return evalC && canBeat(evalC, last); });
        
        if (validPlays.length > 0) {
            if (aiDifficulty === 'hard') {
                let normalPlays = validPlays.filter(p => evaluate(p).monsterLevel === 0);
                let monsterPlays = validPlays.filter(p => evaluate(p).monsterLevel > 0);
                
                if (normalPlays.length > 0) {
                    // ğŸ”¥ å›°é›£æ¨¡å¼é€²åŒ–ï¼šè½ç‰Œé«˜ä½å°é–
                    if (isDanger && last.type <= 2) {
                        // ç•¶æœ‰äººè½ç‰Œï¼Œä¸”ç›¤é¢æ˜¯å–®å¼µæˆ–å°å­æ™‚ï¼Œç›´æ¥å‡ºã€Œæœ€å¤§ã€çš„å¸¸è¦ç‰Œå»é ‚æ­»ä¸‹å®¶
                        normalPlays.sort((a, b) => evaluate(b).value - evaluate(a).value);
                    } else {
                        // æ­£å¸¸æƒ…æ³ï¼šå‡ºã€Œå‰›å¥½èƒ½å£“éã€çš„æœ€å°ç‰Œï¼Œä¿ç•™å¯¦åŠ›
                        normalPlays.sort((a, b) => evaluate(a).value - evaluate(b).value);
                    }
                    chosenCards = normalPlays[0]; 
                } 
                // æ€ªç‰©ç‰ŒæŠ•è³‡å ±é…¬ç‡åˆ¤å®š (ä¿ç•™ä¸Šä¸€ç‰ˆçš„å„ªè‰¯å‚³çµ±)
                else if (monsterPlays.length > 0) {
                    let isWorthIt = false;
                    if (isDanger || last.monsterLevel > 0 || hand.length <= 5) isWorthIt = true; 
                    if ((last.type === 1 || last.type === 2) && last.value >= 140) isWorthIt = true;
                    if (isWorthIt) {
                        monsterPlays.sort((a, b) => evaluate(a).value - evaluate(b).value);
                        chosenCards = monsterPlays[0]; 
                    }
                }
            } else { 
                // ğŸŒŸ ç°¡å–®æ¨¡å¼ï¼šæœ‰ç‰Œå°±å£“ï¼Œä¸ç®¡ä¸‰ä¸ƒäºŒåä¸€
                validPlays.sort((a, b) => evaluate(a).value - evaluate(b).value);
                chosenCards = validPlays[0]; 
            }
        }
    }
    
    if(chosenCards) executePlay(chosenCards, evaluate(chosenCards), false); else executePass();
}

/* ===== ç©å®¶æ“ä½œ UX ===== */
function smartSelect(i) {
    let targetRank = players[0][i].rank; selected = [];
    players[0].forEach((c, idx) => { if (c.rank === targetRank) selected.push(idx); });
    renderPlayer(); playSound(sndPlayCard);
}

function showHint() {
    if(current !== 0) return; let hand = players[0]; let allPlays = []; 
    allPlays.push(...hand.map(c => [c])); allPlays.push(...getCombinations(hand, 2).filter(c => evaluate(c)?.type === 2)); allPlays.push(...getCombinations(hand, 3).filter(c => evaluate(c)?.type === 3)); 
    if (hand.length >= 5) allPlays.push(...getCombinations(hand, 5).filter(c => evaluate(c) !== null));
    let chosenCards = null;

    if (last == null) {
        if (isFirstTurn) {
            let valid = allPlays.filter(play => play.some(c => c.rank == 3 && c.suit == "â™£"));
            if (valid.length > 0) chosenCards = valid.sort((a, b) => evaluate(a).value - evaluate(b).value)[0];
        } else { chosenCards = allPlays.sort((a, b) => evaluate(a).value - evaluate(b).value)[0]; }
    } else {
        let validPlays = allPlays.filter(combo => { let evalC = evaluate(combo); return evalC && canBeat(evalC, last); });
        if (validPlays.length > 0) chosenCards = validPlays.sort((a, b) => evaluate(a).value - evaluate(b).value)[0];
    }

    if (chosenCards) {
        selected = [];
        chosenCards.forEach(cc => { let idx = hand.findIndex(hc => hc.rank === cc.rank && hc.suit === cc.suit); if (idx !== -1) selected.push(idx); });
        renderPlayer(); updateInfo("ğŸ’¡ å·²ç‚ºæ‚¨é¸å–å»ºè­°ç‰Œå‹ï¼");
    } else { updateInfo("âš ï¸ ç›®å‰å®Œå…¨ç„¡ç‰Œå¯å‡ºï¼Œè«‹æŒ‰ Passï¼"); }
}

function checkAutoPass() {
    if (current === 0 && last !== null) {
        let hand = players[0]; let allPlays = []; 
        allPlays.push(...hand.map(c => [c])); allPlays.push(...getCombinations(hand, 2).filter(c => evaluate(c)?.type === 2)); allPlays.push(...getCombinations(hand, 3).filter(c => evaluate(c)?.type === 3)); 
        if (hand.length >= 5) allPlays.push(...getCombinations(hand, 5).filter(c => evaluate(c) !== null));
        let canPlay = allPlays.some(combo => { let evalC = evaluate(combo); return evalC && canBeat(evalC, last); });
        if (!canPlay) {
            updateInfo("âš ï¸ ç„¡ç‰Œå¯å£“ï¼Œ1.5ç§’å¾Œè‡ªå‹• Pass...");
            setTimeout(() => { if(current === 0) pass(); }, 1500);
        } else { updateInfo("âœ¨ è¼ªåˆ°ä½ äº†ï¼Œè«‹å‡ºç‰Œ (é›™æ“Šç‰Œé¢å¯é¸å–)"); }
    } else if (current === 0 && last === null) { updateInfo("âœ¨ ç²å¾—ç‰Œæ¬Šï¼Œè«‹è‡ªç”±å‡ºç‰Œ"); }
}

function play(){
    if(current != 0) return; if(selected.length == 0) return; 
    let cards = selected.map(i => players[0][i]); let r = evaluate(cards);
    if(!r){ updateInfo("âš ï¸ é•åè¦å‰‡ï¼šç„¡æ•ˆç‰Œå‹æˆ–ä¸å…è¨±å‡ºç´”åŒèŠ±ï¼"); return; }
    if(last == null){ 
        if(isFirstTurn && !cards.some(c => c.rank == 3 && c.suit == "â™£")){ updateInfo("âš ï¸ é¦–å±€å¿…é ˆåŒ…å«æ¢…èŠ± 3ï¼"); return; } 
        isFirstTurn = false; 
    } else { if(!canBeat(r, last)){ updateInfo("âš ï¸ ç‰Œå‹ä¸ç¬¦æˆ–é»æ•¸å¤ªå°ï¼"); return; } }
    executePlay(cards, r, true);
}

function pass(){ if(current != 0) return; if(last == null){ updateInfo("âš ï¸ æ“æœ‰ç‰Œæ¬Šæ™‚ä¸èƒ½ Passï¼"); return; } selected = []; renderPlayer(); executePass(); }
function executePass(){
    consecutivePasses++; updateInfo(`ç©å®¶ ${current} é¸æ“‡ Pass`);
    if(consecutivePasses >= 3){ 
        last = null; consecutivePasses = 0; current = lastPlayer; renderTable([]); renderOpponents(); 
        if(current === 0) checkAutoPass(); else { updateInfo(`ğŸ”„ ç‰Œæ¬Šå›åˆ° é›»è…¦ ${current}`); setTimeout(()=>{ aiPlay(); }, 1200); }
    } else { current = (current + 1) % 4; renderOpponents(); if(current != 0) setTimeout(()=>{ aiPlay(); }, 1200); else checkAutoPass(); }
}

/* ===== çµç®—èˆ‡æˆå°±çµ±è¨ˆåˆ¤å®š ===== */
function shootConfetti() {
    const container = document.getElementById('confetti-container'); container.style.display = 'block';
    const colors = ['#ffc300', '#d90429', '#4ade80', '#3b82f6', '#a855f7', '#ff007f'];
    for (let i = 0; i < 200; i++) {
        let conf = document.createElement('div'); conf.className = 'confetti'; conf.style.left = Math.random() * 100 + 'vw';
        conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        conf.style.animationDuration = (Math.random() * 3 + 2) + 's'; conf.style.animationDelay = (Math.random() * 1.5) + 's';
        container.appendChild(conf);
    }
}

function showScoreModal(winnerIndex) {
    let roundScores = [0, 0, 0, 0]; let winnerEarnings = 0; let hasOpponentWith13 = false;
    for (let i = 0; i < 4; i++) {
        if (i !== winnerIndex) {
            let remain = players[i].length; let penalty = remain;
            if (remain === 13) { penalty *= 3; hasOpponentWith13 = true; } 
            else if (remain >= 10) penalty *= 2;
            roundScores[i] -= penalty; winnerEarnings += penalty; 
        }
    }
    roundScores[winnerIndex] += winnerEarnings;
    
    playerStats.matches++;
    if (winnerIndex === 0) {
        playerStats.wins++;
        if (winnerEarnings > playerStats.maxScore) playerStats.maxScore = winnerEarnings;
        unlockAchievement("firstBlood"); if (hasOpponentWith13) unlockAchievement("cleanSweep");
    }
    saveStats(); 

    let hasUltimate = false;
    for (let i = 0; i < 4; i++) { totalScores[i] += roundScores[i]; if (totalScores[i] >= 100) hasUltimate = true; }
    localStorage.setItem("big2_scores", JSON.stringify(totalScores));

    if (hasUltimate) { shootConfetti(); if (totalScores[0] >= 100) unlockAchievement("centurion"); }

    document.getElementById("modalTitle").innerHTML = hasUltimate ? `ğŸ‘‘ ç¸½å† è»èª•ç”Ÿï¼` : (winnerIndex === 0 ? `ğŸ† ä½ è´äº†ï¼(+${winnerEarnings})` : `ğŸ˜¢ é›»è…¦ ${winnerIndex} ç²å‹`);
    let scoresHtml = "";
    for (let i = 0; i < 4; i++) scoresHtml += `<div style="padding:5px">â¤ ${i===0?"ä½ ":`é›»è…¦${i}`}ï¼š${i===winnerIndex?"è´å®¶":`å‰© ${players[i].length} å¼µ`} <span style="float:right">${roundScores[i]} (ç¸½åˆ†: ${totalScores[i]})</span></div>`;
    document.getElementById("modalScores").innerHTML = scoresHtml; 
    document.getElementById("scoreModal").style.display = "flex";
}

function resetScores() { localStorage.removeItem("big2_scores"); location.reload(); }
function next(){ if(players[current].length === 0){ setTimeout(() => { showScoreModal(current); }, 500); return; } current = (current + 1) % 4; renderOpponents(); if(current != 0) setTimeout(()=>{ aiPlay(); }, 1200); else checkAutoPass(); }

/* ===== åˆå§‹åŒ– ===== */
function init(){
    renderScoreboard(); createDeck(); shuffle(); deal(); findStarter(); renderOpponents();
    setTimeout(() => {
        renderPlayer(true);
        isFirstTurn = true; lastPlayer = current; updateInfo(`âœ¨ éŠæˆ²é–‹å§‹ï¼ç”± ç©å®¶ ${current} å…ˆå‡ºç‰Œ`);
        if(current !== 0) setTimeout(()=>{ aiPlay(); }, 1800); else checkAutoPass();
    }, 500);
}
init();
</script>
</body>
</html>


